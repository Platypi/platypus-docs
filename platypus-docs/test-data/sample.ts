/* tslint:disable *//** * PlatypusTS v0.9.0 (http://getplatypi.com)  * Copyright 2014 Platypi, LLC. All rights reserved.  *  * PlatypusTS is licensed under the GPL-3.0 found at   * http://opensource.org/licenses/GPL-3.0  *  */ /**  * @name plat  * @kind namespace  *   * @description  * The entry point into the platypus library.  */module plat {    /* tslint:disable:no-unused-variable */    /*     * Injectables     */    var __AppStatic = '$AppStatic',        __App = '$App',        __Http = '$Http',        __HttpConfig = '$HttpConfig',        __Promise = '$Promise',        __Compat = '$Compat',        __ControlFactory = '$ControlFactory',        __AttributeControlFactory = '$AttributeControlFactory',        __Document = '$Document',        __DispatchEventInstance = '$DispatchEventInstance',        __ErrorEventStatic = '$ErrorEventStatic',        __EventManagerStatic = '$EventManagerStatic',        __LifecycleEventStatic = '$LifecycleEventStatic',        __NavigationEventStatic = '$NavigationEventStatic',        __ExceptionStatic = '$ExceptionStatic',        __Parser = '$Parser',        __Regex = '$Regex',        __Tokenizer = '$Tokenizer',        __NavigatorInstance = '$NavigatorInstance',        __RoutingNavigator = '$RoutingNavigator',        __ContextManagerStatic = '$ContextManagerStatic',        __Compiler = '$Compiler',        __CommentManagerFactory = '$CommentManagerFactory',        __ElementManagerFactory = '$ElementManagerFactory',        __NodeManagerStatic = '$NodeManagerStatic',        __TextManagerFactory = '$TextManagerFactory',        __CacheFactory = '$CacheFactory',        __ManagerCache = '$ManagerCache',        __TemplateCache = '$TemplateCache',        __Animator = '$Animator',        __AttributesInstance = '$AttributesInstance',        __BindableTemplatesFactory = '$BindableTemplatesFactory',        __Dom = '$Dom',        __DomEvents = '$DomEvents',        __DomEventsConfig = '$DomEventsConfig',        __DomEventInstance = '$DomEventInstance',        __ResourcesFactory = '$ResourcesFactory',        __TemplateControlFactory = '$TemplateControlFactory',        __BaseViewControlFactory = '$BaseViewControlFactory',        __Utils = '$Utils',        __Browser = '$Browser',        __BrowserConfig = '$BrowserConfig',        __Router = '$Router',        __UrlUtilsInstance = '$UrlUtilsInstance',        __Window = '$Window',        __LocalStorage = '$LocalStorage',        __SessionStorage = '$SessionStorage',        __Geolocation = '$Geolocation',            /**         * Controls         */        __Plat = 'plat-',        __Bind = __Plat + 'bind',        __Href = __Plat + 'href',        __Src = __Plat + 'src',        __KeyDown = __Plat + 'keydown',        __KeyPress = __Plat + 'keypress',        __KeyUp = __Plat + 'keyup',        __Name = __Plat + 'name',        __Options = __Plat + 'options',        __Checked = __Plat + 'checked',        __Disabled = __Plat + 'disabled',        __Selected = __Plat + 'selected',        __ReadOnly = __Plat + 'readonly',        __Visible = __Plat + 'visible',        __Style = __Plat + 'style',        __Tap = __Plat + 'tap',        __Blur = __Plat + 'blur',        __Change = __Plat + 'change',        __Copy = __Plat + 'copy',        __Cut = __Plat + 'cut',        __Paste = __Plat + 'paste',        __DblTap = __Plat + 'dbltap',        __Focus = __Plat + 'focus',        __Submit = __Plat + 'submit',        __TouchStart = __Plat + 'touchstart',        __TouchEnd = __Plat + 'touchend',        __TouchMove = __Plat + 'touchmove',        __TouchCancel = __Plat + 'touchcancel',        __Hold = __Plat + 'hold',        __Release = __Plat + 'release',        __Swipe = __Plat + 'swipe',        __SwipeLeft = __Plat + 'swipeleft',        __SwipeRight = __Plat + 'swiperight',        __SwipeUp = __Plat + 'swipeup',        __SwipeDown = __Plat + 'swipedown',        __Track = __Plat + 'track',        __TrackLeft = __Plat + 'trackleft',        __TrackRight = __Plat + 'trackright',        __TrackUp = __Plat + 'trackup',        __TrackDown = __Plat + 'trackdown',        __TrackEnd = __Plat + 'trackend',        __Anchor = 'a',        __ForEach = __Plat + 'foreach',        __Html = __Plat + 'html',        __If = __Plat + 'if',        __Ignore = __Plat + 'ignore',        __Select = __Plat + 'select',        __Template = __Plat + 'template',        __Routeport = __Plat + 'routeport',        __Viewport = __Plat + 'viewport',            /**         * Animations         */        __Hide = __Plat + 'hide',        __Animating = __Plat + 'animating',        __SimpleAnimation = __Plat + 'animation',        __SimpleTransition = __Plat + 'transition',        __Enter = __Plat + 'enter',        __Leave = __Plat + 'leave',        __Move = __Plat + 'move',        __FadeIn = __Plat + 'fadein',        __FadeOut = __Plat + 'fadeout',            /**         * Custom events         */        __$tap = '$tap',        __$dbltap = '$dbltap',        __$touchstart = '$touchstart',        __$touchend = '$touchend',        __$touchmove = '$touchmove',        __$touchcancel = '$touchcancel',        __$hold = '$hold',        __$release = '$release',        __$swipe = '$swipe',        __$swipeleft = '$swipeleft',        __$swiperight = '$swiperight',        __$swipeup = '$swipeup',        __$swipedown = '$swipedown',        __$track = '$track',        __$trackleft = '$trackleft',        __$trackright = '$trackright',        __$trackup = '$trackup',        __$trackdown = '$trackdown',        __$trackend = '$trackend',            /**         * Constants         */        __startSymbol = '{{',        __endSymbol = '}}',        __STATIC = 'static',        __SINGLETON = 'singleton',        __INSTANCE = 'instance',        __FACTORY = 'factory',        __CLASS = 'class',        __CSS = 'css',        __COMPILED = '-compiled',        __BOUND_PREFIX = '-@',        __START_NODE = ': start node',        __END_NODE = ': end node',        __JS = 'js',        __noopInjector = 'noop';    /* tslint:enable:no-unused-variable */        /* tslint:disable:no-unused-variable */    var __nativeIsArray = !!Array.isArray,        __uids__: plat.IObject<Array<string>> = {};        function noop(): void { }        function extend(destination: any, ...sources: any[]): any {        if (isNull(destination)) {            return destination;        }            var deep = isBoolean(destination);            if (deep) {            destination = sources.shift();        }            var keys: Array<string>,            property: any;            forEach(sources, (source, k) => {            if (!isObject(source)) {                return;            }                keys = Object.keys(source);                forEach(keys, (key) => {                property = source[key];                if (deep) {                    if (isArray(property)) {                        extend(deep, destination[key] || (destination[key] = []), property);                        return;                    } else if (isDate(property)) {                        destination[key] = new Date(property.getTime());                        return;                    } else if (isRegExp(property)) {                        destination[key] = new RegExp(property);                        return;                    } else if (isNode(property)) {                        destination[key] = (<Node>property).cloneNode(true);                        return;                    } else if (isObject(property)) {                        extend(deep, destination[key] || (destination[key] = {}), property);                        return;                    }                }                destination[key] = property;            });        });            return destination;    }        function deepExtend(destination: any, ...sources: any[]): any {        return extend.apply(null, [true, destination].concat(sources));    }        function _clone(obj: any, deep?: boolean) {        if (!isObject(obj)) {            return obj;        } else if (isDate(obj)) {            return new Date((<Date>obj).getTime());        } else if (isRegExp(obj)) {            return new RegExp(obj);        } else if (isNode(obj)) {            return (<Node>obj).cloneNode(deep);        } else if (isError(obj)) {            return new obj.constructor((<Error>obj).message);        }            var type = {};            if (isArray(obj)) {            type = [];        }            if (isBoolean(deep) && deep) {            return deepExtend(type, obj);        }            return extend(type, obj);    }        function isError(obj: any): boolean {        return Object.prototype.toString.call(obj) === '[object Error]';    }        function isObject(obj: any): boolean {        return obj != null && typeof obj === 'object';    }        function isWindow(obj: any): boolean {        return !!(obj && obj.document && obj.setInterval);    }        function isDocument(obj: any): boolean {        return !!(obj && obj.nodeType === Node.DOCUMENT_NODE);    }        function isNode(obj: any): boolean {        return !!(obj && typeof obj.nodeType === 'number');    }        function isDocumentFragment(obj: any): boolean {        return !!(obj && (<Node>obj).nodeType === Node.DOCUMENT_FRAGMENT_NODE);    }        function isFile(obj: any): boolean {        return isObject(obj) && obj.toString() === '[object File]';    }        function isString(obj: any): boolean {        return typeof obj === 'string';    }        function isRegExp(obj: any): boolean {        return Object.prototype.toString.call(obj) === '[object RegExp]';    }        function isPromise(obj: any): boolean {        return isObject(obj) && (obj.toString() === '[object Promise]' || isFunction(obj.then));    }        function isEmpty(obj: any): boolean {        if (isNull(obj)) {            return true;        }            if (isString(obj) || isArray(obj)) {            return obj.length === 0;        }            if (!isObject(obj)) {            return false;        }            return Object.keys(obj).length === 0;    }        function isBoolean(obj: any): boolean {        return typeof obj === 'boolean';    }        function isNumber(obj: any): boolean {        return typeof obj === 'number' && !isNaN(obj);    }        function isFunction(obj: any): boolean {        return typeof obj === 'function';    }        function isNull(obj: any): boolean {        return obj === null || obj === undefined;    }        function isUndefined(obj: any): boolean {        return obj === undefined;    }        function isArray(obj: any): boolean {        if (__nativeIsArray) {            return Array.isArray(obj);        }            return Object.prototype.toString.call(obj) === '[object Array]';    }        function isArrayLike(obj: any): boolean {        if (isNull(obj) || isWindow(obj) || isFunction(obj)) {            return false;        }            return isString(obj) || obj.length >= 0;    }        function isDate(obj: any): boolean {        return Object.prototype.toString.call(obj) === '[object Date]';    }        function filter<T>(obj: any, iterator: (value: T, key: any, obj: any) => boolean, context?: any): Array<T> {        var arr: Array<T> = [];        if (isNull(obj)) {            return arr;        }            if (isFunction(obj.filter)) {            return obj.filter(iterator, context);        }            forEach<T>(obj, (value: T, key: any, obj: any) => {            if (iterator(value, key, obj)) {                arr.push(value);            }        });            return arr;    }        function where(obj: any, properties: any): Array<any> {        return filter(obj, (value)            => !some(properties, (property, key)                => (<any>value)[key] !== property));    }        function forEach<T>(array: Array <T>, iterator: (value: T, index: number, obj: any) => void, context?: any): Array < T>;    function forEach<T>(obj: any, iterator: (value: T, key: string, obj: any) => void, context?: any): any;    function forEach<T>(obj: any, iterator: (value: T, key: any, obj: any) => void, context?: any): any {        if (isNull(obj) || !(isObject(obj) || isArrayLike(obj))) {            return obj;        }            var i: number,            key: string,            length: number;            if (isFunction(obj.forEach)) {            return obj.forEach(iterator, context);        } else if (isArrayLike(obj)) {            for (i = 0, length = obj.length; i < length; ++i) {                iterator.call(context, obj[i], i, obj);            }        } else {            var keys = Object.keys(obj);            length = keys.length;            while (keys.length > 0) {                key = keys.shift();                iterator.call(context, obj[key], key, obj);            }        }            return obj;    }        function map<T, U>(obj: any, iterator: (value: T, key: any, obj: any) => U, context?: any): Array<U> {        var arr: Array<U> = [];            if (isNull(obj)) {            return arr;        }            if (isFunction(obj.map)) {            return obj.map(iterator, context);        }            forEach(obj, (value, key) => {            arr.push(iterator.call(context, value, key, obj));        });            return arr;    }        function pluck<T, U>(obj: any, key: string): Array<U> {        return map<T, U>(obj, (value) => (<any>value)[key]);    }        function some<T>(obj: any, iterator: (value: T, key: any, obj: any) => boolean, context?: any): boolean {        if (isNull(obj) || isFunction(obj)) {            return false;        }            var i: number,            key: string,            length: number,            ret: boolean;            if (isFunction(obj.some)) {            return obj.some(iterator, context);        } else if (isArrayLike(obj)) {            for (i = 0, length = obj.length; i < length; ++i) {                ret = iterator.call(context, obj[i], i, obj);                if (ret === true) {                    return true;                }            }        } else {            var keys = Object.keys(obj);            length = keys.length;            while (keys.length > 0) {                key = keys.shift();                ret = iterator.call(context, obj[key], key, obj);                if (ret === true) {                    return true;                }            }        }            return false;    }        function postpone(method: (...args: any[]) => void, args?: Array<any>, context?: any): plat.IRemoveListener {        return defer(method, 0, args, context);    }        function defer(method: (...args: any[]) => void, timeout: number, args?: Array<any>, context?: any): plat.IRemoveListener {        function defer() {            method.apply(context, args);        }            var timeoutId = setTimeout(defer, timeout);            return () => {            clearTimeout(timeoutId);        };    }        function uniqueId(prefix?: string): string {        if (isNull(prefix)) {            prefix = '';        }            var puid = __uids__[prefix];            if (isNull(puid)) {            puid = __uids__[prefix] = ['0', '/'];        }            var index = puid.length,            charCode: number;            while (index--) {            charCode = puid[index].charCodeAt(0);            // '9'            if (charCode === 57) {                puid[index] = 'A';                return join();            }                // 'Z'            if (charCode === 90) {                puid[index] = 'a';                return join();            }                // 'z'            if (charCode === 122) {                puid[index] = '0';            } else {                puid[index] = String.fromCharCode(charCode + 1);                return join();            }        }            puid.unshift('0');            function join(): string {            return prefix + puid.join('');        }            return join();    }        var camelCaseRegex: RegExp;        function camelCase(str: string): string {        if (!isString(str) || isEmpty(str)) {            return str;        }            str = str.charAt(0).toLowerCase() + str.substr(1);        camelCaseRegex = camelCaseRegex || (<plat.expressions.IRegex>plat.acquire(__Regex)).camelCaseRegex;            return str.replace(camelCaseRegex,            (match: string, delimiter?: string, char?: string, index?: number)                => index ? char.toUpperCase() : char);    }        function deleteProperty(obj: any, property: number): any;    function deleteProperty(obj: any, property: string): any;    function deleteProperty(obj: any, property: any): any {        if (!isNull(obj)) {            /* tslint:disable:no-unused-expression */            delete obj[property];            /* tslint:enable:no-unused-expression */        }            return obj;    }        function access(obj: any, property: number): any;    function access(obj: any, property: string): any;    function access(obj: any, property: any): any {        if (isNull(obj)) {            return obj;        }        return obj[property];    }    /* tslint:enable:no-unused-variable */        /* tslint:disable:no-unused-variable */    var __nodeNameRegex = /<([\w:]+)/,        __option = [1, '<select multiple="multiple">', '</select>'],        __table = [1, '<table>', '</table>'],        __tableData = [3, '<table><tbody><tr>', '</tr></tbody></table>'],        __svg = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', '</svg>'],        __innerTableWrappers: plat.IObject<Array<any>> = {            thead: __table,            tbody: __table,            tfoot: __table,            colgroup: __table,            caption: __table,            tr: [2, '<table><tbody>', '</tbody></table>'],            col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],            td: __tableData,            th: __tableData        },        __innerHtmlWrappers: plat.IObject<Array<any>> = extend({}, __innerTableWrappers, {            option: __option,            optgroup: __option,            legend: [1, '<fieldset>', '</fieldset>'],            area: [1, '<map>', '</map>'],            param: [1, '<object>', '</object>'],            text: __svg,            circle: __svg,            ellipse: __svg,            line: __svg,            path: __svg,            polygon: __svg,            polyline: __svg,            rect: __svg,            _default: [0, '', '']        });        function appendChildren(nodeList: any, root?: Node): Node {        var isFragment = isDocumentFragment(root),            nullRoot = isNull(root),            fragment: DocumentFragment = isFragment ?            <DocumentFragment>root :            (plat.acquire(__Document)).createDocumentFragment();            if (nullRoot) {            root = fragment;        }            var list: Array<Node>;            if (isFunction(nodeList.push)) {            list = nodeList;        } else {            list = Array.prototype.slice.call(nodeList);        }            while (list.length > 0) {            fragment.insertBefore(list.shift(), null);        }            if (!(isFragment || nullRoot)) {            root.appendChild(fragment);        }            return root;    }        function clearNode(node: Node): void {        var childNodes = Array.prototype.slice.call(node.childNodes);            while (childNodes.length > 0) {            node.removeChild(childNodes.pop());        }    }        function clearNodeBlock(nodeList: any, parent: Node): void {        if (!isFunction(nodeList.push)) {            nodeList = Array.prototype.slice.call(nodeList);        }            if (!isNull(parent)) {            clearNodeBlockWithParent(nodeList, parent);            return;        }            var node: Node;            while (nodeList.length > 0) {            node = nodeList.pop();            parent = node.parentNode;                if (isNull(parent)) {                continue;            }                parent.removeChild(node);        }    }        function clearNodeBlockWithParent(nodeList: Array<Node>, parent: Node): void {        while (nodeList.length > 0) {            parent.removeChild(nodeList.pop());        }    }        function stringToNode(html: string): Node {        var $compat: plat.ICompat = plat.acquire(__Compat),            $document: Document = plat.acquire(__Document),            nodeName = __nodeNameRegex.exec(html),            element = <HTMLElement>$document.createElement('div');            if (isNull(nodeName)) {            element = innerHtml(element, html);            return element.removeChild(element.lastChild);        }            // trim html string        html = html.trim();            var mapTag = nodeName[1];            if ($compat.pushState && isUndefined(__innerTableWrappers[mapTag])) {            return innerHtml(element, html);        } else if (mapTag === 'body') {            element = innerHtml($document.createElement('html'), html);            return element.removeChild(element.lastChild);        }            var wrapper = __innerHtmlWrappers[mapTag] || (<any>__innerHtmlWrappers)._default,            depth = wrapper[0],            parentStart = wrapper[1],            parentEnd = wrapper[2];            element = innerHtml(element, parentStart + html + parentEnd);            while (depth-- > 0) {            element = <HTMLElement>element.lastChild;        }            return element;    }        function setInnerHtml(node: Node, html: string): Node {        clearNode(node);            if (isEmpty(html)) {            return;        }            var element = stringToNode(html);            if (element.childNodes.length > 0) {            appendChildren(element.childNodes, node);        } else {            node.insertBefore(element, null);        }            return node;    }        function insertBefore(parent: Node, nodes: any, endNode?: Node): Array<Node> {        if (isNull(parent) || !isObject(nodes)) {            return;        } else if (isUndefined(endNode)) {            endNode = null;        }            var fragment: DocumentFragment;            if (isNode(nodes)) {            fragment = nodes;                nodes = Array.prototype.slice.call(fragment.childNodes);            parent.insertBefore(fragment, endNode);                return nodes;        }            if (!isFunction(nodes.push)) {            nodes = Array.prototype.slice.call(nodes);        }            var $document = plat.acquire(__Document),            length = nodes.length;            fragment = $document.createDocumentFragment();            for (var i = 0; i < length; ++i) {            fragment.insertBefore(nodes[i], null);        }            parent.insertBefore(fragment, endNode);            return nodes;    }        function replace(node: Node): Array<Node> {        var parent = node.parentNode,            nodes = insertBefore(parent, node.childNodes, node);            parent.removeChild(node);            return nodes;    }        function replaceWith(node: Node, newNode: HTMLElement): HTMLElement;    function replaceWith(node: Node, newNode: Element): Element;    function replaceWith(node: Node, newNode: Node): Node;    function replaceWith(node: any, newNode: any): any {        if (isNull(newNode)) {            return newNode;        }            if (node.nodeType === Node.ELEMENT_NODE) {            var attributes = node.attributes,                length = attributes.length,                attribute: Attr;                for (var i = 0; i < length; ++i) {                attribute = attributes[i];                newNode.setAttribute(attribute.name, attribute.value);            }        }            var parent = node.parentNode;            insertBefore(newNode, node.childNodes);        parent.replaceChild(newNode, node);            return newNode;    }        function serializeHtml(html?: string): DocumentFragment {        var $document = plat.acquire(__Document),            templateElement = $document.createDocumentFragment();            if (!isEmpty(html)) {            setInnerHtml(templateElement, html);        }            return templateElement;    }        function removeBetween(startNode: Node, endNode?: Node): void {        if (isNull(startNode)) {            return;        }            var currentNode = startNode.nextSibling,            parentNode = startNode.parentNode,            tempNode: Node;            if (isNull(endNode)) {            endNode = null;        }            if (isNull(parentNode) || (!isNull(endNode) && endNode.parentNode !== parentNode)) {            return;        }            while (currentNode !== endNode) {            tempNode = currentNode.nextSibling;            parentNode.removeChild(currentNode);            currentNode = tempNode;        }    }        function removeAll(startNode: Node, endNode?: Node): void {        if (isNull(startNode)) {            return;        }            removeBetween(startNode, endNode);            removeNode(startNode);        removeNode(endNode);    }        /**     * Safely sets innerHTML of an element. Uses MSApp.execUnsafeLocalFunction if      * available.     */    function innerHtml(element: HTMLElement, html: string): HTMLElement {        var $compat: plat.ICompat = plat.acquire(__Compat);            if ($compat.msApp) {            MSApp.execUnsafeLocalFunction(() => {                element.innerHTML = html;            });        } else {            element.innerHTML = html;        }            return element;    }        function removeNode(node: Node): void {        if (isNull(node)) {            return;        }            var parentNode = node.parentNode;            if (!isNull(parentNode)) {            node.parentNode.removeChild(node);        }    }        function addClass(element: HTMLElement, className: string): void {        if (isUndefined(element.classList)) {            if (isEmpty(element.className)) {                element.className = className;                return;            }                element.className += ' ' + className;            return;        }            element.classList.add(className);    }        function removeClass(element: HTMLElement, className: string): void {        if (isUndefined(element.classList)) {            if (element.className === className) {                element.className = '';                return;            }                element.className = element.className                .replace(new RegExp('^' + className + '\\s|\\s' + className + '$|\\s' + className + '|' + className + '\\s', 'g'), '');            return;        }            element.classList.remove(className);    }        function toggleClass(element: HTMLElement, className: string): void {        if (isUndefined(element.classList)) {            var name = element.className;            if (name === '') {                element.className = className;            } else if (name === className) {                element.className = '';                return;            }                var classNameRegex = new RegExp('^' + className + '\\s|\\s' + className + '$|\\s' + className + '|' + className + '\\s', 'g');            if (classNameRegex.test(name)) {                element.className = name.replace(classNameRegex, '');                return;            }                element.className += ' ' + className;            return;        }            element.classList.toggle(className);    }        function hasClass(element: HTMLElement, className: string): boolean {        if (isUndefined(element.classList)) {            var name = element.className;            if (name === '') {                return false;            } else if (name === className) {                return true;            }                return new RegExp('^' + className + '\\s|\\s' + className + '$|\\s' + className + '|' + className + '\\s', 'g').test(name);        }            return element.classList.contains(className);    }    /* tslint:enable:no-unused-variable */        /**     * An IInjectorObject of plat.IControls. Contains all the registered     * controls for an application.     */    var controlInjectors: plat.dependency.IInjectorObject<plat.IControl> = {};        /**     * An IInjectorObject of plat.ui.IBaseViewControls. Contains all the registered     * view controls for an application.     */    var viewControlInjectors: plat.dependency.IInjectorObject<plat.ui.IBaseViewControl> = {};        /**     * An IInjectorObject of objects. Contains all the registered     * injectables for an application.     */    var injectableInjectors: plat.dependency.IInjectorObject<plat.dependency.IInjector<any>> = {};        /**     * An IInjectorObject of static objects. Contains all the registered     * static injectables for an application.     */    var staticInjectors: plat.dependency.IInjectorObject<plat.dependency.IInjector<any>> = {};        /**     * An IInjectorObject of animations. Can be either CSS or JS implementations.     */    var animationInjectors: plat.dependency.IInjectorObject<plat.ui.IBaseAnimation> = {};        /**     * An IInjectorObject of animations. Should only contain JS implementations.     */    var jsAnimationInjectors: plat.dependency.IInjectorObject<plat.ui.IBaseAnimation> = {};        export module register {        /**         * Generic function for creating an Injector and adding it to an IInjectorObject.         *          * @param obj The IInjectorObject to which to add an Injector.         * @param name The name used to set/get the Injector from the IInjectorObject.         * @param Type The constructor or function definition for the Injector.         * @param dependencies An array of strings representing the dependencies needed for the         * injector.         * @param injectableType The injectable type.         * @param isStatic The injectable type is a static type.         *          * @returns {register} The object that contains the register methods (for method chaining).         */        function add(obj: dependency.IInjectorObject<any>, name: string, Type: any, dependencies?: Array<any>,            injectableType?: string, isStatic?: boolean): typeof register {            var injector = obj[name] = new dependency.Injector<any>(name, Type, dependencies, injectableType);            if (isStatic === true) {                staticInjectors[name] = injector;            }            return register;        }        /**         * Registers the IApp with the framework. The framework will instantiate the IApp when needed, and wire up         * the Application Lifecycle events. The dependencies array corresponds to injectables that will be          * passed into the Constructor of the app.         *          * @param name The name of your app.         * @param Type The constructor for the IApp.         * @param dependencies An array of strings representing the dependencies needed for the app injector.         */        export function app(name: string, Type: new (...args: any[]) => IApp, dependencies?: Array<any>): typeof register {            var app = new dependency.Injector<IApp>(name, Type, dependencies),                $appStatic: IAppStatic = acquire(__AppStatic);            $appStatic.registerApp(app);            return register;        }        /**         * Registers an IControl with the framework. The framework will instantiate the IControl when needed. The          * dependencies array corresponds to injectables that will be passed into the Constructor of the control.         *          * @param name The control type, corresponding to the HTML notation for creating a new IControl (e.g. 'plat-foreach').         * @param Type The constructor for the IControl.         * @param dependencies An array of strings representing the dependencies needed for the IControl injector.         *          * @example plat.register.control('my-tap', MyTap, [plat.expressions.IParser]);         */        export function control(name: string, Type: new (...args: any[]) => IControl, dependencies?: Array<any>): typeof register {            if (isString(name)) {                name = name.toLowerCase();            } else {                throw new Error('A Control must be registered with a string name');            }            return add(controlInjectors, name, Type, dependencies);        }        /**         * Registers a ViewControl with the framework. The framework will instantiate the control when needed. The          * dependencies array corresponds to injectables that will be passed into the Constructor of the control.         *          * @param name The control type, corresponding to the HTML notation for creating a new IViewControl. Used for navigation          * to the specified ViewControl.         * @param Type The constructor for the IViewControl.         * @param dependencies An optional array of strings representing the dependencies needed for the IViewControl injector.         *          * @example plat.register.viewControl('my-view-control', MyViewControl);         */        export function viewControl(name: string, Type: new (...args: any[]) => ui.IViewControl,            dependencies?: Array<any>): typeof register;        /**         * Registers a WebViewControl with the framework. The framework will instantiate the control when needed. The          * dependencies array corresponds to injectables that will be passed into the Constructor of the control.         *          * @param name The control type, corresponding to the HTML notation for creating a new IWebViewControl. Used for navigation          * to the specified WebViewControl.         * @param Type The constructor for the IWebViewControl.         * @param dependencies An optional array of strings representing the dependencies needed for the IWebViewControl injector.         * @param routes Optional route strings (or regular expressions) used for matching a URL to the registered IWebViewControl.         *          * @example plat.register.viewControl('my-view-control', MyViewControl, null, ['customers/:customer(/:ordernumber)']);         */        export function viewControl(name: string, Type: new (...args: any[]) => ui.IWebViewControl,            dependencies: Array<any>, routes: Array<any>): typeof register;        export function viewControl(name: string, Type: new (...args: any[]) => ui.IBaseViewControl,            dependencies?: Array<any>, routes?: Array<any>): typeof register {            if (isString(name)) {                name = name.toLowerCase();            } else {                throw new Error('A ViewControl must be registered with a string name');            }            var ret = add(viewControlInjectors, name, Type, dependencies);            if (isArray(routes)) {                var $Router: web.IRouter = acquire(__Router);                $Router.registerRoutes(name, routes);            }            return ret;        }        /**         * Registers an injectable with the framework. Injectables are objects that can be used for dependency injection into other objects.         * The dependencies array corresponds to injectables that will be passed into the Constructor of the injectable.         *          * @param name The name of the injector, used when another component is specifying dependencies.         * @param dependencies An array of strings representing the dependencies needed for the injectable's injector.         * @param Type The constructor for the injectable. The injectable will only be instantiated once during the application         * lifetime.         * @param injectableType Specifies the type of injectable, either plat.register.injectable.SINGLETON,          * plat.register.injectable.STATIC, plat.register.injectable.INSTANCE, plat.register.injectable.FACTORY,          * plat.register.injectable.CLASS (defaults to plat.register.injectable.SINGLETON).         *          * @example plat.register.injectable('$CacheFactory', [plat.expressions.IParser], Cache);         * @example plat.register.injectable('database', MyDatabase, null, register.injectable.INSTANCE);         */        export function injectable(name: string, Type: new (...args: any[]) => any,            dependencies?: Array<any>, injectableType?: string): typeof register;        /**         * Registers an injectable with the framework. Injectables are objects that can be used for dependency injection into other objects.         * The dependencies array corresponds to injectables that will be passed into the injectable method.         *          * @param name The name of the injector, used when another component is specifying dependencies.         * @param dependencies An array of strings representing the dependencies needed for the injectable's injector.         * @param Type The constructor for the injectable. The injectable will only be instantiated once during the application         * lifetime.         * @param injectableType Specifies the type of injectable, either plat.register.injectable.SINGLETON,          * plat.register.injectable.STATIC, plat.register.injectable.INSTANCE, plat.register.injectable.FACTORY,          * plat.register.injectable.CLASS (defaults to plat.register.injectable.SINGLETON).         *          * @returns {register} The object that contains the register methods (for method chaining).         *          * @example plat.register.injectable('$CacheFactory', [plat.expressions.IParser],          *  function(parser: plat.expressions.IParser) { return { ... }; });         * @example plat.register.injectable('database', function() { return new Database(); }, null, register.injectable.INSTANCE);         */        export function injectable(name: string, method: (...args: any[]) => any,            dependencies?: Array<any>, injectableType?: string): typeof register;        export function injectable(name: string, Type: any, dependencies?: Array<any>, injectableType?: string): typeof register {            if (!isString(injectableType)) {                injectableType = __SINGLETON;            } else {                injectableType = injectableType.toLowerCase();                if (injectableType === __FACTORY || injectableType === __STATIC || injectableType === __CLASS) {                    return add(injectableInjectors, name, Type, dependencies, injectableType, true);                } else if (!(injectableType === __SINGLETON || injectableType === __INSTANCE)) {                    throw new Error('Invalid injectable type ' + injectableType + ' during injectable registration.');                }            }            return add(injectableInjectors, name, Type, dependencies, injectableType, false);        }        /**         * A function for registering an injectable that also contains constants for injectable type.         */        export module injectable {                /**                 * Static injectables will be injected before the application loads. This provides a way to create                  * a static constructor and load dependencies into static class properties.                 */                export var STATIC = __STATIC;                /**                 * Singleton injectables will contain a constructor. A Singleton injectable will be instantiated once and                  * used throughout the application lifetime. It will be instantiated when another component is injected                  * and lists it as a dependency.                 */                export var SINGLETON = __SINGLETON;                /**                 * Instance injectables will contain a constructor. An Instance injectable will be instantiated multiple times                  * throughout the application lifetime. It will be instantiated whenever another component is injected                  * and lists it as a dependency.                 */                export var INSTANCE = __INSTANCE;                /**                 * Factory injectables will not contain a constructor but will instead contain a method for obtaining an                  * instance, such as getInstance() or create(). It will be injected before the application loads, similar to a Static                  * injectable.                 */                export var FACTORY = __FACTORY;                /**                 * Class injectables are essentially a direct reference to a class's constructor. It may contain both                  * static and instance methods as well as a constructor for creating a new instance.                 */                export var CLASS = __CLASS;        }        /**         * Adds a CSS animation denoted by its name. If you wish to also support legacy browsers, make sure to register a          * JS implementation as well.         *          * @param name The unique idenitifer of the animation.         * @param Type The constructor for the custom animation.         * @param dependencies Any dependencies that need to be injected into the animation at          * instantiation.         * @param animationType The type of animation. Both the intended type and default value are plat.register.animation.CSS.         */        export function animation(name: string, Type: new (...args: any[]) => ui.ICssAnimation,            dependencies?: Array<any>, animationType?: 'css'): typeof register;        /**         * Adds a CSS animation denoted by its name. If you wish to also support legacy browsers, make sure to register a          * JS implementation as well.         *          * @param name The unique idenitifer of the animation.         * @param Type The constructor for the custom animation.         * @param dependencies Any dependencies that need to be injected into the animation at          * instantiation.         * @param animationType The type of animation. Both the intended type and default value are plat.register.animation.CSS.         */        export function animation(name: string, Type: new (...args: any[]) => ui.ICssAnimation,            dependencies?: Array<any>, animationType?: string): typeof register;        /**         * Adds a JS animation denoted by its name. If  Intended to be used when JS animation implementations for legacy browsers          * is desired.         *          * @param name The unique idenitifer of the animation.         * @param Type The constructor for the custom animation.         * @param dependencies Any dependencies that need to be injected into the animation at          * instantiation.         * @param animationType The type of animation. The intended type is plat.register.animation.JS.         */        export function animation(name: string, Type: new (...args: any[]) => ui.IJsAnimation,            dependencies: Array<any>, animationType: 'js'): typeof register;        /**         * Adds a JS animation denoted by its name. If  Intended to be used when JS animation implementations for legacy browsers          * is desired.         *          * @param name The unique idenitifer of the animation.         * @param Type The constructor for the custom animation.         * @param dependencies Any dependencies that need to be injected into the animation at          * instantiation.         * @param animationType The type of animation. The intended type is plat.register.animation.JS.         */        export function animation(name: string, Type: new (...args: any[]) => ui.IJsAnimation,            dependencies: Array<any>, animationType: string): typeof register;        export function animation(name: string, Type: new (...args: any[]) => ui.IBaseAnimation,            dependencies?: Array<any>, animationType?: string): typeof register {            if (!isString(animationType)) {                animationType = __CSS;            } else {                animationType = animationType.toLowerCase();                if (!(animationType === animation.CSS || animationType === animation.JS)) {                    throw new Error('Invalid animationType "' + animationType + '" during animation registration.');                }            }            return add((animationType === __JS ? jsAnimationInjectors : animationInjectors),                name, Type, dependencies, register.injectable.INSTANCE);        }        /**         * A function for registering animations that also contains constants for animation type.         */        export module animation {                /**                 * A CSS animation.                 */                export var CSS = __CSS;                /**                 * A JavaScript animation.                 */                export var JS = __JS;        }    }        /**     * @name dependency     * @memberof plat     * @kind namespace     *      * @description     * Holds classes and interfaces related to dependency injection.     */    export module dependency {        /**         * @name Injector         * @memberof plat.dependency         * @kind class         *          * @implements {plat.dependency.IInjector}         *          * @description         * The Injector class is used for dependency injection. You can create an injector object,         * specify dependencies and a constructor for your component. When the injector object is         * 'injected' it will create a new instance of your component and pass in the dependencies         * to the constructor.         *          * @typeparam {any} T The type of object that will be returned when the inject method is invoked.         */        export class Injector<T> implements IInjector<T> {            /**             * @name initialize             * @memberof plat.dependency.Injector             * @kind function             * @access public             * @static             *              * @description             * Initializes all static injectors.             *              * @returns {void}             */            static initialize(): void {                var injectors = staticInjectors,                    keys = Object.keys(injectors),                    length = keys.length;                for (var i = 0; i < length; ++i) {                    injectors[keys[i]].inject();                }                staticInjectors = {};            }            /**             * @name getDependencies             * @memberof plat.dependency.Injector             * @kind function             * @access public             * @static             *              * @description             * Gathers and returns the array of listed dependencies.             *              * @param {Array<any>} dependencies The array of dependencies specified              * by either their Constructor or their registered name.             *              * @returns {Array<plat.dependency.IInjecor<any>>} The dependencies             */            static getDependencies(dependencies: Array<any>): Array<IInjector<any>> {                if (isNull(dependencies) || isEmpty(dependencies)) {                    return [];                }                var deps: Array<IInjector<any>> = [],                    length = dependencies.length;                for (var i = 0; i < length; ++i) {                    deps.push(Injector.getDependency(dependencies[i]));                }                return deps;            }            /**             * @name getDependency             * @memberof plat.dependency.Injector             * @kind function             * @access public             * @static             *              * @description             * Finds and returns the dependency.             *              * @param {any} dependency an object/string used to find the dependency.             *              * @returns {plat.dependency.IInjector<any>} The dependency             */            static getDependency(dependency: any): IInjector<any> {                if (isNull(dependency) || dependency === __noopInjector) {                    return Injector.__noop();                } else if (Injector.isInjector(dependency)) {                    return dependency;                }                return Injector.__locateInjector(dependency);            }            /**             * @name convertDependencies             * @memberof plat.dependency.Injector             * @kind function             * @access public             * @static             *              * @description             * Converts dependencies specified by their Constructors into              * equivalent dependencies specified by their registered string              * name.             *              * @param {Array<any>} dependencies The array of dependencies specified              * by either their Constructor or their registered name.             *              * @returns {Array<string>} The dependency strings.             */            static convertDependencies(dependencies: Array<any>): Array<string> {                if (!isArray(dependencies)) {                    return [];                }                var deps: Array<string> = [],                    length = dependencies.length,                    dependency: any,                    value: string;                for (var i = 0; i < length; ++i) {                    dependency = dependencies[i];                    if (isNull(dependency)) {                        deps.push('noop');                        continue;                    }                    value = Injector.__getInjectorName(dependency);                    deps.push(value);                }                return deps;            }            /**             * @name isInjector             * @memberof plat.dependency.Injector             * @kind function             * @access public             * @static             *              * @description             * Checks if the object being passed in fulfills the requirements for being an Injector.             *              * @param {plat.dependency.Injector<any>} dependency The object to check.             *              * @returns {boolean} Whether or not the object passed in is an injector.             */            static isInjector(dependency: Injector<any>): boolean {                return isFunction(dependency.inject) &&                    !isUndefined(dependency.type) &&                    !isUndefined(dependency.name) &&                    !isUndefined(dependency.Constructor);            }            /**             * @name __getInjectorName             * @memberof plat.dependency.Injector             * @kind function             * @access private             * @static             *              * @description             * Gets the string name related to an injector.             *              * @param {any} dependency The object to search for.             *              * @returns {string} The string injector name             */            private static __getInjectorName(dependency: any): string {                if (isNull(dependency)) {                    return __noopInjector;                } else if (isString(dependency)) {                    return dependency;                } else if (dependency === window) {                    return __Window;                } else if (dependency === window.document) {                    return __Document;                }                var injectors = injectableInjectors,                    injector: IInjector<any>,                    keys = Object.keys(injectors),                    length = keys.length,                    key: string,                    value: any;                for (var i = 0; i < length; ++i) {                    key = keys[i];                    injector = injectors[key];                    value = injector.Constructor;                    if (value === dependency) {                        return key;                    }                }                return __noopInjector;            }            /**             * @name __construct             * @memberof plat.dependency.Injector             * @kind function             * @access private             * @static             *              * @description             * Calls the injector's constructor with the associated dependencies.             *              * @param {any} Constructor The Constructor to call.             * @param {Array<any>} args The arguments to pass to the constructor.             *              * @returns {any} The instantiated constructor.             */            private static __construct(Constructor: any, args: Array<any>): any {                if (isNull(Constructor) || isNull(Constructor.prototype)) {                    return Constructor;                }                var obj = Object.create(Constructor.prototype),                    ret = obj.constructor.apply(obj, args);                if (!isUndefined(ret)) {                    return ret;                }                return obj;            }            /**             * @name __locateInjector             * @memberof plat.dependency.Injector             * @kind function             * @access private             * @static             *              * @description             * Finds an injector object with the associated constructor.             *              * @param {any} Constructor The Constructor to locate.             *              * @returns {any} The located injector.             */            private static __locateInjector(Constructor: any): any {                if (isNull(Constructor)) {                    return;                } else if (isString(Constructor)) {                    return injectableInjectors[Constructor] || Injector.__noop();                } else if (Constructor === window) {                    return (<any>injectableInjectors).$Window;                } else if (Constructor === window.document) {                    return (<any>injectableInjectors).$Document;                }                var injectors = injectableInjectors,                    injector: IInjector<any>,                    keys = Object.keys(injectors),                    length = keys.length;                for (var i = 0; i < length; ++i) {                    injector = injectors[keys[i]];                    if (injector.Constructor === Constructor) {                        return injector;                    }                }                return Injector.__wrap(Constructor);            }            /**             * @name __wrap             * @memberof plat.dependency.Injector             * @kind function             * @access private             * @static             *              * @description             * Once an injector is injected, it is wrapped to prevent further injection.             *              * @param {any} value The injected value.             *              * @returns {plat.dependency.IInjector<any>} The wrapped injector.             */            private static __wrap(value: any): IInjector<any> {                return {                    inject: () => value,                    name: 'wrapped',                    __dependencies: [],                    Constructor: value                };            }            /**             * @name __noop             * @memberof plat.dependency.Injector             * @kind function             * @access private             * @static             *              * @description             * Returns an empty injector object.             *              * @returns {plat.dependency.IInjector<any>} The noop injector.             */            private static __noop(): IInjector<any> {                return {                    inject: noop,                    type: __noopInjector,                    name: __noopInjector,                    __dependencies: [],                    Constructor: <any>noop                };            }            /**             * @name __findCircularReferences             * @memberof plat.dependency.Injector             * @kind function             * @access private             * @static             *              * @description             * Determines if there is a circular dependency in a dependency tree.             *              * @param {plat.dependency.Injector<any>} injector The starting point for the dependency tree search.             *              * @returns {string} The end of the circular dependency chain, if one exists.             */            private static __findCircularReferences(injector: Injector<any>): string {                if (!(isObject(injector) && isArray(injector.__dependencies))) {                    return;                }                var source = injector.name,                    dependencies = injector.__dependencies,                    node: {                        name: string;                        dependencies: Array<string>;                    },                    stack: Array<typeof node> = [{                        name: source,                        dependencies: dependencies.slice(0)                    }],                    dependency: string,                    locate = Injector.__locateInjector,                    length: number;                while (stack.length > 0) {                    node = stack.pop();                    dependencies = node.dependencies;                    length = dependencies.length;                    for (var i = 0; i < length; ++i) {                        dependency = dependencies[i];                        if (dependency === source) {                            return node.name;                        }                        injector = locate(dependency);                        if (!(isObject(injector) && isArray(injector.__dependencies))) {                            continue;                        }                        stack.push({                            name: injector.name,                            dependencies: injector.__dependencies.slice(0)                        });                    }                }            }            /**             * @name __dependencies             * @memberof plat.dependency.Injector             * @kind property             * @access private             *              * @type {Array<string>}             *              * @description             * The dependencies for this injector             */            private __dependencies: Array<string>;            /**             * @name constructor             * @memberof plat.dependency.Injector             * @kind function             * @access public             *              * @description             * The constructor for an injector. Converts any non-string dependencies to strings to support mocking Injectors during runtime.             *              * @param {string} name The name of the injected type.             * @param {new () => T} Constructor The constructor method for the component requiring the dependency              * injection.             * @param {Array<any>} dependencies An array of strings specifying the injectable dependencies for the              * associated constructor.             * @param {string} type The type of injector, used for injectables specifying a injectableType of              * STATIC, SINGLETON, FACTORY, INSTANCE, or CLASS. The default is SINGLETON.             *              * @returns {plat.dependency.Injector}             */            constructor(public name: string, public Constructor: new () => T, dependencies?: Array<any>, public type: string = null) {                var deps = this.__dependencies = Injector.convertDependencies(dependencies),                    index = deps.indexOf(__noopInjector),                    circularReference: string;                if (index > -1) {                    var dependency = dependencies[index];                    if (isNull(dependency)) {                        throw new TypeError('The dependency for ' +                            name + ' at index ' +                            index + ' is undefined, did you forgot to include a file?');                    }                    throw new TypeError('Could not resolve dependency ' +                        dependency.substring(9, dependency.indexOf('(')) +                        ' for ' +                        name +                        '. Are you using a static injectable Type?');                }                circularReference = Injector.__findCircularReferences(this);                if (isString(circularReference)) {                    throw new Error('Circular dependency detected from ' + name + ' to ' + circularReference + '.');                }                if (name === __AppStatic) {                    var App: IAppStatic = <IAppStatic>(<any>this).inject();                    this.__dependencies = deps;                    App.start();                }            }            /**             * @name inject             * @memberof plat.dependency.Injector             * @kind function             * @access public             *              * @description             * Gathers the dependencies for the Injector object and creates a new instance of the              * Constructor, passing in the dependencies in the order they were specified. If the              * Injector contains a Constructor for an injectable and the Constructor is registered              * as a SINGLE type it will only inject that injectable once.             *              * @returns {T} The injected object             */            inject(): T {                var toInject: any = [],                    type = this.type;                var dependencies = this.__dependencies,                    length = dependencies.length,                    dependency: IInjector<any>,                    injectable: any;                for (var i = 0; i < length; ++i) {                    dependency = Injector.getDependency(dependencies[i]);                    toInject.push(dependency.inject());                }                injectable = <T>Injector.__construct(this.Constructor, toInject);                if (type === __SINGLETON || type === __FACTORY ||                    type === __STATIC || type === __CLASS) {                    this._wrapInjector(injectable);                }                return injectable;            }            /**             * @name _wrapInjector             * @memberof plat.dependency.Injector             * @kind function             * @access protected             *              * @description             * Wraps the injector with the instantiated value in the case of a              * SINGLE or STATIC type so that it does not re-instantiate.             *              * @param {any} value The value to wrap             */            _wrapInjector(value: any): IInjector<any> {                var name = this.name;                return injectableInjectors[name] = <IInjector<any>>{                    type: this.type,                    name: name,                    __dependencies: this.__dependencies,                    Constructor: this.Constructor,                    inject: () => <T>value                };            }        }        /**         * @name IInjectorObject         * @memberof plat.dependency         * @kind interface         * @access public         *          * @description         * An object whose values are all {@link plat.dependency.IInjector|IInjectors}.         */        export interface IInjectorObject<T> extends IObject<IInjector<T>> { }        /**         * @name IInjector         * @memberof plat.dependency         * @kind class         *          * @description         * The IInjector interface is used for dependency injection. You can create an injector object,         * specify dependencies and a constructor for your component. When the injector object is         * 'injected' it will create a new instance of your component and pass in the dependencies         * to the constructor.         *          * @typeparam {any} T The type of object that will be returned when the inject method is invoked.         */        export interface IInjector<T> {            /**             * @name inject             * @memberof plat.dependency.IInjector             * @kind function             * @access public             *              * @description             * Gathers the dependencies for the IInjector object and creates a new instance of the              * Constructor, passing in the dependencies in the order they were specified. If the              * Injector contains a Constructor for an injectable and the Constructor is registered              * as a SINGLE type it will only inject that injectable once.             *              * @returns {T} The injected object             */            inject(): T;            /**             * @name Constructor             * @memberof plat.dependency.IInjector             * @kind property             * @access public             *              * @type {new () => T}             *              * @description             * The constructor method for the component requiring the dependency injection.             */            Constructor: new () => T;            /**             * @name type             * @memberof plat.dependency.IInjector             * @kind property             * @access public             *              * @type {string}             *              * @description             * The type of injector, used for injectables specifying a register.injectableType of              * STATIC, SINGLE, or MULTI. The default is SINGLE.             */            type?: string;            /**             * @name name             * @memberof plat.dependency.IInjector             * @kind property             * @access public             *              * @type {string}             *              * @description             * The name registered for the injector.             */            name: string;        }    }    /**     * @name acquire     * @memberof plat     * @kind function     * @variation 0     * @access public     * @static     *      * @description     * Returns the requested injectable dependency.     *      * @typeparam {any} T The type of the requested dependency.     *      * @param {() => T} dependency The dependency Type to return.     *      * @returns T The requested dependency.     */    export function acquire<T>(dependency: () => T): T;    /**     * @name acquire     * @memberof plat     * @kind function     * @variation 1     * @access public     * @static     *      * @description     * Returns the requested injectable dependency.     *      * @param {Function} dependency The dependency Type to return.     *      * @returns {any} The requested dependency.     */    export function acquire(dependency: Function): any;    /**     * @name acquire     * @memberof plat     * @kind function     * @variation 2     * @access public     * @static     *      * @description     * Returns the requested injectable dependency.     *      * @param {Function} dependency An array of Types specifying the injectable dependencies.     *      * @returns {Array<any>} The dependencies, in the order they were requested.     */    export function acquire(dependencies: Array<Function>): Array<any>;    /**     * @name acquire     * @memberof plat     * @kind function     * @variation 3     * @access public     * @static     *      * @description     * Returns the requested injectable dependency.     *      * @param {string} dependency The injectable dependency type to return.     *      * @returns {any} The requested dependency.     */    export function acquire(dependency: string): any;    /**     * @name acquire     * @memberof plat     * @kind function     * @variation 4     * @access public     * @static     *      * @description     * Gathers dependencies and returns them as an array in the order they were requested.     *      * @param {Array<string>} dependencies An array of strings specifying the injectable dependencies.     *      * @returns {Array<any>} The dependencies, in the order they were requested.     */    export function acquire(dependencies: Array<string>): Array<any>;    /**     * @name acquire     * @memberof plat     * @kind function     * @variation 5     * @access public     * @static     *      * @description     * Gathers dependencies and returns them as an array in the order they were requested.     *      * @param {Array<any>} dependencies An array of strings or Functions specifying the injectable dependencies.     *      * @returns {Array<any>} The dependencies, in the order they were requested.     */    export function acquire(dependencies: Array<any>): Array<any>;    export function acquire(dependencies: any) {        var deps: Array<dependency.IInjector<any>>,            array = isArray(dependencies);        if (array) {            deps = dependency.Injector.getDependencies(dependencies);        } else {            deps = dependency.Injector.getDependencies([dependencies]);        }        var length = deps.length,            output: Array<any> = [];        for (var i = 0; i < length; ++i) {            output.push(deps[i].inject());        }        if (!array) {            return output[0];        }        return output;    }    /**     * Manages the throwing and consuming of errors and warnings.     */    export class Exception {        /**         * Method for sending a warning to all listeners. Will          * not throw an error.         *          * @param message The message to be sent to the listeners.         * @param type Denotes the type of fatal exception.         */        static warn(message: string, type?: number): void {            raise(message, type, false);        }        /**         * Method for sending a fatal error to all listeners. Will         * throw an error.         *          * @param error The Error to be sent to all the listeners.         * @param type Denotes the type of fatal exception.          */        static fatal(error: Error, type?: number): void;        /**         * Method for sending a fatal message to all listeners. Will         * throw an error.         *          * @param message The message to be sent to all the listeners.         * @param type Denotes the type of fatal exception.         */        static fatal(message: string, type?: number): void;        static fatal(message: any, type?: number) {            raise(message, type, true);        }        /**         * Exception Type         */        static PARSE = 0;        /**         * Exception Type         */        static COMPILE = 1;        /**         * Exception Type         */        static BIND = 2;        /**         * Exception Type         */        static NAME = 3;        /**         * Exception Type         */        static NAVIGATION = 4;        /**         * Exception Type         */        static TEMPLATE = 5;        /**         * Exception Type         */        static AJAX = 6;        /**         * Exception Type         */        static CONTEXT = 7;        /**         * Exception Type         */        static EVENT = 8;        /**         * Exception Type         */        static INJECTABLE = 9;        /**         * Exception Type         */        static COMPAT = 10;        /**         * Exception Type         */        static PROMISE = 11;        /**         * Animation Type         */        static ANIMATION = 12;    }    /**     * The Type for referencing the '$ExceptionStatic' injectable as a dependency.     */    export function IExceptionStatic(): IExceptionStatic {        return Exception;    }    register.injectable(__ExceptionStatic, IExceptionStatic, null, __STATIC);    /**     * The intended external interface for the '$ExceptionStatic' injectable.     */    export interface IExceptionStatic {        /**         * Method for sending a warning to all listeners. Will         * not throw an error.         *          * @param message The message to be sent to the listeners.         * @param type Denotes the type of fatal exception.         */        warn(message: string, type?: number): void;        /**         * Method for sending a fatal error to all listeners. Will         * throw an error.         *          * @param error The Error to be sent to all the listeners.         * @param type Denotes the type of fatal exception.         */        fatal(error: Error, type?: number): void;        /**         * Method for sending a fatal message to all listeners. Will         * throw an error.         *          * @param message The message to be sent to all the listeners.         * @param type Denotes the type of fatal exception.         */        fatal(message: string, type?: number): void;        /**         * Exception Type         */        PARSE: number;        /**         * Exception Type         */        COMPILE: number;        /**         * Exception Type         */        BIND: number;        /**         * Exception Type         */        NAME: number;        /**         * Exception Type         */        NAVIGATION: number;        /**         * Exception Type         */        TEMPLATE: number;        /**         * Exception Type         */        AJAX: number;        /**         * Exception Type         */        CONTEXT: number;        /**         * Exception Type         */        EVENT: number;        /**         * Exception Type         */        INJECTABLE: number;        /**         * Exception Type         */        COMPAT: number;        /**         * Exception Type         */        PROMISE: number;        /**         * Animation Type         */        ANIMATION: number;    }    class PlatException {        constructor(public message: string, public name: string) { }    }    class PlatError {        message: string;        name = 'PlatError';        constructor(message?: string) {            this.message = message || '';        }    }    function setPrototypes(platError?: any): void {        PlatError.prototype = platError || Error.prototype;        PlatException.prototype = new PlatError();    }    function raise(message: any, type: number, isFatal?: boolean): void {        var error: Error;        if (message instanceof Error) {            setPrototypes(Object.getPrototypeOf(message));        } else if (PlatError.prototype !== Error.prototype) {            setPrototypes();        }        error = new PlatException(message, '');        switch (type) {            case Exception.PARSE:                error.name = 'ParsingError';                break;            case Exception.BIND:                error.name = 'BindingError';                break;            case Exception.COMPILE:                error.name = 'CompilingError';                break;            case Exception.NAME:                error.name = 'PlatNameError';                break;            case Exception.NAVIGATION:                error.name = 'NavigatingError';                break;            case Exception.TEMPLATE:                error.name = 'TemplatingError';                break;            case Exception.CONTEXT:                error.name = 'ContextError';                break;            case Exception.EVENT:                error.name = 'DispatchEventError';                break;            case Exception.INJECTABLE:                error.name = 'InjectableError';                break;            case Exception.COMPAT:                error.name = 'CompatibilityError';                break;            default:                error = new PlatError(message);                break;        }        if (message instanceof Error) {            var properties = Object.getOwnPropertyNames(message),                length = properties.length;            error.message = '';            error = Object.create(error);            for (var i = 0; i < length; ++i) {                (<any>error)[properties[i]] = message[properties[i]];            }        }        var ErrorEvent: events.IErrorEventStatic = acquire(__ErrorEventStatic);        ErrorEvent.dispatch('error', Exception, error);        if (isFatal) {            throw error;        }    }    /**     * @name Compat     * @memberof plat     * @kind class     *      * @implements {plat.ICompat}     *      * @description     * A class containing boolean values signifying browser      * and/or platform compatibilities.     */    export class Compat implements ICompat {        /**         * @name $Window         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {Window}         *          * @description         * The window injectable.         */        $Window: Window = acquire(__Window);        /**         * @name $Document         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {Document}         *          * @description         * The document injectable.         */        $Document: Document = acquire(__Document);        /**         * @name isCompatible         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Determines if the browser is modern enough to correctly          * run PlatypusTS.         */        isCompatible: boolean;        /**         * @name cordova         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether or not Cordova is defined. If it is,          * we hook up ALM events to Cordova's functions.         */        cordova: boolean;        /**         * @name pushState         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether window.history.pushState is defined.         */        pushState: boolean;        /**         * @name fileSupported         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether the File API is supported.         */        fileSupported: boolean;        /**         * @name amd         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether Require is present. If it is, we assume          * it is going to be used and leave the loading of the app up          * to the developer.         */        amd: boolean;        /**         * @name msApp         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether we are in the contet of a Windows 8 app.         */        msApp: boolean;        /**         * @name indexedDb         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether indexedDB exists on the window.         */        indexedDb: boolean;        /**         * @name proto         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether Object.prototype.__proto__ exists.         */        proto: boolean;        /**         * @name getProto         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether Object.prototype.getPrototypeOf exists.         */        getProto: boolean;        /**         * @name setProto         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether Object.prototype.setPrototypeOf exists.         */        setProto: boolean;        /**         * @name hasTouchEvents         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Whether or not the current browser has touch events          * like touchstart, touchmove, touchend, etc.         */        hasTouchEvents: boolean;        /**         * @name hasPointerEvents         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Whether or not the current browser has pointer events          * like pointerdown, MSPointerMove, pointerup, etc.         */        hasPointerEvents: boolean;        /**         * @name hasMsPointerEvents         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Whether or not the current browser has touch events          * like MSPointerDown, touchmove, MSPointerUp, etc.         */        hasMsPointerEvents: boolean;        /**         * @name animationSupported         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Whether or not the browser supports animations.         */        animationSupported: boolean;        /**         * @name platCss         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Whether the platypus.css file was included or not.         */        platCss: boolean;        /**         * @name mappedEvents         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {plat.IMappedEvents}         *          * @description         * An object containing the correctly mapped touch events for the browser.         */        mappedEvents: IMappedEvents;        /**         * @name animationEvents         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {plat.IAnimationEvents}         *          * @description         * An object containing the properly prefixed animation events.         */        animationEvents: IAnimationEvents;        /**         * @name vendorPrefix         * @memberof plat.Compat         * @kind property         * @access public         *          * @type {plat.IVendorPrefix}         *          * @description         * An object containing information regarding any potential vendor prefix.         */        vendorPrefix: IVendorPrefix;        /**         * @name constructor         * @memberof plat.Compat         * @kind function         * @access public         *          * @description         * Define everything         *          * @returns {void}         */        constructor() {            this.__defineBooleans();            this.__defineMappedEvents();            this.__defineAnimationEvents();            this.__determineCss();        }        /**         * @name __defineBooleans         * @memberof plat.Compat         * @kind function         * @access private         *          * @description         * Define booleans         *          * @returns {void}         */        private __defineBooleans(): void {            var $window = this.$Window,                navigator = $window.navigator,                history = $window.history,                def = (<any>$window).define,                msA = (<any>$window).MSApp;            this.isCompatible = isFunction(Object.defineProperty) && isFunction(this.$Document.querySelector);            this.cordova = !isNull((<any>$window).cordova);            this.pushState = !(isNull(history) || isNull(history.pushState));            this.fileSupported = !(isUndefined((<any>$window).File) || isUndefined((<any>$window).FormData));            this.amd = isFunction(def) && !isNull(def.amd);            this.msApp = isObject(msA) && isFunction(msA.execUnsafeLocalFunction);            this.indexedDb = !isNull($window.indexedDB);            this.proto = isObject((<any>{}).__proto__);            this.getProto = isFunction(Object.getPrototypeOf);            this.setProto = isFunction((<any>Object).setPrototypeOf);            this.hasTouchEvents = !isUndefined((<any>$window).ontouchstart);            this.hasPointerEvents = !!navigator.pointerEnabled;            this.hasMsPointerEvents = !!navigator.msPointerEnabled;        }        /**         * @name __defineMappedEvents         * @memberof plat.Compat         * @kind function         * @access private         *          * @description         * Define {@link plat.IMappedEvents|mapped events}         *          * @returns {void}         */        private __defineMappedEvents(): void {            if (this.hasPointerEvents) {                this.mappedEvents = {                    $touchstart: 'pointerdown',                    $touchend: 'pointerup',                    $touchmove: 'pointermove',                    $touchcancel: 'pointercancel'                };            } else if (this.hasMsPointerEvents) {                this.mappedEvents = {                    $touchstart: 'MSPointerDown',                    $touchend: 'MSPointerUp',                    $touchmove: 'MSPointerMove',                    $touchcancel: 'MSPointerCancel'                };            } else if (this.hasTouchEvents) {                this.mappedEvents = {                    $touchstart: 'touchstart',                    $touchend: 'touchend',                    $touchmove: 'touchmove',                    $touchcancel: 'touchcancel'                };            } else {                this.mappedEvents = {                    $touchstart: 'mousedown',                    $touchend: 'mouseup',                    $touchmove: 'mousemove',                    $touchcancel: null                };            }        }        /**         * @name __defineAnimationEvents         * @memberof plat.Compat         * @kind function         * @access private         *          * @description         * Define {@link plat.IAnimationEvents|animation events}         *          * @returns {void}         */        private __defineAnimationEvents(): void {            var documentElement = this.$Document.documentElement,                styles = this.$Window.getComputedStyle(documentElement, ''),                prefix: string;            if (!isUndefined((<any>styles).OLink)) {                prefix = 'o';            } else {                var matches = Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/);                prefix = (isArray(matches) && matches.length > 1) ? matches[1] : '';            }            this.vendorPrefix = {                lowerCase: prefix,                css: prefix === '' ? '' : '-' + prefix + '-',                js: prefix[0].toUpperCase() + prefix.substr(1)            };            if (prefix === 'webkit') {                this.animationSupported = !isUndefined((<any>documentElement.style).WebkitAnimation);                if (!this.animationSupported) {                    this.animationEvents = {                        $animation: '',                        $animationStart: '',                        $animationEnd: '',                        $transition: '',                        $transitionStart: '',                        $transitionEnd: ''                    };                    return;                }                this.animationEvents = {                    $animation: 'webkitAnimation',                    $animationStart: 'webkitAnimationStart',                    $animationEnd: 'webkitAnimationEnd',                    $transition: 'webkitTransition',                    $transitionStart: 'webkitTransitionStart',                    $transitionEnd: 'webkitTransitionEnd'                };            } else {                this.animationSupported = !isUndefined((<any>documentElement.style).animation);                if (!this.animationSupported) {                    this.animationEvents = {                        $animation: '',                        $animationStart: '',                        $animationEnd: '',                        $transition: '',                        $transitionStart: '',                        $transitionEnd: ''                    };                    return;                }                this.animationEvents = {                    $animation: 'animation',                    $animationStart: 'animationstart',                    $animationEnd: 'animationend',                    $transition: 'transition',                    $transitionStart: 'transitionstart',                    $transitionEnd: 'transitionend'                };            }        }        /**         * @name __determineCss         * @memberof plat.Compat         * @kind function         * @access private         *          * @description         * Determines whether or not platypus css styles exist.         *          * @returns {void}         */        private __determineCss(): void {            var $document = this.$Document,                head = $document.head,                element = $document.createElement('div');            element.setAttribute(__Hide, '');            head.insertBefore(element, null);            var computedStyle = this.$Window.getComputedStyle(element),                display = computedStyle.display,                visibility = computedStyle.visibility;            if (display === 'none' || visibility === 'hidden') {                this.platCss = true;            } else {                this.platCss = false;            }            head.removeChild(element);        }    }   /**    * The Type for referencing the '$Compat' injectable as a dependency.    */    export function ICompat(): ICompat {        return new Compat();    }    register.injectable(__Compat, ICompat);    /**     * @name ICompat     * @memberof plat     * @kind interface     *      * @description     * An object containing boolean values signifying browser      * and/or platform compatibilities.     */    export interface ICompat {        /**         * @name isCompatible         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Determines if the browser is modern enough to correctly          * run PlatypusTS.         */        isCompatible: boolean;        /**         * @name cordova         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether or not Cordova is defined. If it is,          * we hook up ALM events to Cordova's functions.         */        cordova: boolean;        /**         * @name pushState         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether window.history.pushState is defined.         */        pushState: boolean;        /**         * @name fileSupported         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether the File API is supported.         */        fileSupported: boolean;        /**         * @name amd         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether Require is present. If it is, we assume          * it is going to be used and leave the loading of the app up          * to the developer.         */        amd: boolean;        /**         * @name msApp         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether we are in the contet of a Windows 8 app.         */        msApp: boolean;        /**         * @name indexedDb         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether indexedDB exists on the window.         */        indexedDb: boolean;        /**         * @name proto         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether Object.prototype.__proto__ exists.         */        proto: boolean;        /**         * @name getProto         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether Object.prototype.getPrototypeOf exists.         */        getProto: boolean;        /**         * @name setProto         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Signifies whether Object.prototype.setPrototypeOf exists.         */        setProto: boolean;        /**         * @name hasTouchEvents         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Whether or not the current browser has touch events          * like touchstart, touchmove, touchend, etc.         */        hasTouchEvents: boolean;        /**         * @name hasPointerEvents         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Whether or not the current browser has pointer events          * like pointerdown, MSPointerMove, pointerup, etc.         */        hasPointerEvents: boolean;        /**         * @name hasMsPointerEvents         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Whether or not the current browser has touch events          * like MSPointerDown, touchmove, MSPointerUp, etc.         */        hasMsPointerEvents: boolean;        /**         * @name animationSupported         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Whether or not the browser supports animations.         */        animationSupported: boolean;        /**         * @name platCss         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {boolean}         *          * @description         * Whether the platypus.css file was included or not.         */        platCss: boolean;        /**         * @name mappedEvents         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {plat.IMappedEvents}         *          * @description         * An object containing the correctly mapped touch events for the browser.         */        mappedEvents: IMappedEvents;        /**         * @name animationEvents         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {plat.IAnimationEvents}         *          * @description         * An object containing the properly prefixed animation events.         */        animationEvents: IAnimationEvents;        /**         * @name vendorPrefix         * @memberof plat.ICompat         * @kind property         * @access public         *          * @type {plat.IVendorPrefix}         *          * @description         * An object containing information regarding any potential vendor prefix.         */        vendorPrefix: IVendorPrefix;    }    /**     * @name IMappedEvents     * @memberof plat     * @kind interface     *      * @extends {plat.IObject}     *      * @description     * Describes an object containing the correctly mapped touch events for the browser.     */    export interface IMappedEvents extends IObject<string> {        /**         * @name $touchstart         * @memberof plat.IMappedEvents         * @kind property         * @access public         *          * @type {string}         *          * @description         * An event type for touch start.         */        $touchstart: string;        /**         * @name $touchend         * @memberof plat.IMappedEvents         * @kind property         * @access public         *          * @type {string}         *          * @description         * An event type for touch end.         */        $touchend: string;        /**         * @name $touchmove         * @memberof plat.IMappedEvents         * @kind property         * @access public         *          * @type {string}         *          * @description         * An event type for touch move.         */        $touchmove: string;        /**         * @name $touchcancel         * @memberof plat.IMappedEvents         * @kind property         * @access public         *          * @type {string}         *          * @description         * An event type for touch cancel.         */        $touchcancel: string;    }    /**     * @name IAnimationEvents     * @memberof plat     * @kind interface     *      * @extends {plat.IObject}     *      * @description     * Describes an object containing the properly prefixed animation events.     */    export interface IAnimationEvents extends IObject<string> {        /**         * @name $animation         * @memberof plat.IAnimationEvents         * @kind property         * @access public         *          * @type {string}         *          * @description         * The animation identifier.         */        $animation: string;        /**         * @name $animationStart         * @memberof plat.IAnimationEvents         * @kind property         * @access public         *          * @type {string}         *          * @description         * The animation start event.         */        $animationStart: string;        /**         * @name $animationEnd         * @memberof plat.IAnimationEvents         * @kind property         * @access public         *          * @type {string}         *          * @description         * The animation end event.         */        $animationEnd: string;        /**         * @name $transition         * @memberof plat.IAnimationEvents         * @kind property         * @access public         *          * @type {string}         *          * @description         * The transition identifier.         */        $transition: string;        /**         * @name $transitionStart         * @memberof plat.IAnimationEvents         * @kind property         * @access public         *          * @type {string}         *          * @description         * The transition start event.         */        $transitionStart: string;        /**         * @name $transitionEnd         * @memberof plat.IAnimationEvents         * @kind property         * @access public         *          * @type {string}         *          * @description         * The transition end event.         */        $transitionEnd: string;    }    /**     * @name IVendorPrefix     * @memberof plat     * @kind interface     *      * @extends {plat.IObject}     *      * @description     * Describes an object that contains information regarding the browser's      * vendor prefix.     */    export interface IVendorPrefix extends IObject<string> {        /**         * @name lowerCase         * @memberof plat.IVendorPrefix         * @kind property         * @access public         *          * @type {string}         *          * @description         * The lowercase representation of the browser's vendor prefix.         */        lowerCase: string;        /**         * @name css         * @memberof plat.IVendorPrefix         * @kind property         * @access public         *          * @type {string}         *          * @description         * The css representation of the browser's vendor prefix          * denoted by -{prefix}-.         */        css: string;        /**         * @name js         * @memberof plat.IVendorPrefix         * @kind property         * @access public         *          * @type {string}         *          * @description         * The JavaScript representation of the browser's vendor prefix          * denoted by it beginning with a capital letter.         */        js: string;    }    /**     * @name Utils     * @memberof plat     * @kind class     *      * @implements {plat.IUtils}     *      * @description     * An extensible class defining common utilities and helper functions.     */    export class Utils implements IUtils {        /**         * @name noop         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * An empty method for quickly creating dummy objects.         *          * @returns {void}         */        noop(): void { }        /**         * @name extend         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Allows you to extend the properties of an object with any number          * of other objects. If objects share properties, the last object in the         * arguments will take precedence. This method is only a shallow copy of         * all the source objects to the destination object.         *          * @param {any} destination The destination object to extend.         * @param {Array<any>} ...sources Any number of objects with which to extend the          * destination object.         *          * @returns {any} The extended destination object.         */        extend(destination: any, ...sources: any[]): any {            return extend.apply(null, [destination].concat(sources));        }        /**         * @name deepExtend         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Allows you to extend the properties of an object with any number          * of other objects. If objects share properties, the last object in the         * arguments will take precedence. This method is a deep copy of         * all the source objects to the destination object.         *          * @param {any} destination The destination object to extend.         * @param {Array<any>} ...sources Any number of objects with which to extend the          * destination object.         *          * @returns {any} The extended destination object.         */        deepExtend(destination: any, ...sources: any[]): any {            return extend.apply(null, [true, destination].concat(sources));        }        /**         * @name clone         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Creates a copy of the passed-in object. If deep is true it will          * be a deep copy (duplicate), else nested objects/arrays will be copied by reference         * and not duplicated.         *          * @typeparam {any} T The type of object being cloned.         *          * @param {T} obj The object to clone.         * @param {boolean} deep? Whether or not it is a deep clone.         *          * @returns {T} The cloned object.         */        clone<T>(obj: T, deep?: boolean): T {            return _clone(obj, deep);        }        /**         * @name isObject         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a type of Object.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is an object, false otherwise.         */        isObject(obj: any): boolean {            return isObject(obj);        }        /**         * @name isWindow         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a window object.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is the window, false otherwise.         */        isWindow(obj: any): boolean {            return isWindow(obj);        }        /**         * @name isDocument         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a document object.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is the document, false otherwise.         */        isDocument(obj: any): boolean {            return isDocument(obj);        }        /**         * @name isNode         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a Node.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a Node, false otherwise.         */        isNode(obj: any): boolean {            return isNode(obj);        }        /**         * @name isDocumentFragment         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a DocumentFragment.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a DocumentFragment, false otherwise.         */        isDocumentFragment(obj: any): boolean {            return isDocumentFragment(obj);        }        /**         * @name isString         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a string.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a string, false otherwise.         */        isString(obj: any): boolean {            return isString(obj);        }        /**         * @name isRegExp         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a RegExp object.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a RegExp object, false otherwise.         */        isRegExp(obj: any): boolean {            return isRegExp(obj);        }        /**         * @name isPromise         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a Promise object.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a Promise object, false otherwise.         */        isPromise(obj: any): boolean {            return isPromise(obj);        }        /**         * @name isEmpty         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is empty. Useful for         * checking for empty strings, arrays, or objects without keys.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if the object isEmpty (or null/undefined),          * false otherwise.         */        isEmpty(obj: any): boolean {            return isEmpty(obj);        }        /**         * @name isBoolean         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a boolean.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a boolean, false otherwise.         */        isBoolean(obj: any): boolean {            return isBoolean(obj);        }        /**         * @name isNumber         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a number.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a number, false otherwise.         */        isNumber(obj: any): boolean {            return isNumber(obj);        }        /**         * @name isFunction         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a function.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a function, false otherwise.         */        isFunction(obj: any): boolean {            return isFunction(obj);        }        /**         * @name isNull         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is null or undefined.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is null or undefined, false otherwise.         */        isNull(obj: any): boolean {            return isNull(obj);        }        /**         * @name isUndefined         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is undefined.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is undefined, false otherwise.         */        isUndefined(obj: any): boolean {            return isUndefined(obj);        }        /**         * @name isArray         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is an Array.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is an Array, false otherwise.         */        isArray(obj: any): boolean {            return isArray(obj);        }        /**         * @name isArrayLike         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it has array-like qualities.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj has array-like qualities (i.e. it is an         * Array, string, arguments, or NodeList), false otherwise.         */        isArrayLike(obj: any): boolean {            return isArrayLike(obj);        }        /**         * @name isDate         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a Date object.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a Date object, false otherwise.         */        isDate(obj: any): boolean {            return isDate(obj);        }        /**         * @name filter         * @memberof plat.Utils         * @kind function         * @access public         * @variation 0         *          * @description         * Takes in an array and a function to evaluate the properties in the array.         * Returns a filtered array of objects resulting from evaluating the function.         *          * @typeparam {any} T The type of objects contained in the Array being filtered.         *          * @param {Array<T>} array The Array to filter.         * @param {(value: T, index: number, obj: any) => boolean} iterator The iterator function to call with array's properties.          * Returns true if the property should be kept, false otherwise.         * @param {any} context? Optional context with which to call the iterator.         *          * @returns {Array<T>} An array of objects which evaluated to true with the iterator.         */        filter<T>(array: Array<T>, iterator: (value: T, index: number, obj: any) => boolean, context?: any): Array<T>;        /**         * @name filter         * @memberof plat.Utils         * @kind function         * @access public         * @variation 1         *          * @description         * Takes in an object/array and a function to evaluate the properties in the object/array.         * Returns a filtered array of objects resulting from evaluating the function.         *          * @typeparam {any} T The type of objects contained in the Object/Array being filtered.         *          * @param {any} obj The object to filter.         * @param {(value: T, index: number, obj: any) => boolean} iterator The iterator function to call with array's properties.          * Returns true if the property should be kept, false otherwise.         * @param {any} context? Optional context with which to call the iterator.         *          * @returns {Array<T>} An array of objects which evaluated to true with the iterator.         */        filter<T>(obj: any, iterator: (value: T, key: any, obj: any) => boolean, context?: any): Array<T>;        filter<T>(obj: any, iterator: (value: T, key: any, obj: any) => boolean, context?: any): Array<T> {            return filter(obj, iterator, context);        }        /**         * @name where         * @memberof plat.Utils         * @kind function         * @access public         * @variation 0         *          * @description         * Takes in a list and object containing key/value pairs to search for in the list.         *          * @typeparam {any} T The type of objects contained in the input Array.         *          * @param {Array<T>} array The list used for searching for properties.         * @param {any} properties An object containing key/value pairs to match with obj's values.         *          * @returns {Array<T>} The matched values in obj.         */        where<T>(array: Array<T>, properties: any): Array<T>;        /**         * @name where         * @memberof plat.Utils         * @kind function         * @access public         * @variation 1         *          * @description         * Takes in a list and object containing key/value pairs to search for in the list.         *          * @typeparam {any} T The type of objects contained in the input Object.         *          * @param {any} obj The object used for searching for properties.         * @param {any} properties An object containing key/value pairs to match with obj's values.         *          * @returns {Array<T>} The matched values in obj.         */        where<T>(obj: any, properties: any): Array<T>;        where(obj: any, properties: any): Array<any> {            return where(obj, properties);        }        /**         * @name forEach         * @memberof plat.Utils         * @kind function         * @access public         * @variation 0         *          * @description         * Takes in an Array and a function to iterate over. Calls the iterator function with every property         * in the Array, then returns the object.         *          * @typeparam {any} T The type of objects contained in the input Array.         *          * @param {Array<T>} array An Array.         * @param {(value: T, index: number, obj: any) => void} iterator A method that takes in a value, index, and the object.         * @param {any} context? An optional context to bind to the iterator.         *          * @returns {Array<T>} The array.         */        forEach<T>(array: Array<T>, iterator: (value: T, index: number, obj: any) => void, context?: any): Array<T>;        /**         * @name forEach         * @memberof plat.Utils         * @kind function         * @access public         * @variation 1         *          * @description         * Takes in an Array and a function to iterate over. Calls the iterator function with every property         * in the Array, then returns the object.         *          * @typeparam {any} T The type of objects contained in the input Object.         *          * @param {any} obj An object.         * @param {(value: T, index: number, obj: any) => void} iterator A method that takes in a value, index, and the object.         * @param {any} context? An optional context to bind to the iterator.         *          * @returns {any} The input Object.         */        forEach<T>(obj: any, iterator: (value: T, key: string, obj: any) => void, context?: any): any;        forEach<T>(obj: any, iterator: (value: T, key: any, obj: any) => void, context?: any): any {            return forEach(obj, iterator, context);        }        /**         * @name map         * @memberof plat.Utils         * @kind function         * @access public         * @variation 0         *          * @description         * Takes in an object and an iterator function. Calls the iterator with all the values in the object. The          * iterator can transform the object and return it. The returned values will be pushed to an Array and          * returned.         *          * @typeparam {any} T The type of objects contained in the input Array.         * @typeparam {any} U The type of objects contained in the transformed output Array.         *          * @param {Array<T>} array An Array.         * @param {(value: T, index: number, obj: any) => U} iterator The transformation function.         * @param {any} context? An optional context to bind to the iterator.         *          * @returns {Array<U>} The accumulated transformed values from the iterator.         */        map<T, U>(array: Array<T>, iterator: (value: T, index: number, obj: any) => U, context?: any): Array<U>;        /**         * @name map         * @memberof plat.Utils         * @kind function         * @access public         * @variation 1         *          * @description         * Takes in an object and an iterator function. Calls the iterator with all the values in the object. The          * iterator can transform the object and return it. The returned values will be pushed to an Array and          * returned.         *          * @typeparam {any} T The type of objects contained in the input Object/Array.         * @typeparam {any} U The type of objects contained in the transformed output Array.         *          * @param {Array<T>} obj An Object.         * @param {(value: T, index: number, obj: any) => U} iterator The transformation function.         * @param {any} context? An optional context to bind to the iterator.         *          * @returns {Array<U>} The accumulated transformed values from the iterator.         */        map<T, U>(obj: any, iterator: (value: T, key: string, obj: any) => U, context?: any): Array<U>;        map<T, U>(obj: any, iterator: (value: T, key: any, obj: any) => U, context?: any): Array<U> {            return map<T, U>(obj, iterator, context);        }        /**         * @name pluck         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in an object and a property to extract from all of the object's values. Returns an array of         * the 'plucked' values.         *          * @typeparam {any} T The type of objects contained in the input Object/Array.         * @typeparam {any} U The type of objects contained in the transformed output Array.         *          * @param {any} obj An object.         * @param {string} key The property to 'pluck' from each value in obj.         *          * @returns {Array<U>} An array of 'plucked' values from obj.         */        pluck<T, U>(obj: any, key: string): Array<U> {            return map<T, U>(obj, (value) => (<any>value)[key]);        }        /**         * @name some         * @memberof plat.Utils         * @kind function         * @access public         * @variation 0         *          * @description         * Takes in an array and an iterator. Evaluates all the values in the array with the iterator.         * Returns true if any of the iterators return true, otherwise returns false.         *          * @typeparam {any} T The type of objects contained in the input Array.         *          * @param {Array<T>} array An array.         * @param {(value: T, index: number, obj: any) => boolean} iterator A method with which to evaluate all the values in obj.         * @param {any} context? An optional context to bind to the iterator.         *          * @returns {boolean} True if any calls to iterator return true, false otherwise.         */        some<T>(array: Array<T>, iterator: (value: T, index: number, obj: any) => boolean, context?: any): boolean;        /**         * @name some         * @memberof plat.Utils         * @kind function         * @access public         * @variation 1         *          * @description         * Takes in an array and an iterator. Evaluates all the values in the array with the iterator.         * Returns true if any of the iterators return true, otherwise returns false.         *          * @typeparam {any} T The type of objects contained in the input Object/Array.         *          * @param {Array<T>} obj An object.         * @param {(value: T, index: number, obj: any) => boolean} iterator A method with which to evaluate all the values in obj.         * @param {any} context? An optional context to bind to the iterator.         *          * @returns {boolean} True if any calls to iterator return true, false otherwise.         */        some<T>(obj: any, iterator: (value: T, key: string, obj: any) => boolean, context?: any): boolean;        some<T>(obj: any, iterator: (value: T, key: any, obj: any) => boolean, context?: any): boolean {            return some<T>(obj, iterator, context);        }        /**         * @name postpone         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in a method and array of arguments to pass to that method. Delays calling the method until          * after the current call stack is clear. Equivalent to a setTimeout with a timeout of 0.         *          * @param {(...args: Array<any>) => void} method The method to call.         * @param {Array<any>} args? The arguments to apply to the method.         * @param {any} context? An optional context to bind to the method.         *          * @returns {plat.IRemoveListener} A function that will clear the timeout when called.         */        postpone(method: (...args: any[]) => void, args?: Array<any>, context?: any) {            return defer(method, 0, args, context);        }        /**         * @name defer         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in a method and array of arguments to pass to that method. Delays calling the method until          * after the current call stack is clear. Equivalent to a setTimeout with the specified timeout value.         *          * @param {(...args: Array<any>) => void} method The method to call.         * @param {number} timeout The time (in milliseconds) to delay before calling the provided method         * @param {Array<any>} args? The arguments to apply to the method.         * @param {any} context? An optional context to bind to the method.         *          * @returns {plat.IRemoveListener} A function that will clear the timeout when called.         */        defer(method: (...args: any[]) => void, timeout: number, args?: Array<any>, context?: any) {            return defer(method, timeout, args, context);        }        /**         * @name uniqueId         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in a prefix and returns a unique identifier string with the prefix preprended. If no prefix         * is specified, none will be prepended.         *          * @param {string} prefix? A string prefix to prepend tothe unique ID.         *          * @returns {string} The prefix-prepended unique ID.         */        uniqueId(prefix?: string) {            return uniqueId(prefix);        }        /**         * @name camelCase         * @memberof plat.Utils         * @kind function         * @access public         *          * @description         * Takes in a spinal-case, dot.case, or snake_case string and returns          * a camelCase string. Also can turn a string into camelCase with space          * as a delimeter.         *          * @param {string} str The spinal-case, dot.case, or snake_case string.         *          * @returns {string} The camelCase string.         */        camelCase(str: string) {            return camelCase(str);        }    }    /**     * The Type for referencing the '$Utils' injectable as a dependency.     */    export function IUtils(): IUtils {        return new Utils();    }    register.injectable(__Utils, IUtils);    /**     * @name IUtils     * @memberof plat     * @kind interface     *      * @description     * An object defining common utilities and helper functions.     */    export interface IUtils {        /**         * @name noop         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * An empty method for quickly creating dummy objects.         *          * @returns {void}         */        noop(): void;        /**         * @name extend         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Allows you to extend the properties of an object with any number          * of other objects. If objects share properties, the last object in the         * arguments will take precedence. This method is only a shallow copy of         * all the source objects to the destination object.         *          * @param {any} destination The destination object to extend.         * @param {Array<any>} ...sources Any number of objects with which to extend the          * destination object.         *          * @returns {any} The extended destination object.         */        extend(destination: any, ...sources: any[]): any;        /**         * @name deepExtend         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Allows you to extend the properties of an object with any number          * of other objects. If objects share properties, the last object in the         * arguments will take precedence. This method is a deep copy of         * all the source objects to the destination object.         *          * @param {any} destination The destination object to extend.         * @param {Array<any>} ...sources Any number of objects with which to extend the          * destination object.         *          * @returns {any} The extended destination object.         */        deepExtend(destination: any, ...sources: any[]): any;        /**         * @name clone         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Creates a copy of the passed-in object. If deep is true it will          * be a deep copy (duplicate), else nested objects/arrays will be copied by reference         * and not duplicated.         *          * @typeparam {any} T The type of object being cloned.         *          * @param {T} obj The object to clone.         * @param {boolean} deep? Whether or not it is a deep clone.         *          * @returns {T} The cloned object.         */        clone<T>(obj: T, deep?: boolean): T;        /**         * @name isObject         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a type of Object.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is an object, false otherwise.         */        isObject(obj: any): boolean;        /**         * @name isWindow         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a window object.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is the window, false otherwise.         */        isWindow(obj: any): boolean;        /**         * @name isDocument         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a document object.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is the document, false otherwise.         */        isDocument(obj: any): boolean;        /**         * @name isNode         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a Node.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a Node, false otherwise.         */        isNode(obj: any): boolean;        /**         * @name isDocumentFragment         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a DocumentFragment.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a DocumentFragment, false otherwise.         */        isDocumentFragment(obj: any): boolean;        /**         * @name isString         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a string.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a string, false otherwise.         */        isString(obj: any): boolean;        /**         * @name isRegExp         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a RegExp object.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a RegExp object, false otherwise.         */        isRegExp(obj: any): boolean;        /**         * @name isPromise         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a Promise object.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a Promise object, false otherwise.         */        isPromise(obj: any): boolean;        /**         * @name isEmpty         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is empty. Useful for         * checking for empty strings, arrays, or objects without keys.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if the object isEmpty (or null/undefined),          * false otherwise.         */        isEmpty(obj: any): boolean;        /**         * @name isBoolean         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a boolean.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a boolean, false otherwise.         */        isBoolean(obj: any): boolean;        /**         * @name isNumber         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a number.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a number, false otherwise.         */        isNumber(obj: any): boolean;        /**         * @name isFunction         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a function.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a function, false otherwise.         */        isFunction(obj: any): boolean;        /**         * @name isNull         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is null or undefined.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is null or undefined, false otherwise.         */        isNull(obj: any): boolean;        /**         * @name isUndefined         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is undefined.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is undefined, false otherwise.         */        isUndefined(obj: any): boolean;        /**         * @name isArray         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is an Array.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is an Array, false otherwise.         */        isArray(obj: any): boolean;        /**         * @name isArrayLike         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it has array-like qualities.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj has array-like qualities (i.e. it is an         * Array, string, arguments, or NodeList), false otherwise.         */        isArrayLike(obj: any): boolean;        /**         * @name isDate         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in anything and determines if it is a Date object.         *          * @param {any} obj Anything.         *          * @returns {boolean} True if obj is a Date object, false otherwise.         */        isDate(obj: any): boolean;        /**         * @name filter         * @memberof plat.IUtils         * @kind function         * @access public         * @variation 0         *          * @description         * Takes in an array and a function to evaluate the properties in the array.         * Returns a filtered array of objects resulting from evaluating the function.         *          * @typeparam {any} T The type of objects contained in the Array being filtered.         *          * @param {Array<T>} array The Array to filter.         * @param {(value: T, index: number, obj: any) => boolean} iterator The iterator function to call with array's properties.         * Returns true if the property should be kept, false otherwise.         * @param {any} context? Optional context with which to call the iterator.         *          * @returns {Array<T>} An array of objects which evaluated to true with the iterator.         */        filter<T>(array: Array<T>, iterator: (value: T, index: number, obj: any) => boolean, context?: any): Array<T>;        /**         * @name filter         * @memberof plat.IUtils         * @kind function         * @access public         * @variation 1         *          * @description         * Takes in an object/array and a function to evaluate the properties in the object/array.         * Returns a filtered array of objects resulting from evaluating the function.         *          * @typeparam {any} T The type of objects contained in the Object/Array being filtered.         *          * @param {any} obj The object to filter.         * @param {(value: T, index: number, obj: any) => boolean} iterator The iterator function to call with array's properties.          * Returns true if the property should be kept, false otherwise.         * @param {any} context? Optional context with which to call the iterator.         *          * @returns {Array<T>} An array of objects which evaluated to true with the iterator.         */        filter<T>(obj: any, iterator: (value: T, key: any, obj: any) => boolean, context?: any): Array<T>;        /**         * @name where         * @memberof plat.IUtils         * @kind function         * @access public         * @variation 0         *          * @description         * Takes in a list and object containing key/value pairs to search for in the list.         *          * @typeparam {any} T The type of objects contained in the input Array.         *          * @param {Array<T>} array The list used for searching for properties.         * @param {any} properties An object containing key/value pairs to match with obj's values.         *          * @returns {Array<T>} The matched values in obj.         */        where<T>(array: Array<T>, properties: any): Array<T>;        /**         * @name where         * @memberof plat.IUtils         * @kind function         * @access public         * @variation 1         *          * @description         * Takes in a list and object containing key/value pairs to search for in the list.         *          * @typeparam {any} T The type of objects contained in the input Object.         *          * @param {any} obj The object used for searching for properties.         * @param {any} properties An object containing key/value pairs to match with obj's values.         *          * @returns {Array<T>} The matched values in obj.         */        where<T>(obj: any, properties: any): Array<T>;        /**         * @name forEach         * @memberof plat.IUtils         * @kind function         * @access public         * @variation 0         *          * @description         * Takes in an Array and a function to iterate over. Calls the iterator function with every property         * in the Array, then returns the object.         *          * @typeparam {any} T The type of objects contained in the input Array.         *          * @param {Array<T>} array An Array.         * @param {(value: T, index: number, obj: any) => void} iterator A method that takes in a value, index, and the object.         * @param {any} context? An optional context to bind to the iterator.         *          * @returns {Array<T>} The array.         */        forEach<T>(array: Array<T>, iterator: (value: T, index: number, obj: any) => void, context?: any): Array<T>;        /**         * @name forEach         * @memberof plat.IUtils         * @kind function         * @access public         * @variation 1         *          * @description         * Takes in an Array and a function to iterate over. Calls the iterator function with every property         * in the Array, then returns the object.         *          * @typeparam {any} T The type of objects contained in the input Object.         *          * @param {any} obj An object.         * @param {(value: T, index: number, obj: any) => void} iterator A method that takes in a value, index, and the object.         * @param {any} context? An optional context to bind to the iterator.         *          * @returns {any} The input Object.         */        forEach<T>(obj: any, iterator: (value: T, key: string, obj: any) => void, context?: any): any;        /**         * @name map         * @memberof plat.IUtils         * @kind function         * @access public         * @variation 0         *          * @description         * Takes in an object and an iterator function. Calls the iterator with all the values in the object. The          * iterator can transform the object and return it. The returned values will be pushed to an Array and          * returned.         *          * @typeparam {any} T The type of objects contained in the input Array.         * @typeparam {any} U The type of objects contained in the transformed output Array.         *          * @param {Array<T>} array An Array.         * @param {(value: T, index: number, obj: any) => U} iterator The transformation function.         * @param {any} context? An optional context to bind to the iterator.         *          * @returns {Array<U>} The accumulated transformed values from the iterator.         */        map<T, U>(array: Array<T>, iterator: (value: T, index: number, obj: any) => U, context?: any): Array<U>;        /**         * @name map         * @memberof plat.IUtils         * @kind function         * @access public         * @variation 1         *          * @description         * Takes in an object and an iterator function. Calls the iterator with all the values in the object. The          * iterator can transform the object and return it. The returned values will be pushed to an Array and          * returned.         *          * @typeparam {any} T The type of objects contained in the input Object/Array.         * @typeparam {any} U The type of objects contained in the transformed output Array.         *          * @param {Array<T>} obj An Object.         * @param {(value: T, index: number, obj: any) => U} iterator The transformation function.         * @param {any} context? An optional context to bind to the iterator.         *          * @returns {Array<U>} The accumulated transformed values from the iterator.         */        map<T, U>(obj: any, iterator: (value: T, key: string, obj: any) => U, context?: any): Array<U>;        /**         * @name pluck         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in an object and a property to extract from all of the object's values. Returns an array of         * the 'plucked' values.         *          * @typeparam {any} T The type of objects contained in the input Object/Array.         * @typeparam {any} U The type of objects contained in the transformed output Array.         *          * @param {any} obj An object.         * @param {string} key The property to 'pluck' from each value in obj.         *          * @returns {Array<U>} An array of 'plucked' values from obj.         */        pluck<T, U>(obj: any, key: string): Array<U>;        /**         * @name some         * @memberof plat.IUtils         * @kind function         * @access public         * @variation 0         *          * @description         * Takes in an array and an iterator. Evaluates all the values in the array with the iterator.         * Returns true if any of the iterators return true, otherwise returns false.         *          * @typeparam {any} T The type of objects contained in the input Array.         *          * @param {Array<T>} array An array.         * @param {(value: T, index: number, obj: any) => boolean} iterator A method with which to evaluate all the values in obj.         * @param {any} context? An optional context to bind to the iterator.         *          * @returns {boolean} True if any calls to iterator return true, false otherwise.         */        some<T>(array: Array<T>, iterator: (value: T, index: number, obj: any) => boolean, context?: any): boolean;        /**         * @name some         * @memberof plat.IUtils         * @kind function         * @access public         * @variation 1         *          * @description         * Takes in an array and an iterator. Evaluates all the values in the array with the iterator.         * Returns true if any of the iterators return true, otherwise returns false.         *          * @typeparam {any} T The type of objects contained in the input Object/Array.         *          * @param {Array<T>} obj An object.         * @param {(value: T, index: number, obj: any) => boolean} iterator A method with which to evaluate all the values in obj.         * @param {any} context? An optional context to bind to the iterator.         *          * @returns {boolean} True if any calls to iterator return true, false otherwise.         */        some<T>(obj: any, iterator: (value: T, key: string, obj: any) => boolean, context?: any): boolean;        /**         * @name postpone         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in a method and array of arguments to pass to that method. Delays calling the method until          * after the current call stack is clear. Equivalent to a setTimeout with a timeout of 0.         *          * @param {(...args: Array<any>) => void} method The method to call.         * @param {Array<any>} args? The arguments to apply to the method.         * @param {any} context? An optional context to bind to the method.         *          * @returns {plat.IRemoveListener} A function that will clear the timeout when called.         */        postpone(method: (...args: any[]) => void, args?: Array<any>, context?: any): IRemoveListener;        /**         * @name defer         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in a method and array of arguments to pass to that method. Delays calling the method until          * after the current call stack is clear. Equivalent to a setTimeout with the specified timeout value.         *          * @param {(...args: Array<any>) => void} method The method to call.         * @param {number} timeout The time (in milliseconds) to delay before calling the provided method         * @param {Array<any>} args? The arguments to apply to the method.         * @param {any} context? An optional context to bind to the method.         *          * @returns {plat.IRemoveListener} A function that will clear the timeout when called.         */        defer(method: (...args: any[]) => void, timeout: number, args?: Array<any>, context?: any): IRemoveListener;        /**         * @name uniqueId         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in a prefix and returns a unique identifier string with the prefix preprended. If no prefix         * is specified, none will be prepended.         *          * @param {string} prefix? A string prefix to prepend tothe unique ID.         *          * @returns {string} The prefix-prepended unique ID.         */        uniqueId(prefix?: string): string;        /**         * @name camelCase         * @memberof plat.IUtils         * @kind function         * @access public         *          * @description         * Takes in a spinal-case, dot.case, or snake_case string and returns          * a camelCase string. Also can turn a string into camelCase with space          * as a delimeter.         *          * @param {string} str The spinal-case, dot.case, or snake_case string.         *          * @returns {string} The camelCase string.         */        camelCase(str: string): string;    }    /**     * @name IIterator     * @memberof plat     * @kind interface     *      * @description     * The Type for a {@link plat.Utils|Utils} iterator callback method.     *      * @typeparam {any} T The value type used in the iterator callback.     * @typeparam {any} U The return type of the iterator callback.     */    export interface IIterator<T, U> {        /**         * @memberof plat.IIterator         * @kind function         * @access public         * @static         *          * @description         * A method signature for {@link plat.IIterator|IIterator}.         *          * @param {T} value The value for an object during an iteration.         * @param {number} index The index where the value can be found.         * @param {any} obj The object passed into the util method.         *          * @returns {U} The returned value.         */        (value: T, index: number, obj: any): U;        /**         * @memberof plat.IIterator         * @kind function         * @access public         * @static         *          * @description         * A method signature for {@link plat.IIterator|IIterator}.         *          * @param {T} value The value for an object during an iteration.         * @param {string} key The key where the value can be found.         * @param {any} obj The object passed into the util method.         *          * @returns {U} The returned value.         */        (value: T, key: string, obj: any): U;    }    /**     * The Type for referencing the '$Window' injectable as a dependency.      * Used so that the Window can be mocked.     */    export function Window(): Window {        return window;    }    register.injectable(__Window, Window);    /**     * The Type for referencing the '$Document' injectable as a dependency.      * Used so that the Window can be mocked.     */    export function Document($Window?: Window): Document {        return $Window.document;    }    register.injectable(__Document, Document, [__Window]);    export module expressions {        /**         * A class for keeping track of commonly used regular expressions.         */        export class Regex implements IRegex {            markupRegex: RegExp;            argumentRegex: RegExp = /\((.*)\)/;            aliasRegex: RegExp = /[^@\.\[\(]+(?=[\.\[\(])/;            initialUrlRegex: RegExp = /\/[^\/]*\.(?:html|htm)/;            protocolRegex: RegExp = /:\/\//;            invalidVariableRegex: RegExp = /[^a-zA-Z0-9@_$]/;            fileNameRegex: RegExp = /.*(?:\/|\\)/;            shiftedKeyRegex: RegExp = /[A-Z!@#$%^&*()_+}{":?><|~]/;            get newLineRegex(): RegExp {                return /\r|\n/g;            }            get optionalRouteRegex(): RegExp {                return /\((.*?)\)/g;            }            get namedParameterRouteRegex(): RegExp {                return /(\(\?)?:\w+/g;            }            get wildcardRouteRegex(): RegExp {                return /\*\w*/g;            }            get escapeRouteRegex(): RegExp {                return /[\-{}\[\]+?.,\\\^$|#\s]/g;            }            get camelCaseRegex(): RegExp {                return /([\-_\.\s])(\w+?)/g;            }            get whiteSpaceRegex(): RegExp {                return /("[^"]*?"|'[^']*?')|[\s\r\n\t\v]/g;            }            get quotationRegex(): RegExp {                return /'|"/g;            }            /**             * Creates the markup regular expression             */            constructor() {                this.markupRegex = new RegExp(__startSymbol + '[\\S\\s]*' + __endSymbol);            }        }        /**         * The Type for referencing the '$Regex' injectable as a dependency.         */        export function IRegex(): IRegex {            return new Regex();        }        register.injectable(__Regex, IRegex);        /**         * An object containing commonly used regular expressions.         */        export interface IRegex {            /**             * The regular expression for matching or removing all newline characters.             */            newLineRegex: RegExp;            /**             * The regular expression for finding markup in a string.             */            markupRegex: RegExp;            /**             * Finds the arguments in a method expression             *              * @example             *   // outputs ["('foo', 'bar', 'baz')", "'foo', 'bar', 'baz'"]             *   exec("myFunction('foo', 'bar', 'baz')");             */            argumentRegex: RegExp;            /**             * Given a string, finds the root alias name if that string is an             * alias path.             *              * @example             *   // outputs ['context']             *   exec('@context.foo');             *              * @example             *   // outputs null             *   exec('@context');             */            aliasRegex: RegExp;            /**             * Finds optional parameters in a route string.             *              * @example             *   // outputs ['(/foo)', '/foo']             *   exec('(/foo)/bar');             *              * @example             *  // outputs ['(/foo)', '/foo']             *  exec('(/foo))');             */            optionalRouteRegex: RegExp;            /**             * Finds named parameters in a route string.             *              * @example             *   // outputs [':foo']             *   exec('/:foo/bar')             *              *   // outputs [':foo']             *   exec('(/:foo)/bar');             */            namedParameterRouteRegex: RegExp;            /**             * Finds an alphanumeric wildcard match in a route string.             *              * @example             *   // outputs ['*bar']             *   exec('/foo/*bar/baz')             */            wildcardRouteRegex: RegExp;            /**             * Finds invalid characters in a route string.             *              * @example             *  // outputs ['?']             *  exec('/foo/bar?query=baz');             */            escapeRouteRegex: RegExp;            /**             * Finds '/*.html' or '/*.htm' in a url. Useful for removing              * the html file out of the url.             *              * @example             *   // outputs ['/index.html']             *   exec('http://localhost:8080/index.html');             */            initialUrlRegex: RegExp;            /**             * Finds a protocol delimeter in a string (i.e. ://)             */            protocolRegex: RegExp;            /**             * Finds delimeters for spinal-case, snake_case, and dot.case.             * useful for converting to camelCase. Also can turn a string             * into camelCase with space as a delimeter.             *              * @example             *   // outputs ['-o', '-', 'o']             *   exec('plat-options')             *              * @example             *   // outputs ['.c', '.', 'c']             *   exec('plat.config')             *              * @example             *   // outputs ['_v', '_', 'v']             *   exec('plat_var')             *              * @example             *   // outputs [' W', ' ', 'W']             *   exec('Hello World')             */            camelCaseRegex: RegExp;            /**             * Finds all whitespace and newline characters              * not in string literals. Needs to be combined              * with string replace function using $1 argument.             */            whiteSpaceRegex: RegExp;            /**             * Finds all single and double quotes.             */            quotationRegex: RegExp;            /**             * Looks for any invalid variable syntax.             */            invalidVariableRegex: RegExp;            /**             * Grabs the file name from a file path.             */            fileNameRegex: RegExp;            shiftedKeyRegex: RegExp;        }        /**         * Responsible for taking a javascript expression string and         * finding all its tokens (i.e. delimiters, operators, etc).         */        export class Tokenizer implements ITokenizer {            /**             * The input string to tokenize.             */            _input: string;            private __previousChar: string = '';            private __variableRegex = (<expressions.IRegex>acquire(__Regex)).invalidVariableRegex;            private __outputQueue: Array<IToken> = [];            private __operatorStack: Array<IToken> = [];            private __argCount: Array<any> = [];            private __objArgCount: Array<number> = [];            private __lastColonChar: Array<string> = [];            private __lastCommaChar: Array<string> = [];            createTokens(input: string): Array<IToken> {                if (isNull(input)) {                    return [];                }                this._input = input;                var char: string,                    length = input.length,                    ternary = 0,                    ternaryFound = false,                    isSpace = this._isSpace,                    isAlphaNumeric = this._isAlphaNumeric;                for (var index = 0; index < length; index++) {                    char = input[index];                    // space                    if (isSpace(char)) {                        continue;                    } else if (isAlphaNumeric(char)) {                        index = this.__handleAplhaNumeric(index, char);                    } else if (isDelimiter(char)) {                        switch (char) {                            case '.':                                index = this.__handlePeriod(index, char);                                break;                            case '{':                                this.__handleLeftBrace(char);                                break;                            case '}':                                this.__handleRightBrace(char);                                break;                            case '[':                                this.__handleLeftBracket(char);                                break;                            case ']':                                this.__handleRightBracket(char);                                break;                            case '(':                                this.__handleLeftParenthesis(char);                                break;                            case ')':                                this.__handleRightParenthesis(char);                                break;                            case ',':                                this.__handleComma(char);                                break;                            case '\'':                            case '"':                                index = this.__handleStringLiteral(index, char);                                break;                        }                    } else if (isOperator(char)) {                        switch (char) {                            case '?':                                ternaryFound = true;                                ternary++;                                this.__handleQuestion(char);                                break;                            case ':':                                ternary = this.__handleColon(char, ternary);                                break;                            default:                                index = this.__handleOtherOperator(index, char);                        }                        // semicolon throw error                    } else if (char === ';') {                        this._throwError('Unexpected semicolon');                    }                    this.__previousChar = char;                }                if (ternaryFound && (ternary > 0)) {                    this._throwError('Improper ternary expression');                } else if (this.__objArgCount.length > 0) {                    this._throwError('Improper object literal');                }                this.__popRemainingOperators();                var output = this.__outputQueue;                this._resetTokenizer();                return output;            }            // alphanumeric case            private __handleAplhaNumeric(index: number, char: string): number {                var functionArr: Array<string> = [],                    isNumberLike = this._isNumeric(char);                functionArr.push(char);                index = this._lookAhead(index, isNumberLike, functionArr);                var mergedValue = functionArr.join(''),                    outputToPush = isNumberLike ? ({ val: Number(mergedValue), args: 0 }) :                    <IToken>({ val: mergedValue, args: -1 });                this.__outputQueue.push(outputToPush);                return index;            }            // delimeter functions            private __handlePeriod(index: number, char: string): number {                var functionArr: Array<string> = [],                    outputQueue = this.__outputQueue,                    operatorStack = this.__operatorStack,                    topOutputLength = outputQueue.length - 1,                    previousChar = this._input[index - 1];                // if output queue is null OR space or operator or ( or , before .                if (topOutputLength < 0 ||                    this._isSpace(previousChar) ||                    !isNull(OPERATORS[previousChar]) ||                    previousChar === '(' ||                    previousChar === ',') {                    functionArr.push(char);                    index = this._lookAhead(index, true, functionArr);                    outputQueue.push({ val: parseFloat(functionArr.join('')), args: 0 });                } else if (!(isNull(outputQueue[topOutputLength]) ||                    !isNumber(Number(outputQueue[topOutputLength].val)) ||                    this._isValEqual(outputQueue[topOutputLength - 1], char))) {                    functionArr.push(char);                    index = this._lookAhead(index, true, functionArr);                    outputQueue[topOutputLength].val += parseFloat(functionArr.join(''));                } else if (this._isValEqual(operatorStack[0], char)) {                    outputQueue.push({ val: char, args: 0 });                } else {                    operatorStack.unshift({ val: char, args: 0 });                }                return index;            }            private __handleLeftBrace(char: string): void {                this.__operatorStack.unshift({ val: char, args: 0 });                this.__objArgCount.push(0);                this.__lastColonChar.push(char);                this.__lastCommaChar.push(char);            }            private __handleRightBrace(char: string): void {                var operatorStack = this.__operatorStack,                    topOperator = operatorStack[0],                    lastArgCount = this.__objArgCount.pop();                if (isNull(topOperator)) {                    this._throwError('Improper object literal');                } else {                    this._popStackForVal(topOperator, '{', 'Improper object literal');                    // pop left brace off stack                    operatorStack.shift();                    this.__lastColonChar.pop();                    this.__lastCommaChar.pop();                    this.__outputQueue.push({ val: '{}', args: lastArgCount });                }            }            private __handleLeftBracket(char: string): void {                var previousChar = this.__previousChar,                    operatorStack = this.__operatorStack;                if (this._isValEqual(operatorStack[0], '.')) {                    this.__outputQueue.push(operatorStack.shift());                }                operatorStack.unshift({ val: char, args: 0 });                this.__argCount.push({                    num: 0,                    isArray: !(previousChar === ']' ||                    previousChar === ')' ||                    this._isAlphaNumeric(previousChar))                });                this.__lastCommaChar.push(char);            }            private __handleRightBracket(char: string): void {                var operatorStack = this.__operatorStack,                    topOperator = operatorStack[0],                    lastArgCountObj = this.__argCount.pop(),                    outputQueue = this.__outputQueue,                    isEmptyArray = (this.__previousChar === '[');                if (isNull(topOperator) || isNull(lastArgCountObj)) {                    this._throwError('Brackets mismatch');                } else {                    if (!lastArgCountObj.isArray) {                        lastArgCountObj.num--;                    }                    this._popStackForVal(topOperator, '[', 'Brackets mismatch');                    // pop left bracket off stack                    operatorStack.shift();                    this.__lastCommaChar.pop();                    // check if function on top of stack                    outputQueue.push({ val: '[]', args: isEmptyArray ? -1 : lastArgCountObj.num + 1 });                }            }            private __handleLeftParenthesis(char: string): void {                var previousChar = this.__previousChar,                    operatorStack = this.__operatorStack;                if (this._isAlphaNumeric(previousChar) || previousChar === ']' || previousChar === ')') {                    var outputQueue = this.__outputQueue,                        topOutput = outputQueue[outputQueue.length - 1];                    if (this._isValEqual(topOutput, '[]')) {                        operatorStack.unshift(outputQueue.pop());                        operatorStack.unshift(outputQueue.pop());                    } else if (!(this._isValEqual(topOutput, '()') || this._isNumeric(topOutput.val))) {                        operatorStack.unshift(outputQueue.pop());                    }                    this.__argCount.push({ num: 0, isFn: true });                }                operatorStack.unshift({ val: char, args: 0 });                this.__lastCommaChar.push(char);            }            private __handleRightParenthesis(char: string): void {                var operatorStack = this.__operatorStack,                    topOperator = operatorStack[0],                    localArgCountObj = this.__argCount.pop();                if (isNull(topOperator)) {                    this._throwError('Parentheses mismatch');                } else {                    this._popStackForVal(topOperator, '(', 'Parentheses mismatch');                    // pop left parenthesis off stack                    operatorStack.shift();                    this.__lastCommaChar.pop();                    // check if function on top of stack                    var previousParen = this.__previousChar === '(';                    if (!isNull(localArgCountObj) &&                        this.__removeFnFromStack(previousParen ? localArgCountObj.num : localArgCountObj.num + 1)) {                        this.__outputQueue.push({ val: '()', args: previousParen ? 0 : (localArgCountObj.num + 1) });                    }                }            }            private __handleComma(char: string): void {                var lastCommaArray = this.__lastCommaChar,                    lastCommaArg = lastCommaArray[lastCommaArray.length - 1];                if (lastCommaArg === '(' || lastCommaArg === '[') {                    var argCountArray = this.__argCount,                        length = argCountArray.length;                    if (length > 0) {                        // increment deepest fn count (don't need to increment obj count because we increment with colon)                        argCountArray[length - 1].num++;                    } else {                        this._throwError('Mismatch with ' + lastCommaArg);                    }                }                var topOperator = this.__operatorStack[0];                if (isNull(topOperator)) {                    this._throwError('Unexpected comma');                } else {                    this._popStackForVal(topOperator, lastCommaArg, 'Unexpected comma');                }            }            private __handleStringLiteral(index: number, char: string): number {                var str = this._lookAheadForDelimiter(char, char, index, true),                    operatorStack = this.__operatorStack,                    topOperator = operatorStack[0];                if (this._isValEqual(topOperator, '([')) {                    operatorStack.unshift({ val: str.char, args: 0 });                } else {                    this.__outputQueue.push({ val: str.char, args: 0 });                }                return str.index;            }            // operator functions            private __handleQuestion(char: string): void {                this.__lastColonChar.push(char);                this.__determinePrecedence(char);            }            private __handleColon(char: string, ternary: number): number {                var lastColonCharArray = this.__lastColonChar,                    lastColonCharacter = lastColonCharArray[lastColonCharArray.length - 1],                    outputQueue = this.__outputQueue;                if (lastColonCharacter === '?') {                    var operatorStack = this.__operatorStack,                        topOperator = operatorStack[0];                    if (isNull(topOperator)) {                        this._throwError('Ternary mismatch');                    } else {                        ternary--;                        // pop latest colon char off queue                        lastColonCharArray.pop();                        this._popStackForVal(topOperator, '?', 'Ternary mismatch');                        outputQueue.push(operatorStack.shift());                        operatorStack.unshift({ val: char, args: 0 });                    }                } else if (lastColonCharacter === '{') {                    var objCountLast = this.__objArgCount.length - 1,                        outputLength = outputQueue.length;                    this.__objArgCount[objCountLast]++;                    if (outputLength > 0) {                        outputQueue[outputLength - 1].args = 1;                    } else {                        this._throwError('Unexpected colon');                    }                } else {                    this._throwError('Unexpected colon');                }                return ternary;            }            private __handleOtherOperator(index: number, char: string): number {                var look = this._lookAheadForOperatorFn(char, index);                this.__determinePrecedence(look.char);                return look.index;            }            private __popRemainingOperators(): void {                var outputQueue = this.__outputQueue,                    operatorStack = this.__operatorStack;                while (operatorStack.length > 0) {                    var topOperator = operatorStack.shift();                    if (topOperator.val === '(' || topOperator.val === ')') {                        this._throwError('Parentheses mismatch');                    }                    outputQueue.push(topOperator);                }            }            // private helper functions            private __determineOperator(operator: any): ITokenDetails {                switch (operator) {                    case '+':                    case '-':                        if (this.__outputQueue.length === 0 || isOperator(this.__previousChar)) {                            return OPERATORS['u' + operator];                        }                    default:                        return OPERATORS[operator];                }            }            private __determinePrecedence(operator: any) {                var determined = false,                    operatorFn = this.__determineOperator(operator),                    operatorPrecedence = operatorFn.precedence,                    operatorAssoc = operatorFn.associativity,                    operatorStack = this.__operatorStack,                    outputQueue = this.__outputQueue,                    firstArrayOperator: ITokenDetails,                    firstArrayVal: any,                    firstArrayObj: IToken;                while (!determined) {                    firstArrayObj = operatorStack[0];                    if (!firstArrayObj) {                        operatorStack.unshift({ val: operator, args: operatorFn.fn.length - 2 });                        return;                    }                    firstArrayVal = operatorStack[0].val;                    firstArrayOperator = OPERATORS[firstArrayVal];                    if (!(isNull(firstArrayOperator) ||                        !(firstArrayOperator.precedence < operatorPrecedence ||                        (firstArrayOperator.precedence === operatorPrecedence && operatorAssoc === 'ltr')))) {                        outputQueue.push(operatorStack.shift());                    } else {                        operatorStack.unshift({ val: operator, args: operatorFn.fn.length - 2 });                        determined = true;                    }                }            }            private __removeFnFromStack(argCount: number): boolean {                var outputQueue = this.__outputQueue,                    operatorStack = this.__operatorStack,                    topOperator = operatorStack[0],                    isValEqual = this._isValEqual,                    isValUnequal = this._isValUnequal,                    fnToken: IToken,                    atLeastOne = false;                while (!isNull(topOperator) &&                    isValUnequal(topOperator, '([') &&                    (this._isStringValidVariable(topOperator.val) ||                    isValEqual(topOperator.val, '[].') ||                    isAccessor(topOperator.val))) {                    fnToken = operatorStack.shift();                    if (!(fnToken.args !== -1 || isValEqual(fnToken, '[].'))) {                        fnToken.args = -2;                    }                    outputQueue.push(fnToken);                    topOperator = operatorStack[0];                    atLeastOne = true;                }                if (!(atLeastOne || isValUnequal(outputQueue[outputQueue.length - argCount - 1], '()'))) {                    atLeastOne = true;                }                return atLeastOne;            }            // protected helper functions            /**             * Determines character type             *              * @param char The character to check             * @param isNumberLike Whether or not the character resembles a number             */            _checkType(char: string, isNumberLike: boolean): boolean {                if (isNumberLike) {                    return this._isNumeric(char);                }                return this._isAlphaNumeric(char);            }            /**             * Looks ahead in the expression to group similar character types.             *              * @param index The current index in the expression string             * @param isNumberLike Whether or not the character resembles a number             * @param array A temporary array used to aggregate similar character types.             * @returns {number} The new index in the expression string             */            _lookAhead(index: number, isNumberLike: boolean, array: Array<string>): number {                var ch: string,                    input = this._input;                while (++index) {                    if (this._checkType((ch = input[index]), isNumberLike)) {                        array.push(ch);                    } else {                        break;                    }                }                return index - 1;            }            /**             * Looks ahead in the expression to try and complete the              * current operator.             *              * @param char The operator to find             * @param index The current index in the expression string             */            _lookAheadForOperatorFn(char: string, index: number): ILookAheadResult {                var ch: string,                    fn: string,                    input = this._input;                while ((++index < input.length) && ch !== '') {                    ch = input[index];                    fn = char + ch;                    if (isOperator(fn)) {                        char = fn;                    } else {                        break;                    }                }                return { char: char, index: index - 1 };            }            /**             * Looks ahead in the expression until it comes to the ending              * character to try and complete a particular sequence              * (i.e. - a string literal).             *              * @param char The starting character             * @param endChar The ending character             * @param index The current index in the expression string             * @param includeDelimiter Whether or not to include the delimiter              * in the result             */            _lookAheadForDelimiter(char: string, endChar: string,                index: number, includeDelimiter?: boolean): ILookAheadResult {                var ch: string,                    input = this._input;                while ((ch = input[++index]) !== endChar) {                    char += ch;                }                if (includeDelimiter) {                    char = char.substr(1);                    index++;                }                return { char: char, index: index - 1 };            }            /**             * Pops the operator stack onto the output queue until a particular              * operator value is reached.             *              * @param topOperator The top of the operator stack             * @param char The operator value being searched for             * @param error The error to throw in the case that the expression              * is invalid.             */            _popStackForVal(topOperator: any, char: string, error: string): void {                var outputQueue = this.__outputQueue,                    operatorStack = this.__operatorStack;                while (topOperator.val !== char) {                    outputQueue.push(operatorStack.shift());                    topOperator = operatorStack[0];                    if (operatorStack.length === 0) {                        this._throwError(error);                    }                }            }            /**             * Check if the 'val' property is equal to a particular character.             *              * @param obj The obj whose 'val' property to compare             * @param char The char to compare with             */            _isValEqual(obj: any, char: string): boolean {                if (isNull(obj) || isNull(obj.val)) {                    return isNull(char);                } else if (obj.val === '') {                    return char === '';                }                return char.indexOf(obj.val) !== -1;            }            /**             * Check if the 'val' property is not equal to a particular character.             *              * @param obj The obj whose 'val' property to compare             * @param char The char to compare with             */            _isValUnequal(obj: any, char: string): boolean {                if (isNull(obj) || isNull(obj.val)) {                    return !isNull(char);                } else if (obj.val === '') {                    return char !== '';                }                return char.indexOf(obj.val) === -1;            }            /**             * Reset the tokenizer's properties.             */            _resetTokenizer(): void {                this._input = null;                this.__previousChar = '';                this.__outputQueue = [];                this.__operatorStack = [];                this.__argCount = [];                this.__objArgCount = [];                this.__lastColonChar = [];                this.__lastCommaChar = [];            }            /**             * Throw an exception in the case of an error.             *              * @param error The error message to throw             */            _throwError(error: string): void {                var $exception: IExceptionStatic = acquire(__ExceptionStatic);                $exception.fatal(error + ' in ' + this._input, $exception.PARSE);            }            /**             * Checks if a single character is numeric.             *              * @param char The character to check.             */            _isNumeric(char: string): boolean {                return ('0' <= char && char <= '9');            }            /**             * Checks if a single character is a space.             *              * @param char The character to check.             */            _isSpace(char: string): boolean {                return (char === ' ' ||                    char === '\r' ||                    char === '\n' ||                    char === '\t' ||                    char === '\v' ||                    char === '\u00A0');            }            /**             * Checks if a single character is an alphabetical              * type character.             *              * @param char The character to check.             */            _isAlpha(char: string): boolean {                return ('a' <= char && char <= 'z' ||                    'A' <= char && char <= 'Z' ||                    '@' === char ||                    '_' === char ||                    '$' === char);            }            /**             * Checks if a single character is alphanumeric.             *              * @param char The character to check.             */            _isAlphaNumeric(char: string): boolean {                return ('a' <= char && char <= 'z' ||                    'A' <= char && char <= 'Z' ||                    '0' <= char && char <= '9' ||                    '@' === char ||                    '_' === char ||                    '$' === char);            }            /**             * Checks if a string has proper javascript variable syntax.             *              * @param input The string to check.             */            _isStringValidVariable(input: string): boolean {                return !this.__variableRegex.test(input);            }        }        /**         * The Type for referencing the '$Tokenizer' injectable as a dependency.         */        export function ITokenizer(): ITokenizer {            return new Tokenizer();        }        register.injectable(__Tokenizer, ITokenizer);        /**         * Describes an object used to find tokens for an expression and create ITokens.         */        export interface ITokenizer {            /**             * Takes in an expression string and outputs ITokens.             *              * @param input The expression string to tokenize.             */            createTokens(input: string): Array<IToken>;        }        /**         * Describes a token in an expression.         */        export interface IToken {            /**             * The string or number value of the token.             */            val: any;            /**             * Denotes the type of token, as well as the number             * of arguments for a function if it is the token.             *              * If -2: Denotes a function name unless indexed into with [].             * If -1: Denotes a variable or empty array literal.             * If 0: Denotes a number, keyword, object indexer (.[]), string literal,             *  function with 0 arguments, ternary expression, or empty object literal             * If 1: Denotes a function type with 1 argument, a property on an object literal,             *  an object literal with 1 property, or an array literal with 1 entry.             * If > 1: Denotes a function type with args arguments, an object literal with             *  args properties, or an array literal with args entries.             */            args: number;        }        /**         * Provides all the necessary details on how to evaluate a token.         */        export interface ITokenDetails {            /**             * The precedence that this token takes with respect to the              * evaluation order.             */            precedence: number;            /**             * Whether or not the token associates with the expression on             * their left or right.             */            associativity: string;            /**             * A function used to evaluate an operator expression.             */            fn: Function;        }        /**         * An object describing the result of looking ahead in the expression.         */        export interface ILookAheadResult {            /**             * The resultant string after after looking ahead             */            char: string;            /**             * The new current index in the expression string             */            index: number;        }        /**         * Parses javascript expression strings and creates IParsedExpressions.         */        export class Parser implements IParser {            $Tokenizer: ITokenizer = acquire(__Tokenizer);            /**             * A single expression's token representation created by the Tokenizer.             */            _tokens: Array<IToken> = [];            private __cache: IObject<IParsedExpression> = {};            private __codeArray: Array<string> = [];            private __identifiers: Array<string> = [];            private __tempIdentifiers: Array<string> = [];            private __aliases: Array<string> = [];            private __uniqueAliases: IObject<boolean> = {};            parse(input: string): IParsedExpression {                var parsedObject = this.__cache[input];                if (!isNull(parsedObject)) {                    return parsedObject;                }                this._tokens = this.$Tokenizer.createTokens(input);                parsedObject = this._evaluate(input);                var identifiers = parsedObject.identifiers;                if (identifiers.length === 0) {                    var noModel = parsedObject.evaluate(null);                    parsedObject.evaluate = function evaluateNoContext() { return noModel; };                }                this.__cache[input] = parsedObject;                return parsedObject;            }            /**             * Evaluate the current token array.             *              * @param input The input string to evaluate.             */            _evaluate(input: string): IParsedExpression {                var tokens = this._tokens,                    length = tokens.length,                    tempIdentifiers = this.__tempIdentifiers,                    codeArray = this.__codeArray,                    codeStr = '',                    useLocalContext = false;                for (var i = 0; i < length; i++) {                    var tokenObj = tokens[i],                        token = tokenObj.val,                        args = tokenObj.args;                    // check if its an accessor                    if (isAccessor(token)) {                        switch (token) {                            case '()':                                useLocalContext = this.__handleFunction(i, args, useLocalContext);                                break;                            case '{}':                                codeArray.push(this.__convertObject(args));                                tempIdentifiers.push('.');                                break;                            default:                                // handle empty array                                if (args < 0) {                                    codeArray.push('[]');                                    tempIdentifiers.push('.');                                    // handle array literal                                } else if (args > 0) {                                    codeArray.push(this.__convertArrayLiteral(args));                                    tempIdentifiers.push('.');                                } else {                                    useLocalContext = this.__indexIntoObject(i, useLocalContext);                                }                                break;                        }                        // check if its an operator                    } else if (isOperator(token)) {                        switch (token) {                            case '?':                                this.__handleQuestion();                                break;                            case ':':                                this.__handleColon();                                break;                            case '+':                            case '-':                                if (args === 1) {                                    this.__handleOperator('u' + token, args);                                    break;                                }                            default:                                // check if string literal                                if (args === 0) {                                    codeStr = this.__convertPrimitive(i, token, args);                                    codeArray.push(codeStr);                                    break;                                }                                this.__handleOperator(token, args);                                break;                        }                        // its either function, object, or primitive                    } else {                        // potential function or object to index into                        if (args < 0) {                            codeStr = this.__convertFunction(i, token, useLocalContext);                            // primitive                        } else {                            codeStr = this.__convertPrimitive(i, token, args);                        }                        codeArray.push(codeStr);                    }                }                // move the rest of the tempIdentifiers to the identifiers                this._popRemainingIdentifiers();                // make the identifiers array unqiue entries only                this._makeIdentifiersUnique();                var parsedExpression: IParsedExpression = {                    evaluate: <(context: any, aliases?: any) => any>new Function('context', 'aliases',                        'var initialContext;' +                        'return ' + (codeArray.length === 0 ? ('"' + input + '"') : codeArray.join('')) + ';'),                    expression: input,                    identifiers: this.__identifiers.slice(0),                    aliases: this.__aliases.slice(0)                };                // reset parser's properties                this._resetParser();                return parsedExpression;            }            // parse cases            private __convertPrimitive(index: number, token: string, args: number): string {                var tempIdentifiers = this.__tempIdentifiers;                if (args > 0) {                    tempIdentifiers.push('.');                    return token;                } else {                    var castToken = Number(token),                        castTokenIsNumberLike = isNumber(castToken),                        peek1 = this._peek(index),                        isPeekIndexer = peek1 && peek1.args < 1;                    if (isKeyword(token) ||                        (isString(token) &&                        (castTokenIsNumberLike ||                        this._isValUnequal(peek1, '[]()') ||                        (this._isValEqual(peek1, '[]') &&                        !isPeekIndexer)))) {                        tempIdentifiers.push('.');                        return '"' + token + '"';                    } else {                        if (!castTokenIsNumberLike ||                            (this._isValEqual(peek1, '[].') &&                            isPeekIndexer)) {                            tempIdentifiers.push(token);                        } else {                            tempIdentifiers.push('.');                        }                        return token;                    }                }            }            private __convertFunction(index: number, token: string, useLocalContext: boolean): string {                var tokens = this._tokens,                    tempIdentifiers = this.__tempIdentifiers,                    nextToken = this._peek(index);                if (token[0] === '@' && isNull(this.__uniqueAliases[token])) {                    this.__uniqueAliases[token] = true;                    this.__aliases.push(token.slice(1));                } else if (isKeyword(token)) {                    tempIdentifiers.push('.');                    return token;                }                if (this._isValEqual(tokens[index - 1], '()') && this._isValEqual(nextToken, '[].')) {                    tempIdentifiers.push('.');                } else {                    tempIdentifiers.push(token);                }                if (!isNull(nextToken)) {                    switch (nextToken.val) {                        case '.':                        case '()':                            return token;                        default:                            if (!useLocalContext) {                                return '(initialContext = (' + this.__findInitialContext.toString() + ')(context,aliases,"' + token + '"))';                            }                            break;                    }                } else {                    return '(initialContext = (' + this.__findInitialContext.toString() + ')(context,aliases,"' + token + '"))';                }            }            private __convertObject(args: number): string {                var identifiers = this.__identifiers,                    tempIdentifiers = this.__tempIdentifiers,                    codeArray = this.__codeArray,                    j = 0,                    key: string,                    codeStr = '{',                    tempIdentifier: string,                    temp: string;                while (j++ < args) {                    temp = codeArray.pop();                    key = codeArray.pop();                    codeStr += ',"' + key + '":' + temp;                    if (tempIdentifiers.length > 1) {                        tempIdentifier = tempIdentifiers.pop();                        // pop the key's tempIdentifier                        tempIdentifiers.pop();                        if (tempIdentifier !== '.') {                            identifiers.push(tempIdentifier);                        }                    }                }                return codeStr.replace(',', '') + '}';            }            private __convertArrayLiteral(args: number): string {                var identifiers = this.__identifiers,                    tempIdentifiers = this.__tempIdentifiers,                    codeArray = this.__codeArray,                    j = 0,                    tempStr = '',                    codeStr = '[',                    tempIdentifier: string;                while (j++ < args) {                    tempStr = codeArray.pop() + ',' + tempStr;                    if (tempIdentifiers.length > 0) {                        tempIdentifier = tempIdentifiers.pop();                        if (tempIdentifier !== '.') {                            identifiers.push(tempIdentifier);                        }                    }                }                codeStr += tempStr.slice(0, tempStr.length - 1) + ']';                return codeStr;            }            // accessors            private __handleFunction(index: number, args: number, useLocalContext: boolean): boolean {                var tokens = this._tokens,                    identifiers = this.__identifiers,                    tempIdentifiers = this.__tempIdentifiers,                    codeArray = this.__codeArray,                    j = 0,                    previousToken = tokens[index - 1],                    previousTokenIsFnName = (previousToken.args === -2),                    grabFnName = previousTokenIsFnName || this._isValEqual(previousToken, '[].'),                    tempStr = '',                    tempIdentifier: string,                    fnName = '',                    identifierFnName = '',                    codeStr: string,                    pushedIdentifier = false;                if (grabFnName) {                    fnName = codeArray.pop();                    identifierFnName = tempIdentifiers.pop();                }                while (j++ < args) {                    tempStr = codeArray.pop() + ',' + tempStr;                    if (tempIdentifiers.length > 0) {                        tempIdentifier = tempIdentifiers.pop();                        if (tempIdentifier !== '.') {                            identifiers.push(tempIdentifier);                            pushedIdentifier = true;                        }                    }                }                if (args > 0) {                    codeStr = '.call(initialContext || context,' + tempStr.slice(0, tempStr.length - 1) + ')';                } else {                    codeStr = '.call(initialContext || context)';                }                if (useLocalContext) {                    useLocalContext = false;                    if (codeArray.length > 0) {                        var context = codeArray.pop();                        var lastIndex = tempIdentifiers.length - 1;                        if (!(lastIndex < 0 || tempIdentifiers[lastIndex] === '.' || identifierFnName === '')) {                            tempIdentifiers[lastIndex] += '.' + identifierFnName;                            identifiers.push(tempIdentifiers.pop());                            // check fn name is not null, pushed an identifier, and the context is not an array literal                        } else if (!(identifierFnName === '' ||                            !pushedIdentifier ||                            context[0] === '[' ||                            context[context.length - 1] === ']')) {                            identifiers[identifiers.length - 1] += '.' + identifierFnName;                        }                        if (isEmpty(fnName)) {                            codeStr = context + codeStr;                        } else {                            codeStr = '((' + this.__indexIntoContext.toString() + ')(' + context + ',"' +                            fnName + '") || (function () {}))' + codeStr;                        }                    } else {                        this._throwError('Improper expression or context');                    }                } else {                    if (grabFnName) {                        codeStr = '(initialContext = ((' + this.__findInitialContext.toString() + ')(context,aliases,"' +                        fnName + '") || (function () {}))' + codeStr + ')';                        identifiers.push(fnName);                    } else {                        codeStr = codeArray.pop() + codeStr;                    }                }                codeArray.push(codeStr);                var peek = this._peek(index),                    length = tempIdentifiers.length;                if (this._isValEqual(peek, '[]') && length > 0) {                    var lastIdentifier = tempIdentifiers[length - 1];                    if (lastIdentifier !== '.') {                        identifiers.push(tempIdentifiers.pop());                    }                }                return useLocalContext;            }            private __indexIntoObject(index: number, useLocalContext: boolean): boolean {                var tokens = this._tokens,                    identifiers = this.__identifiers,                    tempIdentifiers = this.__tempIdentifiers,                    codeArray = this.__codeArray,                    nextChar = this._peek(index),                    lastIndex: number;                if (this._isValEqual(nextChar, '()')) {                    return true;                }                var codeStr = codeArray.pop(),                    previousToken = tokens[index - 1],                    identifierIndexer = tempIdentifiers.pop(),                    hasIdentifierIndexer = !isNull(identifierIndexer),                    context = codeArray.pop(),                    token = tokens[index];                if (hasIdentifierIndexer && identifierIndexer[0] === '@') {                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + context + ',' + codeStr + ')';                    identifiers.push(identifierIndexer);                    if (tempIdentifiers.length > 0) {                        identifiers.push(tempIdentifiers.pop());                    }                } else if (this._isValEqual(previousToken, '++--()[]*/%?:>=<=&&||!===')) {                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + context + ',' + codeStr + ')';                    tempIdentifiers.push('.');                } else if (previousToken.args < 0 && this._isValEqual(token, '[]')) {                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + context + ',' + codeStr + ')';                    lastIndex = tempIdentifiers.length - 1;                    if (lastIndex >= 0) {                        if (tempIdentifiers[lastIndex] !== '.') {                            identifiers.push(tempIdentifiers.pop());                        }                    }                    identifiers.push(identifierIndexer);                } else {                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + context + ',"' + codeStr + '")';                    lastIndex = tempIdentifiers.length - 1;                    if (lastIndex >= 0) {                        if (tempIdentifiers[lastIndex] !== '.') {                            tempIdentifiers[lastIndex] += '.' + identifierIndexer;                        }                    } else if (hasIdentifierIndexer && identifierIndexer !== '.' && this._isValUnequal(token, '.')) {                        identifiers.push(identifierIndexer);                    }                }                codeArray.push(codeStr);                return useLocalContext;            }            // operators            private __handleQuestion(): void {                var identifiers = this.__identifiers,                    tempIdentifiers = this.__tempIdentifiers,                    codeArray = this.__codeArray,                    temp = codeArray.pop(),                    codeStr = codeArray.pop() + '?' + temp,                    tempIdentifier: string;                for (var i = 0; i < 2; i++) {                    if (tempIdentifiers.length > 0) {                        tempIdentifier = tempIdentifiers.pop();                        if (tempIdentifier !== '.') {                            identifiers.push(tempIdentifier);                        }                    } else {                        break;                    }                }                codeArray.push(codeStr);            }            private __handleColon(): void {                var identifiers = this.__identifiers,                    tempIdentifiers = this.__tempIdentifiers,                    codeArray = this.__codeArray,                    temp = codeArray.pop(),                    codeStr = codeArray.pop() + ':' + temp,                    tempIdentifier: string;                for (var i = 0; i < 2; i++) {                    if (tempIdentifiers.length > 0) {                        tempIdentifier = tempIdentifiers.pop();                        if (tempIdentifier !== '.') {                            identifiers.push(tempIdentifier);                        }                    } else {                        break;                    }                }                codeArray.push(codeStr);            }            private __handleOperator(token: string, args: number): void {                var identifiers = this.__identifiers,                    tempIdentifiers = this.__tempIdentifiers,                    codeArray = this.__codeArray,                    j = 0,                    tempStr = '',                    codeStr = '(' + OPERATORS[token].fn.toString() + ')(context, aliases,',                    tempIdentifier: string;                while (j++ < args) {                    tempStr = 'function (context, aliases) { return ' + codeArray.pop() + '; }' + ',' + tempStr;                    if (tempIdentifiers.length > 0) {                        tempIdentifier = tempIdentifiers.pop();                        if (tempIdentifier !== '.') {                            identifiers.push(tempIdentifier);                        }                    }                }                codeStr += tempStr.slice(0, tempStr.length - 1) + ')';                codeArray.push(codeStr);            }            // private helper functions            private __findInitialContext(context: any, aliases: any, token: string, undefined?: any): any {                if (token[0] === '@' && aliases !== null && typeof aliases === 'object') {                    return aliases[token];                } else if (context !== null && typeof context === 'object') {                    return context[token];                }                return undefined;            }            private __indexIntoContext(context: any, token: string, undefined?: any): any {                if (context !== null && typeof context === 'object') {                    return context[token];                }                return undefined;            }            // protected helper functions            /**             * Peek at the next token.             *              * @param index The current index.             */            _peek(index: number): IToken {                return this._tokens[index + 1];            }            /**             * Evaluate and remove the leftover identifiers.             */            _popRemainingIdentifiers(): void {                var identifiers = this.__identifiers,                    tempIdentifiers = this.__tempIdentifiers,                    last: string;                while (tempIdentifiers.length > 0) {                    last = tempIdentifiers.pop();                    if (last !== '.') {                        identifiers.push(last);                    }                }            }            /**             * Remove duplicate identifiers.             */            _makeIdentifiersUnique(): void {                var identifiers = this.__identifiers,                    uniqueIdentifiers: Array<string> = [],                    uniqueIdentifierObject: IObject<boolean> = {},                    identifier: string;                while (identifiers.length > 0) {                    identifier = identifiers.pop();                    if (isNull(uniqueIdentifierObject[identifier])) {                        uniqueIdentifierObject[identifier] = true;                        uniqueIdentifiers.push(identifier);                    }                }                this.__identifiers = uniqueIdentifiers;            }            /**             * Check if the 'val' property is equal to a particular character.             *              * @param obj The obj whose 'val' property to compare             * @param char The char to compare with             */            _isValEqual(obj: any, char: string): boolean {                if (isNull(obj) || isNull(obj.val)) {                    return isNull(char);                } else if (obj.val === '') {                    return char === '';                }                return char.indexOf(obj.val) !== -1;            }            /**             * Check if the 'val' property is not equal to a particular character.             *              * @param obj The obj whose 'val' property to compare             * @param char The char to compare with             */            _isValUnequal(obj: any, char: string): boolean {                if (isNull(obj) || isNull(obj.val)) {                    return !isNull(char);                } else if (obj.val === '') {                    return char !== '';                }                return char.indexOf(obj.val) === -1;            }            /**             * Reset the parser's properties.             */            _resetParser(): void {                this._tokens = [];                this.__codeArray = [];                this.__identifiers = [];                this.__tempIdentifiers = [];                this.__aliases = [];                this.__uniqueAliases = {};            }            /**             * Throw an exception in the case of an error.             *              * @param error The error message to throw             */            _throwError(error: string): void {                var $exception: IExceptionStatic = acquire(__ExceptionStatic);                $exception.fatal(error, $exception.PARSE);            }        }        /**         * The Type for referencing the '$Parser' injectable as a dependency.         */        export function IParser(): IParser {            return new Parser();        }        register.injectable(__Parser, IParser);        /**         * Describes an object that can parse an expression string and turn it into an         * IParsedExpression. The intended external interface for the '$Parser'          * injectable.         */        export interface IParser {            /**             * Takes in an expression string and outputs an IParsedExpression.             *              * @param input An expression string to parse.             */            parse(expression: string): IParsedExpression;        }        /**         * Describes an object that is the result of parsing an expression string. Provides a         * way to evaluate the expression with a context.         */        export interface IParsedExpression {            /**             * A method for evaluating an expression with a context.             *              * @param context The primary context for evaluation.             * @param aliases An object containing resource alias values. All keys must begin with '@'.             */            evaluate(context?: any, aliases?: any): any;            /**             * The original expression string.             */            expression: string;            /**             * Contains all the identifiers found in an expression.  Useful for determining             * properties to watch on a context.             */            identifiers: Array<string>;            /**             * Contains all the aliases (denoted by an identifier with '@' as the first character) for this IParsedExpression.             */            aliases: Array<string>;            /**             * Specifies whether or not you want to do a one-time binding on identifiers              * for this expression. Typically this is added to a clone of the IParsedExpression.             */            oneTime?: boolean;        }    }        /**     * @name web     * @memberof plat     * @kind namespace     *      * @description     * Holds classes and interfaces related to event management.     */    export module web {        /**         * @name Browser         * @memberof plat.web         * @kind class         *          * @implements {plat.web.IBrowser}         *          * @description         * The class that handles all interaction with the browser.         */        export class Browser implements IBrowser {            /**             * @name config             * @memberof plat.web.Browser             * @kind property             * @access public             * @static             *              * @type {plat.web.IBrowserConfig}             *              * @description             * The {@link plat.web.IBrowserConfig|IBrowserConfig} injectable object.             */            static config: IBrowserConfig = {                NONE: 'none',                HASH: 'hash',                STATE: 'state',                routingType: 'none',                hashPrefix: '',                baseUrl: ''            };            /**             * @name $EventManagerStatic             * @memberof plat.web.Browser             * @kind property             * @access public             *              * @type {plat.events.IEventManagerStatic}             *              * @description             * Reference to the {@link plat.events.IEventManagerStatic|IEventManagerStatic} injectable.             */            $EventManagerStatic: events.IEventManagerStatic = acquire(__EventManagerStatic);            /**             * @name $Compat             * @memberof plat.web.Browser             * @kind property             * @access public             *              * @type {plat.ICompat}             *              * @description             * Reference to the {@link plat.ICompat|ICompat} injectable.             */            $Compat: ICompat = acquire(__Compat);            /**             * @name $Regex             * @memberof plat.web.Browser             * @kind property             * @access public             *              * @type {plat.expressions.IRegex}             *              * @description             * Reference to the {@link plat.expressions.IRegex|IRegex} injectable.             */            $Regex: expressions.IRegex = acquire(__Regex);            /**             * @name $Window             * @memberof plat.web.Browser             * @kind property             * @access public             *              * @type {Window}             *              * @description             * Reference to the Window injectable.             */            $Window: Window = acquire(__Window);            /**             * @name $Dom             * @memberof plat.web.Browser             * @kind property             * @access public             *              * @type {plat.ui.IDom}             *              * @description             * Reference to the {@link plat.ui.IDom|IDom} injectable.             */            $Dom: ui.IDom = acquire(__Dom);            /**             * @name uid             * @memberof plat.web.Browser             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * A unique string identifier.             */            uid: string;            /**             * @name __currentUrl             * @memberof plat.web.Browser             * @kind property             * @access private             *              * @type {string}             *              * @description             * The browser's current URL.             */            private __currentUrl: string;            /**             * @name __lastUrl             * @memberof plat.web.Browser             * @kind property             * @access private             *              * @type {string}             *              * @description             * The browser's last URL.             */            private __lastUrl = this.$Window.location.href;            /**             * @name __initializing             * @memberof plat.web.Browser             * @kind property             * @access private             *              * @type {boolean}             *              * @description             * Whether or not the browser is in an initialization state.             */            private __initializing = false;            /**             * @name constructor             * @memberof plat.web.Browser             * @kind function             * @access public             *              * @description             * The constructor for a {@link plat.web.Browser|Browser}. Assigns a uid and subscribes to the 'beforeLoad' event.             *              * @returns {plat.web.Browser} A {@link plat.web.Browser|Browser} instance.             */            constructor() {                var ContextManager: observable.IContextManagerStatic = acquire(__ContextManagerStatic);                ContextManager.defineGetter(this, 'uid', uniqueId('plat_'));                this.$EventManagerStatic.on(this.uid, 'beforeLoad', this.initialize, this);            }            /**             * @name initialize             * @memberof plat.web.Browser             * @kind function             * @access public             *              * @description             * Initializes the {@link plat.web.Browser|Browser} instance, trims the url, and              * adds events for popstate and hashchange.             *              * @returns {void}             */            initialize(): void {                var $config = Browser.config,                    $compat = this.$Compat;                this.$EventManagerStatic.dispose(this.uid);                if ($config.routingType === $config.NONE) {                    return;                }                this.__initializing = true;                var url = this.url(),                    trimmedUrl = url.replace(this.$Regex.initialUrlRegex, '/'),                    changed = this._urlChanged.bind(this),                    $dom = this.$Dom,                    $window = this.$Window;                if (isEmpty($config.baseUrl)) {                    acquire(__UrlUtilsInstance);                }                if (trimmedUrl !== url) {                    this.url(trimmedUrl, true);                }                if ($compat.pushState) {                    if ($config.routingType === $config.STATE) {                        this.url($config.baseUrl, true);                    }                    $dom.addEventListener($window, 'popstate', changed, false);                }                $dom.addEventListener($window, 'hashchange', changed, false);                this.__initializing = false;            }            /**             * @name url             * @memberof plat.web.Browser             * @kind function             * @access public             *              * @description             * Sets or gets the current $Window.location             *              * @param {string} url? The URL to set the location to.             * @param {boolean} replace? Whether or not to replace the current URL in              * the history.             *              * @returns {string} The current URL or current location.             */            url(url?: string, replace?: boolean): string {                var location = this.$Window.location;                if (isString(url) && this.__lastUrl !== url) {                    this.__lastUrl = url;                    this._setUrl(url, replace);                }                return this.__currentUrl || location.href;            }            /**             * @name urlUtils             * @memberof plat.web.Browser             * @kind function             * @access public             *              * @description             * Creates a new {@link plat.web.IUrlUtils|IUrlUtils} object.             *              * @param url? The URL to associate with the new {@link plat.web.UrlUtils|UrlUtils}              * instance.             *              * @returns {@link plat.web.IUrlUtils|IUrlUtils} The new {@link plat.web.IUrlUtils|IUrlUtils} object.             */            urlUtils(url?: string): IUrlUtilsInstance {                url = url || this.url();                var $urlUtils: IUrlUtilsInstance = acquire(__UrlUtilsInstance),                    $config = Browser.config;                if ($config.routingType === $config.HASH) {                    url = url.replace(new RegExp('#' + ($config.hashPrefix || '') + '/?'), '');                }                $urlUtils.initialize(url);                return $urlUtils;            }            /**             * @name isCrossDomain             * @memberof plat.web.Browser             * @kind function             * @access public             *              * @description             * Checks to see if the requested URL is cross domain.             *              * @param url The URL to verify whether or not it's cross domain.             *              * @returns {boolean} Whether or not the URL argument is cross domain.             */            isCrossDomain(url: string): boolean {                if (!isString(url)) {                    return false;                }                var urlUtils = this.urlUtils(url),                    locationUtils = this.urlUtils();                // check for protocol:host:port mismatch                return urlUtils.protocol !== locationUtils.protocol ||                    urlUtils.hostname !== locationUtils.hostname ||                    urlUtils.port !== locationUtils.port;            }            /**             * @name _urlChanged             * @memberof plat.web.Browser             * @kind function             * @access public             *              * @description             * The event to fire in the case of a URL change. It kicks              * off a 'urlChanged' direct event notification.             *              * @param url The URL to verify whether or not it's cross domain.             *              * @returns {void}             */            _urlChanged(): void {                if (this.__initializing) {                    return;                }                this.__currentUrl = null;                var url = this.url();                if (this.__lastUrl === url) {                    return;                }                this.__lastUrl = url;                var $manager = this.$EventManagerStatic;                $manager.dispatch('urlChanged',                    this,                    $manager.DIRECT,                    [this.urlUtils()]);            }            /**             * @name _setUrl             * @memberof plat.web.Browser             * @kind function             * @access public             *              * @description             * Checks for the existence of pushState and              * sets the browser URL accordingly.             *              * @param {string} url The URL to set.             * @param {boolean} replace? Whether or not to replace the              * current URL in the history.             *              * @returns {void}             */            _setUrl(url: string, replace?: boolean): void {                url = this._formatUrl(url);                if (this.$Compat.pushState) {                    if (replace) {                        history.replaceState(null, '', url);                    } else {                        history.pushState(null, '', url);                    }                    if (!this.__initializing) {                        this._urlChanged();                    }                } else {                    this.__currentUrl = url;                    if (replace) {                        location.replace(url);                    } else {                        location.href = url;                    }                }            }            /**             * @name _formatUrl             * @memberof plat.web.Browser             * @kind function             * @access public             *              * @description             * Formats the URL in the case of HASH routing.             *              * @param url The URL to format.             *              * @returns {string} The formatted URL.             */            _formatUrl(url: string): string {                var $config = Browser.config;                if ($config.routingType === $config.HASH) {                    var hasProtocol = url.indexOf(this.urlUtils().protocol) !== -1,                        prefix = $config.hashPrefix || '',                        hashRegex = new RegExp('#' + prefix + '|#/');                    if (hasProtocol && !hashRegex.test(url)) {                        url = url + '#' + prefix + '/';                    } else if (!hashRegex.test(url)) {                        url = '#' + prefix + '/' + url;                    }                }                return url;            }        }        /**         * The Type for referencing the '$Browser' injectable as a dependency.         */        export function IBrowser(): IBrowser {            return new Browser();        }        register.injectable(__Browser, IBrowser);        /**         * @name IBrowser         * @memberof plat.web         * @kind interface         *          * @description         * Defines an object that handles interaction with the browser.         */        export interface IBrowser {            /**             * @name uid             * @memberof plat.web.IBrowser             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * A unique string identifier.             */            uid: string;            /**             * @name initialize             * @memberof plat.web.IBrowser             * @kind function             * @access public             *              * @description             * Initializes the {@link plat.web.Browser|Browser} instance, trims the url, and              * adds events for popstate and hashchange.             *              * @returns {void}             */            initialize(): void;            /**             * @name url             * @memberof plat.web.IBrowser             * @kind function             * @access public             *              * @description             * Sets or gets the current $Window.location             *              * @param {string} url? The URL to set the location to.             * @param {boolean} replace? Whether or not to replace the current URL in              * the history.             *              * @returns {string} The current URL or current location.             */            url(url?: string, replace?: boolean): string;            /**             * @name urlUtils             * @memberof plat.web.IBrowser             * @kind function             * @access public             *              * @description             * Creates a new {@link plat.web.IUrlUtils|IUrlUtils} object.             *              * @param url? The URL to associate with the new {@link plat.web.UrlUtils|UrlUtils}              * instance.             *              * @returns {@link plat.web.IUrlUtils|IUrlUtils} The new {@link plat.web.IUrlUtils|IUrlUtils} object.             */            urlUtils(url?: string): IUrlUtilsInstance;            /**             * @name isCrossDomain             * @memberof plat.web.IBrowser             * @kind function             * @access public             *              * @description             * Checks to see if the requested URL is cross domain.             *              * @param url The URL to verify whether or not it's cross domain.             *              * @returns {boolean} Whether or not the URL argument is cross domain.             */            isCrossDomain(url: string): boolean;        }        /**         * The Type for referencing the '$BrowserConfig' injectable as a dependency.         */        export function IBrowserConfig(): IBrowserConfig {            return Browser.config;        }        register.injectable(__BrowserConfig, IBrowserConfig);        /**         * @name IBrowserConfig         * @memberof plat.web         * @kind interface         *          * @description         * Specifies configuration properties for the {@link plat.web.IBrowser|IBrowser}           * injectable.         */        export interface IBrowserConfig {            /**             * @name NONE             * @memberof plat.web.IBrowserConfig             * @kind property             * @access public             *              * @type {string}             *              * @description             * Specifies that the application will not be doing              * url-based routing.             */            NONE: string;            /**             * @name HASH             * @memberof plat.web.IBrowserConfig             * @kind property             * @access public             *              * @type {string}             *              * @description             * Specifies that the application wants to use hash-based              * routing.             */            HASH: string;            /**             * @name STATE             * @memberof plat.web.IBrowserConfig             * @kind property             * @access public             *              * @type {string}             *              * @description             * Specifies that the application wants to use the HTML5              * popstate method for managing routing. If the browser              * does not support HTML5 popstate events, hash routing              * will be used instead.             *              * Note: In 'state' mode, the web server must be configured to              * route every url to the root url.             */            STATE: string;            /**             * @name routingType             * @memberof plat.web.IBrowserConfig             * @kind property             * @access public             *              * @type {string}             *              * @description             * Allows you to define how your app will route. There are             * three modes, NONE ('none'), HASH ('hash'), and STATE ('state').              *              * In NONE, the application will not be responding to              * url changes.             *              * In HASH, the application will use a hash prefix and              * all navigation will be managed with hash changes.             *              * In STATE mode, the application will use the 'popstate'              * event and will be able to manage routes. The web server              * must be configured to route every URL to the root URL if              * using STATE mode.             *              * The default mode is NONE.             */            routingType: string;            /**             * @name hashPrefix             * @memberof plat.web.IBrowserConfig             * @kind property             * @access public             *              * @type {string}             *              * @description             * If routingType is set to HASH ('hash'), this value will be              * appended to the '#' at the beginning of every route. The              * default prefix is '!', meaning each path will be '#!/<path>'.             */            hashPrefix: string;            /**             * @name baseUrl             * @memberof plat.web.IBrowserConfig             * @kind property             * @access public             *              * @type {string}             *              * @description             * Specifies the base URL used to normalize URL routing.             */            baseUrl: string;        }        /**         * @name UrlUtils         * @memberof plat.web         * @kind class         *          * @implements {plat.web.IUrlUtilsInstance}         *          * @description         * Deals with obtaining detailed information about an          * associated URL.         */        export class UrlUtils implements IUrlUtilsInstance {            /**             * @name __urlUtilsElement             * @memberof plat.web.UrlUtils             * @kind property             * @access private             * @static             *              * @type {HTMLAnchorElement}             *              * @description             * Helps with URL initialization through it's href attribute.             */            private static __urlUtilsElement: HTMLAnchorElement;            /**             * @name __getQuery             * @memberof plat.web.UrlUtils             * @kind function             * @access private             * @static             *              * @description             * Creates a query object out of the URL's query search string.             *              * @param {string} search The URL's query search string.             *              * @returns {plat.IObject<string>} An object consisting of key-value pairs              * representing the query string.             */            private static __getQuery(search: string): IObject<string> {                if (isEmpty(search)) {                    return;                }                var split = search.split('&'),                    query: IObject<string> = {},                    length = split.length,                    item: Array<string>;                for (var i = 0; i < length; ++i) {                    item = split[i].split('=');                    query[item[0]] = item[1];                }                return query;            }            /**             * @name __getBaseUrl             * @memberof plat.web.UrlUtils             * @kind function             * @access private             * @static             *              * @description             * Obtains the base URL for the app/site for doing STATE type routing.             *              * @param {string} url The initial URL passed into the Browser.             *              * @returns {string} The base URL.             */            private static __getBaseUrl(url: string): string {                var colon = url.substring(url.indexOf(':')),                    next = colon.substring(colon.search(/\w+/));                return url.substring(0, url.indexOf('/', url.indexOf(next))) + '/';            }            /**             * @name $ContextManagerStatic             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {plat.observable.IContextManagerStatic}             *              * @description             * Reference to the {@link plat.observable.IContextManagerStatic|IContextManagerStatic} injectable.             */            $ContextManagerStatic: observable.IContextManagerStatic = acquire(__ContextManagerStatic);            /**             * @name $Document             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {Document}             *              * @description             * Reference to the Document injectable.             */            $Document: Document = acquire(__Document);            /**             * @name $Window             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {Window}             *              * @description             * Reference to the Window injectable.             */            $Window: Window = acquire(__Window);            /**             * @name $Compat             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {plat.ICompat}             *              * @description             * Reference to the {@link plat.ICompat|ICompat} injectable.             */            $Compat: ICompat = acquire(__Compat);            /**             * @name $Regex             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {plat.expressions.IRegex}             *              * @description             * Reference to the {@link plat.expressions.IRegex|IRegex} injectable.             */            $Regex: expressions.IRegex = acquire(__Regex);            /**             * @name $BrowserConfig             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {plat.web.IBrowserConfig}             *              * @description             * Reference to the {@link plat.web.IBrowserConfig|IBrowserConfig} injectable.             */            $BrowserConfig: IBrowserConfig = acquire(__BrowserConfig);            /**             * @name href             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {string}             *              * @description             * The whole associated URL.             */            href: string;            /**             * @name protocol             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {string}             *              * @description             * The protocol scheme of the URL, including the final ':' of the associated URL.             */            protocol: string;            /**             * @name host             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {string}             *              * @description             * The hostname and port of the associated URL.             */            host: string;            /**             * @name hostname             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {string}             *              * @description             * The domain of the associated URL.             */            hostname: string;            /**             * @name port             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {string}             *              * @description             * The port number of the associated URL.             */            port: string;            /**             * @name pathname             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {string}             *              * @description             * The additional path value in the associated URL preceded by a '/'.              * Removes the query string.             */            pathname: string;            /**             * @name search             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {string}             *              * @description             * A '?' followed by the included parameters in the associated URL.             */            search: string;            /**             * @name hash             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {string}             *              * @description             * A '#' followed by the included hash fragments in the associated URL.             */            hash: string;            /**             * @name username             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {string}             *              * @description             * The username specified before the domain name in the associated URL.             */            username: string;            /**             * @name password             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {string}             *              * @description             * The password specified before the domain name in the associated URL.             */            password: string;            /**             * @name origin             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {string}             *              * @description             * The origin of the associated URL (its protocol, domain, and port).             */            origin: string;            /**             * @name query             * @memberof plat.web.UrlUtils             * @kind property             * @access public             *              * @type {any}             *              * @description             * An object containing keyed query arguments from the associated URL.             */            query: any;            /**             * @name constructor             * @memberof plat.web.UrlUtils             * @kind function             * @access public             *              * @description             * The constructor for a {@link plat.web.UrlUtils|UrlUtils} instance.              * Handles parsing the initial URL and obtain the base URL if necessary.             *              * @returns {plat.web.UrlUtils} A {@link plat.web.UrlUtils|UrlUtils} instance.             */            constructor() {                var $config = this.$BrowserConfig;                if (isEmpty($config.baseUrl)) {                    var url = this.$Window.location.href,                        trimmedUrl = url.replace(this.$Regex.initialUrlRegex, '/');                    if ($config.routingType === $config.HASH) {                        $config.baseUrl = trimmedUrl.replace(/#.*/, '');                    } else {                        $config.baseUrl = UrlUtils.__getBaseUrl(trimmedUrl);                    }                }            }            /**             * @name initialize             * @memberof plat.web.UrlUtils             * @kind function             * @access public             *              * @description             * Initializes and defines properties using              * the input url.             *              * @param {string} url The input to associate with this {@link plat.web.UrlUtils|UrlUtils} instance.             *              * @returns {void}             */            initialize(url: string): void {                url = url || '';                var element = UrlUtils.__urlUtilsElement ||                    (UrlUtils.__urlUtilsElement = this.$Document.createElement('a')),                    define = this.$ContextManagerStatic.defineGetter;                // always make local urls relative to start page.                if (url[0] === '/') {                    url = url.substr(1);                }                element.setAttribute('href', url);                url = element.href;                // we need to do this twice for cerain browsers (e.g. win8)                element.setAttribute('href', url);                url = element.href;                var protocol = element.protocol ? element.protocol.replace(/:$/, '') : '';                // cordova adds //www for some urls, so we want to take those out.                if (protocol.indexOf('http') === -1 && protocol.indexOf('ms-appx') === -1) {                    url = url.replace('//', '');                }                define(this, 'href', url, true, true);                define(this, 'protocol', element.protocol ? element.protocol.replace(/:$/, '') : '', true, true);                define(this, 'host', element.host, true, true);                define(this, 'search', element.search ? element.search.replace(/^\?/, '') : '', true, true);                define(this, 'hash', element.hash ? element.hash.replace(/^#/, '') : '', true, true);                define(this, 'hostname', element.hostname, true, true);                define(this, 'port', element.port, true, true);                var path: string;                if (!isEmpty(this.$BrowserConfig.baseUrl)) {                    path = url.replace(this.$BrowserConfig.baseUrl, '/');                } else {                    path = (element.pathname.charAt(0) === '/')                    ? element.pathname                    : '/' + element.pathname;                }                define(this, 'pathname', path.split('?')[0], true, true);                define(this, 'query', UrlUtils.__getQuery(this.search), true, true);            }            /**             * @name toString             * @memberof plat.web.UrlUtils             * @kind function             * @access public             *              * @description             * A toString function implementation for the {@link plat.web.UrlUtils|UrlUtils} class.             *              * @returns {string} The href associated with this {@link plat.web.UrlUtils|UrlUtils} instance.             */            toString(): string {                return this.href;            }        }        /**         * The Type for referencing the '$UrlUtilsInstance' injectable as a dependency.         */        export function IUrlUtilsInstance(): IUrlUtilsInstance {            return new UrlUtils();        }        register.injectable(__UrlUtilsInstance, IUrlUtilsInstance, null, __INSTANCE);        /**         * @name IUrlUtilsInstance         * @memberof plat.web         * @kind interface         *          * @description         * Defines an object that deals with obtaining detailed information about an          * associated URL.         */        export interface IUrlUtilsInstance {            /**             * @name href             * @memberof plat.web.IUrlUtilsInstance             * @kind property             * @access public             *              * @type {string}             *              * @description             * The whole associated URL.             */            href: string;            /**             * @name protocol             * @memberof plat.web.IUrlUtilsInstance             * @kind property             * @access public             *              * @type {string}             *              * @description             * The protocol scheme of the URL, including the final ':' of the associated URL.             */            protocol: string;            /**             * @name host             * @memberof plat.web.IUrlUtilsInstance             * @kind property             * @access public             *              * @type {string}             *              * @description             * The hostname and port of the associated URL.             */            host: string;            /**             * @name hostname             * @memberof plat.web.IUrlUtilsInstance             * @kind property             * @access public             *              * @type {string}             *              * @description             * The domain of the associated URL.             */            hostname: string;            /**             * @name port             * @memberof plat.web.IUrlUtilsInstance             * @kind property             * @access public             *              * @type {string}             *              * @description             * The port number of the associated URL.             */            port: string;            /**             * @name pathname             * @memberof plat.web.IUrlUtilsInstance             * @kind property             * @access public             *              * @type {string}             *              * @description             * The additional path value in the associated URL preceded by a '/'.              * Removes the query string.             */            pathname: string;            /**             * @name search             * @memberof plat.web.IUrlUtilsInstance             * @kind property             * @access public             *              * @type {string}             *              * @description             * A '?' followed by the included parameters in the associated URL.             */            search: string;            /**             * @name hash             * @memberof plat.web.IUrlUtilsInstance             * @kind property             * @access public             *              * @type {string}             *              * @description             * A '#' followed by the included hash fragments in the associated URL.             */            hash: string;            /**             * @name username             * @memberof plat.web.IUrlUtilsInstance             * @kind property             * @access public             *              * @type {string}             *              * @description             * The username specified before the domain name in the associated URL.             */            username?: string;            /**             * @name password             * @memberof plat.web.IUrlUtilsInstance             * @kind property             * @access public             *              * @type {string}             *              * @description             * The password specified before the domain name in the associated URL.             */            password?: string;            /**             * @name origin             * @memberof plat.web.IUrlUtilsInstance             * @kind property             * @access public             *              * @type {string}             *              * @description             * The origin of the associated URL (its protocol, domain, and port).             */            origin?: string;            /**             * @name query             * @memberof plat.web.IUrlUtilsInstance             * @kind property             * @access public             *              * @type {any}             *              * @description             * An object containing keyed query arguments from the associated URL.             */            query?: any;            /**             * @name initialize             * @memberof plat.web.IUrlUtilsInstance             * @kind function             * @access public             *              * @description             * Initializes and defines properties using              * the input url.             *              * @param {string} url The input to associate with this {@link plat.web.IUrlUtilsInstance|IUrlUtilsInstance}.             *              * @returns {void}             */            initialize(url: string): void;            /**             * @name toString             * @memberof plat.web.IUrlUtilsInstance             * @kind function             * @access public             *              * @description             * A toString function implementation for the {@link plat.web.IUrlUtilsInstance|IUrlUtilsInstance}.             *              * @returns {string} The href associated with this {@link plat.web.IUrlUtilsInstance|IUrlUtilsInstance}.             */            toString(): string;        }        /**         * @name Router         * @memberof plat.web         * @kind class         *          * @implements {plat.web.IRouter}         *          * @description         * The class that handles route registration and navigation          * to and from {@link plat.ui.IViewControl|IViewControls} within the          * {@link plat.ui.controls.Routeport|Routeport}.         */        export class Router implements IRouter {            /**             * @name $Browser             * @memberof plat.web.Router             * @kind property             * @access public             *              * @type {plat.web.IBrowser}             *              * @description             * Reference to the {@link plat.web.IBrowser|IBrowser} injectable.             */            $Browser: IBrowser = acquire(__Browser);            /**             * @name $BrowserConfig             * @memberof plat.web.Router             * @kind property             * @access public             *              * @type {plat.web.IBrowserConfig}             *              * @description             * Reference to the {@link plat.web.IBrowserConfig|IBrowserConfig} injectable.             */            $BrowserConfig: IBrowserConfig = acquire(__BrowserConfig);            /**             * @name $EventManagerStatic             * @memberof plat.web.Router             * @kind property             * @access public             *              * @type {plat.events.IEventManagerStatic}             *              * @description             * Reference to the {@link plat.events.IEventManagerStatic|IEventManagerStatic} injectable.             */            $EventManagerStatic: events.IEventManagerStatic = acquire(__EventManagerStatic);            /**             * @name $NavigationEventStatic             * @memberof plat.web.Router             * @kind property             * @access public             *              * @type {plat.events.INavigationEventStatic}             *              * @description             * Reference to the {@link plat.events.INavigationEventStatic|INavigationEventStatic} injectable.             */            $NavigationEventStatic: events.INavigationEventStatic = acquire(__NavigationEventStatic);            /**             * @name $Compat             * @memberof plat.web.Router             * @kind property             * @access public             *              * @type {plat.ICompat}             *              * @description             * Reference to the {@link plat.ICompat|ICompat} injectable.             */            $Compat: ICompat = acquire(__Compat);            /**             * @name $Regex             * @memberof plat.web.Router             * @kind property             * @access public             *              * @type {plat.expressions.IRegex}             *              * @description             * Reference to the {@link plat.expressions.IRegex|IRegex} injectable.             */            $Regex: expressions.IRegex = acquire(__Regex);            /**             * @name $Window             * @memberof plat.web.Router             * @kind property             * @access public             *              * @type {Window}             *              * @description             * Reference to the Window injectable.             */            $Window: Window = acquire(__Window);            /**             * @name uid             * @memberof plat.web.Router             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * A unique string identifier.             */            uid: string;            /**             * @name _routes             * @memberof plat.web.Router             * @kind property             * @access protected             *              * @type {Array<plat.web.IRouteMatcher>}             *              * @description             * The registered routes (as {@link plat.web.IRouteMatcher|IRouteMatchers}) for matching              * on route change.             */            _routes: Array<IRouteMatcher> = [];            /**             * @name _removeListener             * @memberof plat.web.Router             * @kind property             * @access protected             *              * @type {plat.IRemoveListener}             *              * @description             * The function to stop listening to the 'urlChanged' event.             */            _removeListener: IRemoveListener;            /**             * @name _defaultRoute             * @memberof plat.web.Router             * @kind property             * @access protected             *              * @type {plat.web.IMatchedRoute}             *              * @description             * The registered default route ('') converted into an {@link plat.web.IMatchedRoute|IMatchedRoute}.              * The default route is used whenever a specified route/url is not matched.             */            _defaultRoute: IMatchedRoute;            /**             * @name _baseRoute             * @memberof plat.web.Router             * @kind property             * @access protected             *              * @type {plat.web.IMatchedRoute}             *              * @description             * The registered base route ('/') converted into an {@link plat.web.IMatchedRoute|IMatchedRoute}.              * The base route is the first route navigated to in the {@link plat.ui.controls.Routeport|Routeport} if a              * default route is not specified in its plat-options.             */            _baseRoute: IMatchedRoute;            /**             * @name __escapeRegex             * @memberof plat.web.Router             * @kind property             * @access private             *              * @type {RegExp}             *              * @description             * A regular expression for finding invalid characters in a route string.             */            private __escapeRegex = this.$Regex.escapeRouteRegex;            /**             * @name __optionalRegex             * @memberof plat.web.Router             * @kind property             * @access private             *              * @type {RegExp}             *              * @description             * A regular expression for finding optional parameters in a route string.             */            private __optionalRegex = this.$Regex.optionalRouteRegex;            /**             * @name __pathSlashRegex             * @memberof plat.web.Router             * @kind property             * @access private             *              * @type {RegExp}             *              * @description             * A regular expression for finding forward slashes at the beginning or end of              * an expression.             */            private __pathSlashRegex = /^\/|\/$/g;            /**             * @name __firstRoute             * @memberof plat.web.Router             * @kind property             * @access private             *              * @type {boolean}             *              * @description             * States whether the specified route is the first attempt at routing.             */            private __firstRoute = true;            /**             * @name __history             * @memberof plat.web.Router             * @kind property             * @access private             *              * @type {Array<string>}             *              * @description             * A virtual history stack used in IE based MS apps.             */            private __history: Array<string>;            /**             * @name constructor             * @memberof plat.web.Router             * @kind function             * @access public             *              * @description             * The constructor for a {@link plat.web.Router|Router}. Assigns a uid and subscribes to the 'urlChanged' event.             *              * @returns {plat.web.Router} A {@link plat.web.Router|Router} instance.             */            constructor() {                var ContextManager: observable.IContextManagerStatic = acquire(__ContextManagerStatic);                ContextManager.defineGetter(this, 'uid', uniqueId('plat_'));                this._removeListener = this.$EventManagerStatic.on(this.uid, 'urlChanged',                    (ev: events.IDispatchEventInstance, utils: web.IUrlUtilsInstance) => {                    postpone(() => {                        this._routeChanged(ev, utils);                    });                }, this);                var $browserConfig = this.$BrowserConfig;                if ($browserConfig.routingType === $browserConfig.NONE) {                    $browserConfig.routingType = $browserConfig.HASH;                    $browserConfig.hashPrefix = $browserConfig.hashPrefix || '';                }                if (this.$Compat.msApp) {                    this.__history = [];                }            }            /**             * @name registerRoutes             * @memberof plat.web.Router             * @kind function             * @access public             *              * @description             * Registers route strings/RegExps and associates them with a control type.             *              * @param {string} type The control type with which to associate the routes.             * @param {Array<any>} routes An array of strings or RegExp expressions to associate with              * the control type.             *              * @returns {void}             */            registerRoutes(type: string, routes: Array<any>): void {                if (!isArray(routes)) {                    return;                }                var injector = viewControlInjectors[type],                    length = routes.length;                for (var i = 0; i < length; ++i) {                    this._registerRoute(routes[i], injector, type);                }            }            /**             * @name route             * @memberof plat.web.Router             * @kind function             * @access public             *              * @description             * Formats a url path given the parameters and query string, then changes the              * url to that path.             *              * @param {string} path The route path to navigate to.             * @param {plat.web.IRouteNavigationOptions} options? The {@link plat.web.IRouteNavigationOptions|IRouteNavigationOptions}               * included with this route.             *              * @returns {boolean} Whether or not the route operation was a success.             */            route(path: string, options?: IRouteNavigationOptions): boolean {                options = options || <IRouteNavigationOptions>{};                var replace = options.replace,                    route: string,                    match: IMatchedRoute,                    $browser = this.$Browser,                    currentUtils: IUrlUtilsInstance = $browser.urlUtils();                if (this.__firstRoute) {                    this.__firstRoute = false;                    if (isEmpty(path)) {                        this._routeChanged(null, currentUtils);                        return true;                    }                }                var build = this._buildRoute(path, options.query);                if (isNull(build)) {                    var $exception: IExceptionStatic = acquire(__ExceptionStatic);                    $exception.warn('Route: ' + path + ' is not a matched route.', $exception.NAVIGATION);                    return false;                }                route = build.route;                match = build.match;                var event = this.$NavigationEventStatic.dispatch('beforeRouteChange', this, {                    parameter: match.route,                    target: match.injector,                    type: match.type,                    options: null,                    cancelable: true                });                if (event.cancelled) {                    return false;                }                var nextUtils = $browser.urlUtils(route);                if (currentUtils.href === nextUtils.href) {                    replace = true;                }                $browser.url(route, replace);                return true;            }            /**             * @name goBack             * @memberof plat.web.Router             * @kind function             * @access public             *              * @description             * Navigates back in the history.             *              * @param {number} length? The number of entries to go back in the history.             *              * @returns {void}             */            goBack(length?: number): void {                this.$Window.history.go(-length);                var history = this.__history;                if (isArray(history) && history.length > 1) {                    this.__history = history.slice(0, history.length - length);                    this.$Browser.url(this.__history.pop() || '');                }            }            /**             * @name _buildRoute             * @memberof plat.web.Router             * @kind function             * @access protected             *              * @description             * Builds a valid route with a valid query string to use for navigation.             *              * @param {string} routeParameter The route portion of the navigation path. Used to              * match with a registered {@link plat.ui.WebViewControl|WebViewControl}.             * @param {plat.IObject<string>} query The route query object if passed into the              * {@link plat.web.IRouteNavigationOptions|IRouteNavigationOptions}.             *              * @returns {{ route: string; match: plat.web.IMatchedRoute; }} An object containing              * both the fully evaluated route and the corresponding {@link plat.web.IMatchedRoute|IMatchedRoute}.             */            _buildRoute(routeParameter: string, query: IObject<string>): { route: string; match: IMatchedRoute; } {                var queryStr = this._buildQueryString(query);                if (!isString(routeParameter)) {                    return;                }                var route = routeParameter + queryStr,                    utils = this.$Browser.urlUtils(route),                    match = this._match(utils);                if (isNull(match)) {                    return;                }                return {                    route: route,                    match: match                };            }            /**             * @name _buildQueryString             * @memberof plat.web.Router             * @kind function             * @access protected             *              * @description             * Builds the query string if a query object was passed into              * the {@link plat.web.IRouteNavigationOptions|IRouteNavigationOptions}.             *              * @param {plat.IObject<string>} query The query object passed in.             *              * @returns {string} The built query string.             */            _buildQueryString(query: IObject<string>): string {                var queryStr: Array<string> = [];                if (!isObject(query)) {                    return queryStr.join();                }                var keys = Object.keys(query),                    length = keys.length,                    key: string;                for (var i = 0; i < length; ++i) {                    key = keys[i];                    queryStr.push(key + '=' + query[key]);                }                return '?' + queryStr.join('&');            }            /**             * @name _routeChanged             * @memberof plat.web.Router             * @kind function             * @access protected             *              * @description             * The method called when the route function is invoked              * or on a 'urlChanged' event.             *              * @param {plat.events.IDispatchEventInstance} ev The 'urlChanged' event object.             * @param {plat.web.IUrlUtilsInstance} utils The {@link plat.web.IUrlUtils|IUrlUtils}              * created for the invoked route function.             *              * @returns {void}             */            _routeChanged(ev: events.IDispatchEventInstance, utils: web.IUrlUtilsInstance): void {                var matchedRoute = this._match(utils);                if (isNull(matchedRoute)) {                    var $exception: IExceptionStatic = acquire(__ExceptionStatic);                    $exception.warn('Could not match route: ' + utils.pathname,                        $exception.NAVIGATION);                    return;                }                if (this.__history) {                    this.__history.push(matchedRoute.route.path);                }                this.$NavigationEventStatic.dispatch('routeChanged', this, {                    parameter: matchedRoute.route,                    target: matchedRoute.injector,                    type: matchedRoute.type,                    options: null,                    cancelable: false                });            }            /**             * @name _registerRoute             * @memberof plat.web.Router             * @kind function             * @access protected             *              * @description             * Registers a {@link plat.ui.WebViewControl|WebViewControl's} route.             *              * @param {any} route Can be either a string or RegExp.             * @param {plat.dependency.IInjector<plat.ui.IBaseViewControl>} injector The injector for the              * {@link plat.ui.WebViewControl|WebViewControl} defined by the type.             * @param {string} type The control type.             *              * @returns {void}             */            _registerRoute(route: any, injector: dependency.IInjector<ui.IBaseViewControl>, type: string): void {                var regexp = isRegExp(route),                    routeParameters: IRouteMatcher;                if (!(regexp || isString(route))) {                    return;                } else if (regexp) {                    routeParameters = {                        regex: route,                        type: type,                        injector: injector,                        args: []                    };                } else if (isEmpty(route)) {                    this._defaultRoute = {                        injector: injector,                        type: type                    };                    return;                } else if (route.trim() === '/') {                    this._baseRoute = {                        injector: injector,                        type: type                    };                    return;                } else {                    if (route[0] === '/') {                        route = (<string>route).substr(1);                    }                    routeParameters = this._getRouteParameters(route);                    routeParameters.injector = injector;                    routeParameters.type = type;                }                this._routes.push(routeParameters);            }            /**             * @name _getRouteParameters             * @memberof plat.web.Router             * @kind function             * @access protected             *              * @description             * Parses the route and pulls out route parameters. Then              * converts them to regular expressions to match for              * routing.             *              * @param {string} route The route to parse.             *              * @returns {plat.web.IRouteMatcher} The object used to match a              * route with a {@link plat.ui.BaseViewControl|BaseViewControl's} injector.             */            _getRouteParameters(route: string): IRouteMatcher {                var $regex = this.$Regex,                    namedRegex = $regex.namedParameterRouteRegex,                    escapeRegex = this.__escapeRegex,                    optionalRegex = this.__optionalRegex,                    wildcardRegex = $regex.wildcardRouteRegex,                    regexArgs = route.match(namedRegex),                    wildcard = wildcardRegex.exec(route),                    args: Array<string> = [];                route = route.replace(escapeRegex, '\\$')                    .replace(optionalRegex, '(?:$1)?')                    .replace(namedRegex, (match, optional)                        => optional ? match : '([^/?]+)')                    .replace(wildcardRegex, '([^?]*?)');                if (!isNull(regexArgs)) {                    var length = regexArgs.length;                    for (var i = 0; i < length; ++i) {                        args.push(regexArgs[i].substr(1));                    }                }                if (!isNull(wildcard)) {                    var wildCardName = wildcard[0].substr(1);                    if (isEmpty(wildCardName)) {                        wildCardName = 'wildcard';                    }                    args.push(wildCardName);                }                return {                    regex: new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$'),                    args: args                };            }            /**             * @name _match             * @memberof plat.web.Router             * @kind function             * @access protected             *              * @description             * Matches a route to a registered route using the              * registered route's regular expression.             *              * @param {plat.web.IUrlUtilsInstance} utils The utility used to obtain              * the url fragment and the url query.             *              * @returns {plat.web.IMatchedRoute} The matched route with the matched control              * injector.             */            _match(utils: web.IUrlUtilsInstance): IMatchedRoute {                var routes = this._routes,                    url = this._getUrlFragment(utils),                    route: IRouteMatcher,                    exec: RegExpExecArray,                    args: Array<string>,                    routeParams: IObject<string> = {},                    path: string,                    argsLength: number,                    length = routes.length;                if (isEmpty(url)) {                    var base = this._baseRoute || this._defaultRoute;                    if (isNull(base)) {                        return;                    }                    return {                        injector: base.injector,                        type: base.type,                        route: {                            path: url,                            parameters: {},                            query: utils.query                        }                    };                }                for (var i = 0; i < length; ++i) {                    route = routes[i];                    exec = route.regex.exec(url);                    if (isNull(exec)) {                        continue;                    }                    args = route.args;                    argsLength = args.length;                    path = exec.input;                    if (argsLength === 0) {                        args = Object.keys(exec.slice());                        exec.unshift('');                        argsLength = args.length;                    }                    for (var j = 0; j < argsLength; ++j) {                        routeParams[args[j]] = exec[j + 1];                    }                    return {                        injector: route.injector,                        type: route.type,                        route: {                            path: path,                            parameters: routeParams,                            query: utils.query                        }                    };                }                var defaultRoute = this._defaultRoute;                if (isNull(defaultRoute)) {                    return;                }                return {                    injector: defaultRoute.injector,                    type: defaultRoute.type,                    route: {                        path: url,                        parameters: {},                        query: utils.query                    }                };            }            /**             * @name _getUrlFragment             * @memberof plat.web.Router             * @kind function             * @access protected             *              * @description             * Trims the first and last slash on the URL pathname and returns it.             *              * @param {plat.web.IUrlUtilsInstance} utils The utility used to obtain              * the url fragment.             *              * @returns {string} The trimmed URL pathname.             */            _getUrlFragment(utils: web.IUrlUtilsInstance): string {                return utils.pathname.replace(this.__pathSlashRegex, '');            }        }        /**         * The Type for referencing the '$Router' injectable as a dependency.         */        export function IRouter(): IRouter {            return new Router();        }        register.injectable(__Router, IRouter);        /**         * @name IRouter         * @memberof plat.web         * @kind interface         *          * @description         * Describes the object that handles route registration and navigation          * to and from {@link plat.ui.IWebViewControl|IWebViewControls} within a          * {@link plat.ui.controls.Routeport|Routeport}.         */        export interface IRouter {            /**             * @name uid             * @memberof plat.web.IRouter             * @kind property             * @access public             *              * @type {string}             *              * @description             * A unique string identifier.             */            uid: string;            /**             * @name registerRoutes             * @memberof plat.web.IRouter             * @kind function             * @access public             *              * @description             * Registers route strings/RegExps and associates them with a control type.             *              * @param {string} type The control type with which to associate the routes.             * @param {Array<any>} routes An array of strings or RegExp expressions to associate with              * the control type.             *              * @returns {void}             */            registerRoutes(type: string, routes: Array<any>): void;            /**             * @name route             * @memberof plat.web.IRouter             * @kind function             * @access public             *              * @description             * Formats a url path given the parameters and query string, then changes the              * url to that path.             *              * @param {string} path The route path to navigate to.             * @param {plat.web.IRouteNavigationOptions} options? The {@link plat.web.IRouteNavigationOptions|IRouteNavigationOptions}               * included with this route.             *              * @returns {boolean} Whether or not the route operation was a success.             */            route(path: string, options?: web.IRouteNavigationOptions): boolean;            /**             * @name goBack             * @memberof plat.web.IRouter             * @kind function             * @access public             *              * @description             * Navigates back in the history.             *              * @param {number} length? The number of entries to go back in the history.             *              * @returns {void}             */            goBack(length?: number): void;        }        /**         * @name IRouteNavigationOptions         * @memberof plat.web         * @kind interface         *          * @extends {plat.navigation.IBaseNavigationOptions}         *          * @description         * Options that you can submit to the router in order         * to customize navigation.         */        export interface IRouteNavigationOptions extends navigation.IBaseNavigationOptions {            /**             * @name query             * @memberof plat.web.IRouteNavigationOptions             * @kind property             * @access public             *              * @type {plat.IObject<string>}             *              * @description             * An object that includes the query parameters to be inserted into the route              * as the query string.             */            query?: IObject<string>;        }        /**         * @name IRouteMatcher         * @memberof plat.web         * @kind interface         *          * @description         * Used by the navigator for matching a route with          * a {@link plat.ui.IBaseViewControl|IBaseViewControl's} injector.         */        export interface IRouteMatcher {            /**             * @name injector             * @memberof plat.web.IRouteMatcher             * @kind property             * @access public             *              * @type {plat.dependency.IInjector<plat.ui.IBaseViewControl>}             *              * @description             * The {@link plat.ui.IBaseViewControl|IBaseViewControl} injector.             */            injector?: dependency.IInjector<ui.IBaseViewControl>;            /**             * @name type             * @memberof plat.web.IRouteMatcher             * @kind property             * @access public             *              * @type {string}             *              * @description             * The type of {@link plat.ui.IBaseViewControl|IBaseViewControl}.             */            type?: string;            /**             * @name regex             * @memberof plat.web.IRouteMatcher             * @kind property             * @access public             *              * @type {RegExp}             *              * @description             * A regular expression to match with the url.             */            regex: RegExp;            /**             * @name args             * @memberof plat.web.IRouteMatcher             * @kind property             * @access public             *              * @type {Array<string>}             *              * @description             * Route arguments used to create route parameters               * in the event of a url match.             */            args: Array<string>;        }        /**         * @name IMatchedRoute         * @memberof plat.web         * @kind interface         *          * @description         * Provides a {@link plat.dependency.IInjector<plat.ui.IBaseViewControl>|IInjector<IBaseViewControl>} that matches          * the given {@link plat.web.IRoute|IRoute}.         */        export interface IMatchedRoute {            /**             * @name injector             * @memberof plat.web.IMatchedRoute             * @kind property             * @access public             *              * @type {plat.dependency.IInjector<plat.ui.IBaseViewControl>}             *              * @description             * The associated {@link plat.dependency.IInjector<plat.ui.IBaseViewControl>|IInjector<IBaseViewControl>} for the route.             */            injector: dependency.IInjector<ui.IBaseViewControl>;            /**             * @name type             * @memberof plat.web.IMatchedRoute             * @kind property             * @access public             *              * @type {string}             *              * @description             * The type of {@link plat.ui.IBaseViewControl|IBaseViewControl}.             */            type: string;            /**             * @name route             * @memberof plat.web.IMatchedRoute             * @kind property             * @access public             *              * @type {plat.web.IRoute<any>}             *              * @description             * The route associated with this object's injector.             */            route?: IRoute<any>;        }        /**         * @name IRoute         * @memberof plat.web         * @kind interface         *          * @typeparam {{}} T The type of the defined parameters matched with this route.         *          * @description         * Contains the parsed properties of a url.         */        export interface IRoute<T extends {}> {            /**             * @name parameters             * @memberof plat.web.IRoute             * @kind property             * @access public             *              * @type {T}             *              * @description             * The defined parameters that were matched with the route.              * When a route is registered, the registrant can specify named              * route parameters. Those parameters will appear in this object              * as key/value pairs.             */            parameters: T;            /**             * @name path             * @memberof plat.web.IRoute             * @kind property             * @access public             *              * @type {string}             *              * @description             * This property will always exist and will be equal to the full             * route for navigation (only the path from root, not including              * the query string).             */            path: string;            /**             * @name query             * @memberof plat.web.IRoute             * @kind property             * @access public             *              * @type {string}             *              * @description             * An object containing query string key/value pairs.             */            query?: any;        }    }        /**     * @name async     * @memberof plat     * @kind namespace     *      * @description     * Holds all the async members.     */    export module async {        /**         * @name Promise         * @memberof plat.async         * @kind class         *          * @implements {plat.async.IThenable}         *          * @description         * Takes in a generic type corresponding to the fullfilled success type.          *          * @typeparam {any} R The return type of the promise.         */        export class Promise<R> implements IThenable<R> {            /**             * @name __subscribers             * @memberof plat.async.Promise             * @kind property             * @access private             *              * @type {Array<any>}             *              * @description             * Holds all the subscriber promises             */            private __subscribers: Array<any>;            /**             * @name __state             * @memberof plat.async.Promise             * @kind property             * @access private             *              * @type {plat.async.State}             *              * @description             * The state of the promise (fulfilled/rejected)             */            private __state: State;            /**             * @name __detail             * @memberof plat.async.Promise             * @kind property             * @access private             *              * @type {any}             *              * @description             * The return detail of a promise.             */            private __detail: any;            /**             * @name config             * @memberof plat.async.Promise             * @kind property             * @access public             * @static             *              * @type {any}             *              * @description             * The configuration for creating asynchronous promise flushing.             */            static config = {                /**                 * Handles asynchronous flushing of callbacks. If the callback queue is of                  * length 1, then we need to schedule a flush. Afterward, any additional                  * callbacks added to the queue will be flushed accordingly.                 */                async: (callback: (arg?: IThenable<any>) => void, arg?: IThenable<any>) => {                    var length = queue.push([callback, arg]);                    if (length === 1) {                        scheduleFlush();                    }                }            };            /**             * @name all             * @memberof plat.async.Promise             * @kind function             * @access public             * @static             * @variation 0             *              * @description             * Returns a promise that fulfills when every item in the array is fulfilled.             * Casts arguments to promises if necessary. The result argument of the              * returned promise is an array containing the fulfillment result arguments              * in-order. The rejection argument is the rejection argument of the              * first-rejected promise.             *              * @typeparam {any} R The return type of the promises.             *              * @param {Array<plat.async.IThenable<R>>} promises An array of promises, although every argument is potentially             * cast to a promise meaning not every item in the array needs to be a promise.             *              * @returns {plat.async.IThenable<Array<R>>} A promise that resolves after all the input promises resolve.             */            static all<R>(promises: Array<IThenable<R>>): IThenable<Array<R>>;            /**             * @name all             * @memberof plat.async.Promise             * @kind function             * @access public             * @static             * @variation 1             *              * @description             * Returns a promise that fulfills when every item in the array is fulfilled.             * Casts arguments to promises if necessary. The result argument of the              * returned promise is an array containing the fulfillment result arguments              * in-order. The rejection argument is the rejection argument of the              * first-rejected promise.             *              * @typeparam {any} R The type of the promises.             *              * @param {Array<R>} promises An array of objects, if an object is not a promise, it will be cast.             *              * @returns {plat.async.IThenable<Array<R>>} A promise that resolves after all the input promises resolve.             */            static all<R>(promises: Array<R>): IThenable<Array<R>>;            static all(promises: Array<any>): IThenable<Array<any>> {                if (!isArray(promises)) {                    return Promise.all([promises]);                }                return new Promise<Array<any>>((resolve: (value?: Array<any>) => void, reject: (reason?: any) => void) => {                    var results: Array<any> = [],                        remaining = promises.length,                        promise: Promise<any>;                    if (remaining === 0) {                        resolve(<any>[]);                    }                    function resolver(index: number) {                        return (value: any) => resolveAll(index, value);                    }                    function resolveAll(index: number, value: any) {                        results[index] = value;                        if (--remaining === 0) {                            resolve(<any>results);                        }                    }                    for (var i = 0; i < promises.length; i++) {                        promise = promises[i];                        if (isPromise(promise)) {                            promise.then(resolver(i), reject);                        } else {                            resolveAll(i, promise);                        }                    }                });            }            /**             * @name cast             * @memberof plat.async.Promise             * @kind function             * @access public             * @static             *              * @description             * Creates a promise that fulfills to the passed in object. If the             * passed-in object is a promise it returns the promise.             *              * @typeparam {any} R The type of the input object to cast to a promise.             *              * @param object The object to cast to a Promise.             */            static cast<R>(object?: R): Promise<R> {                if (isObject(object) && (<any>object).constructor === Promise) {                    return <Promise<R>>(<any>object);                }                return new Promise<R>((resolve: (value: R) => any) => resolve(object));            }            /**             * @name race             * @memberof plat.async.Promise             * @kind function             * @access public             * @static             * @variation 0             *              * @description             * Returns a promise that fulfills as soon as any of the promises fulfill,             * or rejects as soon as any of the promises reject (whichever happens first).             *              * @typeparam {any} R The return type of the input promises.             *              * @param {Array<plat.async.IThenable<R>>} promises An Array of promises to 'race'.             *              * @returns {plat.async.IThenable<R>} A promise that fulfills when one of the input              * promises fulfilled.             */            static race<R>(promises: Array<IThenable<R>>): IThenable<R>;            /**             * @name race             * @memberof plat.async.Promise             * @kind function             * @access public             * @static             * @variation 1             *              * @description             * Returns a promise that fulfills as soon as any of the promises fulfill,             * or rejects as soon as any of the promises reject (whichever happens first).             *              * @typeparam {any} R The type of the input objects.             *              * @param {Array<R>} promises An Array of anything to 'race'. Objects that aren't promises will             * be cast.             *              * @returns {plat.async.IThenable<R>} A promise that fulfills when one of the input              * promises fulfilled.             */            static race<R>(promises: Array<R>): IThenable<R>;            static race(promises: Array<any>): IThenable<any> {                if (!isArray(promises)) {                    return Promise.race([promises]);                }                return new Promise<any>((resolve: (value: any) => any, reject: (error: any) => any) => {                    var promise: Promise<any>;                    for (var i = 0; i < promises.length; i++) {                        promise = promises[i];                        if (promise && typeof promise.then === 'function') {                            promise.then(resolve, reject);                        } else {                            resolve(<any>promise);                        }                    }                });            }            /**             * @name resolve             * @memberof plat.async.Promise             * @kind function             * @access public             * @static             *              * @description             * Returns a promise that resolves with the input value.             *              * @typeparam {any} R The value with which to resolve the promise.             *              * @param {R} value The value to resolve.             *              * @returns {plat.async.IThenable<R>} A promise that will resolve with the associated value.             */            static resolve<R>(value?: R): IThenable<R> {                return new Promise<R>((resolve: (value: R) => any, reject: (reason: any) => any) => {                    resolve(value);                });            }            /**             * @name reject             * @memberof plat.async.Promise             * @kind function             * @access public             * @static             *              * @description             * Returns a promise that rejects with the input value.             *              * @param {any} error The value to reject.             *              * @returns {plat.async.IThenable<any>} A promise that will reject with the error.             */            static reject(error?: any): IThenable<any> {                return new Promise<any>((resolve: (value: any) => any, reject: (error: any) => any) => {                    reject(error);                });            }            /**             * @name __invokeResolveFunction             * @memberof plat.async.Promise             * @kind function             * @access private             * @static             *              * @description             * Invokes the resolve function for a promise. Handles error catching.             *              * @typeparam {any} R The return type of the input {@link plat.async.Promise|Promise}.             *              * @param {plat.async.IResolveFunction<R>} resolveFunction The resolve function to invoke.             * @param {plat.async.Promise<R>} promise The promise on which to invoke the resolve function.             *              * @returns {void}             */            private static __invokeResolveFunction<R>(resolveFunction: IResolveFunction<R>,                promise: Promise<R>): void {                function resolvePromise(value?: any) {                    Promise.__resolve<R>(promise, value);                }                function rejectPromise(reason?: any) {                    Promise.__reject(promise, reason);                }                try {                    resolveFunction(resolvePromise, rejectPromise);                } catch (e) {                    rejectPromise(e);                }            }            /**             * @name __invokeCallback             * @memberof plat.async.Promise             * @kind function             * @access private             * @static             *              * @description             * Invokes a callback for a promise with the specified detail.             *              * @param {plat.async.State} settled The state of the promise.             * @param {any} promise The promise object.             * @param {(response: any) => void} callback The callback to invoke.             * @param {any} detail The details to pass to the callback.             *              * @returns {void}             */            private static __invokeCallback(settled: State, promise: any, callback: (response: any) => void, detail: any): void {                var hasCallback = isFunction(callback),                    value: any,                    error: Error,                    succeeded: boolean,                    failed: boolean;                if (hasCallback) {                    try {                        value = callback(detail);                        succeeded = true;                    } catch (e) {                        failed = true;                        error = e;                    }                } else {                    value = detail;                    succeeded = true;                }                if (Promise.__handleThenable<any>(promise, value)) {                    return;                } else if (hasCallback && succeeded) {                    Promise.__resolve<any>(promise, value);                } else if (failed) {                    Promise.__reject(promise, error);                } else if (settled === State.FULFILLED) {                    Promise.__resolve<any>(promise, value);                } else if (settled === State.REJECTED) {                    Promise.__reject(promise, value);                }            }            /**             * @name __publish             * @memberof plat.async.Promise             * @kind function             * @access private             * @static             *              * @description             * Publishes the promise details to all the subscribers for a promise.             *              * @param {any} promise The promise object.             * @param {plat.async.State} settled The state of the promise.             *              * @returns {void}             */            private static __publish(promise: Promise<any>, settled: State): void {                var subscribers = promise.__subscribers,                    detail = promise.__detail,                    child: any,                    callback: () => void;                for (var i = 0; i < subscribers.length; i += 3) {                    child = subscribers[i];                    callback = subscribers[i + settled];                    Promise.__invokeCallback(settled, child, callback, detail);                }                promise.__subscribers = null;            }            /**             * @name __publishFulfillment             * @memberof plat.async.Promise             * @kind function             * @access private             * @static             *              * @description             * Publishes a promises that has been fulfilled.             *              * @param {any} promise The promise object.             *              * @returns {void}             */            private static __publishFulfillment(promise: any): void {                Promise.__publish(promise, promise.__state = State.FULFILLED);            }            /**             * @name __publishRejection             * @memberof plat.async.Promise             * @kind function             * @access private             * @static             *              * @description             * Publishes a promises that has been rejected.             *              * @param {any} promise The promise object.             *              * @returns {void}             */            private static __publishRejection(promise: any): void {                Promise.__publish(promise, promise.__state = State.REJECTED);            }            /**             * @name __reject             * @memberof plat.async.Promise             * @kind function             * @access private             * @static             *              * @description             * Asynchronously rejects a promise             *              * @param {any} promise The promise object.             * @param {any} reason The detail of the rejected promise.             *              * @returns {void}             */            private static __reject(promise: any, reason: any): void {                if (promise.__state !== State.PENDING) {                    return;                }                promise.__state = State.SEALED;                promise.__detail = reason;                Promise.config.async(Promise.__publishRejection, promise);            }            /**             * @name __fulfill             * @memberof plat.async.Promise             * @kind function             * @access private             * @static             *              * @description             * Asynchronously fulfills a promise             *              * @typeparam {any} R The return type of the promise.             *              * @param {plat.async.Promise<R>} promise The promise object.             * @param {any} value The detail of the fulfilled promise.             *              * @returns {void}             */            private static __fulfill<R>(promise: Promise<R>, value: any): void {                if (promise.__state !== State.PENDING) {                    return;                }                promise.__state = State.SEALED;                promise.__detail = value;                Promise.config.async(Promise.__publishFulfillment, promise);            }            /**             * @name __resolve             * @memberof plat.async.Promise             * @kind function             * @access private             * @static             *              * @description             * Asynchronously fulfills a promise, allowing for promise chaining.             *              * @typeparam {any} R The return type of the promise.             *              * @param {plat.async.Promise<R>} promise The promise object.             * @param {any} value The detail of the fulfilled promise.             *              * @returns {void}             */            private static __resolve<R>(promise: Promise<R>, value: any): void {                if (promise === value) {                    Promise.__fulfill(promise, value);                } else if (!Promise.__handleThenable<R>(promise, value)) {                    Promise.__fulfill(promise, value);                }            }            /**             * @name __handleThenable             * @memberof plat.async.Promise             * @kind function             * @access private             * @static             *              * @description             * Handles chaining promises together, when a promise is returned from within a then handler.             *              * @typeparam {any} R The return type of the promise.             *              * @param {plat.async.Promise<R>} promise The promise object.             * @param {plat.async.Promise<R>} value The next promise to await.             *              * @returns {boolean} Whether or not the value passed in is a promise.             */            private static __handleThenable<R>(promise: Promise<R>, value: Promise<R>): boolean {                var resolved: boolean;                try {                    if (promise === value) {                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);                        $exception.fatal(new TypeError('A promises callback cannot return the same promise.'),                            $exception.PROMISE);                    }                    if (isPromise(value)) {                        value.then.call(value, (val: any) => {                            if (resolved) {                                return true;                            }                            resolved = true;                            if (value !== val) {                                Promise.__resolve<R>(promise, val);                            } else {                                Promise.__fulfill<R>(promise, val);                            }                        }, (val: any) => {                            if (resolved) {                                return true;                            }                            resolved = true;                            Promise.__reject(promise, val);                        });                        return true;                    }                } catch (error) {                    if (resolved) {                        return true;                    }                    Promise.__reject(promise, error);                    return true;                }                return false;            }            /**             * @name __subscribe             * @memberof plat.async.Promise             * @kind function             * @access private             * @static             *              * @description             * Adds a child promise to the parent's subscribers.             *              * @typeparam {any} R The return type of the promise.             *              * @param {plat.async.Promise<any>} parent The parent promise.             * @param {plat.async.Promise<any>} value The child promise.             * @param {(success: any) => any} onFullfilled The fulfilled method for the child.             * @param {(error: any) => any} onRejected The rejected method for the child.             *              * @returns {void}             */            private static __subscribe(parent: Promise<any>, child: IThenable<any>,                onFulfilled: (success: any) => any, onRejected: (error: any) => any): void {                var subscribers = parent.__subscribers;                var length = subscribers.length;                subscribers[length] = child;                subscribers[length + State.FULFILLED] = onFulfilled;                subscribers[length + State.REJECTED] = onRejected;            }            /**             * @name constructor             * @memberof plat.async.Promise             * @kind function             * @access public             *              * @description             * An ES6 implementation of the Promise API. Useful for asynchronous programming.             * Takes in 2 generic types corresponding to the fullfilled success and error types.              * The error type (U) should extend Error in order to get proper stack tracing.             *              * @typeparam {any} R The return type of the promise.             *              * @param {plat.async.IResolveFunction<R>} resolveFunction A IResolveFunction for fulfilling/rejecting the Promise.             *              * @returns {plat.async.Promise<R>} A promise object.             */            constructor(resolveFunction: IResolveFunction<R>) {                var $exception: IExceptionStatic;                if (!isFunction(resolveFunction)) {                    $exception = acquire(__ExceptionStatic);                    $exception.fatal(new TypeError('You must pass a resolver function as the first argument to the promise constructor'),                        $exception.PROMISE);                }                if (!(this instanceof Promise)) {                    $exception = acquire(__ExceptionStatic);                    $exception.fatal(new TypeError('Failed to construct "Promise": ' +                        'Please use the "new" operator, this object constructor cannot be called as a function.'),                        $exception.PROMISE);                }                this.__subscribers = [];                Promise.__invokeResolveFunction<R>(resolveFunction, this);            }            /**             * @name then             * @memberof plat.async.Promise             * @kind function             * @access public             * @variation 0             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The return type of the returned promise.             *              * @param {(success: R) => plat.async.IThenable<U>} onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             * @param {(error: any) => plat.async.IThenable<U>} onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             *              * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.             */            then<U>(onFulfilled: (success: R) => IThenable<U>, onRejected?: (error: any) => IThenable<U>): IThenable<U>;            /**             * @name then             * @memberof plat.async.Promise             * @kind function             * @access public             * @variation 1             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The return type of the returned promise.             *              * @param {(success: R) => plat.async.IThenable<U>} onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             * @param {(error: any) => U} onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             *              * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.             */            then<U>(onFulfilled: (success: R) => IThenable<U>, onRejected?: (error: any) => U): IThenable<U>;            /**             * @name then             * @memberof plat.async.Promise             * @kind function             * @access public             * @variation 2             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The return type of the returned promise.             *              * @param {(success: R) => U} onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             * @param {(error: any) => plat.async.IThenable<U>} onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             *              * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.             */            then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => IThenable<U>): IThenable<U>;            /**             * @name then             * @memberof plat.async.Promise             * @kind function             * @access public             * @variation 3             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The return type of the returned promise.             *              * @param {(success: R) => U} onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             * @param {(error: any) => U} onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             *              * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.             */            then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => U): IThenable<U>;            then<U>(onFulfilled: (success: R) => any, onRejected?: (error: any) => any): IThenable<U> {                var promise = this;                var thenPromise = <IThenable<U>>new (<any>this).constructor(() => { }, this);                if (this.__state) {                    var callbacks = arguments;                    Promise.config.async(() => {                        Promise.__invokeCallback(promise.__state, thenPromise, callbacks[promise.__state - 1], promise.__detail);                    });                } else {                    Promise.__subscribe(this, thenPromise, onFulfilled, onRejected);                }                return thenPromise;            }            /**             * @name catch             * @memberof plat.async.Promise             * @kind function             * @access public             * @variation 0             *              * @description             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}             *              * @typeparam {any} U The return type of the returned promise.             *              * @param {(error: any) => plat.async.IThenable<U>} onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             *              * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.             */            catch<U>(onRejected: (error: any) => IThenable<U>): IThenable<U>;            /**             * @name catch             * @memberof plat.async.Promise             * @kind function             * @access public             * @variation 1             *              * @description             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}             *              * @typeparam {any} U The return type of the returned promise.             *              * @param {(error: any) => U} onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             *              * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.             */            catch<U>(onRejected: (error: any) => U): IThenable<U>;            catch<U>(onRejected: (error: any) => any): IThenable<U> {                return this.then(null, onRejected);            }            /**             * @name toString             * @memberof plat.async.Promise             * @kind function             * @access public             *              * @description             * Outputs the Promise as a readable string.             */            toString() {                return '[object Promise]';            }        }        /**         * @name IThenable         * @memberof plat.async         * @kind interface         *          * @description         * Describes a chaining function that fulfills when the previous link is complete and is          * able to be caught in the case of an error.         *          * @typeparam {any} R The return type of the thenable.         */        export interface IThenable<R> {            /**             * @name then             * @memberof plat.async.IThenable             * @kind function             * @access public             * @variation 0             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The return type of the returned promise.             *              * @param {(success: R) => plat.async.IThenable<U>} onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             * @param {(error: any) => plat.async.IThenable<U>} onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             *              * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.             */            then<U>(onFulfilled: (success: R) => IThenable<U>, onRejected?: (error: any) => IThenable<U>): IThenable<U>;            /**             * @name then             * @memberof plat.async.IThenable             * @kind function             * @access public             * @variation 1             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The return type of the returned promise.             *              * @param {(success: R) => plat.async.IThenable<U>} onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             * @param {(error: any) => U} onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             *              * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.             */            then<U>(onFulfilled: (success: R) => IThenable<U>, onRejected?: (error: any) => U): IThenable<U>;            /**             * @name then             * @memberof plat.async.IThenable             * @kind function             * @access public             * @variation 2             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The return type of the returned promise.             *              * @param {(success: R) => U} onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             * @param {(error: any) => plat.async.IThenable<U>} onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             *              * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.             */            then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => IThenable<U>): IThenable<U>;            /**             * @name then             * @memberof plat.async.IThenable             * @kind function             * @access public             * @variation 3             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The return type of the returned promise.             *              * @param {(success: R) => U} onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             * @param {(error: any) => U} onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             *              * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.             */            then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => U): IThenable<U>;            /**             * @name catch             * @memberof plat.async.IThenable             * @kind function             * @access public             * @variation 0             *              * @description             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}             *              * @typeparam {any} U The return type of the returned promise.             *              * @param {(error: any) => plat.async.IThenable<U>} onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             *              * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.             */            catch<U>(onRejected: (error: any) => IThenable<U>): IThenable<U>;            /**             * @name catch             * @memberof plat.async.IThenable             * @kind function             * @access public             * @variation 1             *              * @description             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}             *              * @typeparam {any} U The return type of the returned promise.             *              * @param {(error: any) => U} onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             *              * @returns {plat.async.IThenable<U>} A promise that resolves with the input type parameter U.             */            catch<U>(onRejected: (error: any) => U): IThenable<U>;        }        enum State {            PENDING = <any>(void 0),            SEALED = 0,            FULFILLED = 1,            REJECTED = 2        };        var browserGlobal: any = (typeof window !== 'undefined') ? window : {},            BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;        // node        function useNextTick(): () => void {            return () => {                process.nextTick(flush);            };        }        function useMutationObserver(): () => void {            var observer = new BrowserMutationObserver(flush),                $document = acquire(__Document),                $window = acquire(__Window),                element = $document.createElement('div');            observer.observe(element, { attributes: true });            $window.addEventListener('unload', () => {                observer.disconnect();                observer = null;            }, false);            return () => {                element.setAttribute('drainQueue', 'drainQueue');            };        }        function useSetTimeout(): () => void {            var global: any = global,                local = (typeof global !== 'undefined') ? global : this;            return () => {                local.setTimeout(flush, 1);            };        }        var queue: Array<any> = [];        function flush(): void {            var tuple: Array<(response: any) => void>,                callback: (response: any) => void,                arg: any;            for (var i = 0; i < queue.length; i++) {                tuple = queue[i];                callback = tuple[0];                arg = tuple[1];                callback(arg);            }            queue = [];        }        var process: any = process,            scheduleFlush: () => void;        // decide what async method to use to triggering processing of queued callbacks:        if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {            scheduleFlush = useNextTick();        } else if (BrowserMutationObserver) {            scheduleFlush = useMutationObserver();        } else {            scheduleFlush = useSetTimeout();        }        /**         * Describes a function passed into the constructor for a Promise. The function allows you to         * resolve/reject the Promise.         */        export interface IResolveFunction<R> {            /**             * A function which allows you to resolve/reject a Promise.             *              * @param resolve A method for resolving a Promise. If you pass in a 'thenable' argument              * (meaning if you pass in a Promise-like object), then the promise will resolve with the              * outcome of the object. Else the promise will resolve with the argument.             * @param reject A method for rejecting a promise. The argument should be an instancof Error             * to assist with debugging. If a method in the constructor for a Promise throws an error,              * the promise will reject with the error.             */            (resolve: (value?: R) => void, reject: (reason?: any) => void): void;        }        /**         * The Type for referencing the '$Promise' injectable as a dependency.         */        export function IPromise($Window?: any): IPromise {            if (!isNull($Window.Promise) &&                isFunction($Window.Promise.all) &&                isFunction($Window.Promise.cast) &&                isFunction($Window.Promise.race) &&                isFunction($Window.Promise.resolve) &&                isFunction($Window.Promise.reject)) {                return $Window.Promise;            }            return Promise;        }        register.injectable(__Promise, IPromise, [__Window], __CLASS);        /**         * @name IPromise         * @memberof plat.async         * @kind interface         *          * @description         * The injectable reference for the ES6 Promise implementation.         */        export interface IPromise {            /**             * @name constructor             * @memberof plat.async.IPromise             * @kind function             * @access public             *              * @description             * An ES6 implementation of the Promise API. Useful for asynchronous programming.             * Takes in 2 generic types corresponding to the fullfilled success and error types.              * The error type (U) should extend Error in order to get proper stack tracing.             *              * @typeparam {any} R The return type of the promise.             *              * @param {plat.async.IResolveFunction<R>} resolveFunction A IResolveFunction for fulfilling/rejecting the Promise.             *              * @returns {plat.async.IThenable<R>} A promise object.             */            new <R>(resolveFunction: IResolveFunction<R>): IThenable<R>;            /**             * @name all             * @memberof plat.async.IPromise             * @kind function             * @access public             * @static             * @variation 0             *              * @description             * Returns a promise that fulfills when every item in the array is fulfilled.             * Casts arguments to promises if necessary. The result argument of the             * returned promise is an array containing the fulfillment result arguments             * in-order. The rejection argument is the rejection argument of the             * first-rejected promise.             *              * @typeparam {any} R The return type of the promises.             *              * @param {Array<plat.async.IThenable<R>>} promises An array of promises, although every argument is potentially             * cast to a promise meaning not every item in the array needs to be a promise.             *              * @returns {plat.async.IThenable<Array<R>>} A promise that resolves after all the input promises resolve.             */            all<R>(promises: Array<IThenable<R>>): IThenable<Array<R>>;            /**             * @name all             * @memberof plat.async.IPromise             * @kind function             * @access public             * @static             * @variation 1             *              * @description             * Returns a promise that fulfills when every item in the array is fulfilled.             * Casts arguments to promises if necessary. The result argument of the              * returned promise is an array containing the fulfillment result arguments              * in-order. The rejection argument is the rejection argument of the              * first-rejected promise.             *              * @typeparam {any} R The type of the promises.             *              * @param {Array<R>} promises An array of objects, if an object is not a promise, it will be cast.             *              * @returns {plat.async.IThenable<Array<R>>} A promise that resolves after all the input promises resolve.             */            all<R>(promises: Array<R>): IThenable<Array<R>>;            /**             * @name cast             * @memberof plat.async.IPromise             * @kind function             * @access public             * @static             *              * @description             * Creates a promise that fulfills to the passed in object. If the             * passed-in object is a promise it returns the promise.             *              * @typeparam {any} R The type of the input object to cast to a promise.             *              * @param {R} object The object to cast to a Promise.             *              * @returns {plat.async.IThenable<R>} The cast promise.             */            cast<R>(object?: R): IThenable<R>;            /**             * @name race             * @memberof plat.async.IPromise             * @kind function             * @access public             * @static             * @variation 0             *              * @description             * Returns a promise that fulfills as soon as any of the promises fulfill,             * or rejects as soon as any of the promises reject (whichever happens first).             *              * @typeparam {any} R The return type of the input promises.             *              * @param {Array<plat.async.IThenable<R>>} promises An Array of promises to 'race'.             *              * @returns {plat.async.IThenable<R>} A promise that fulfills when one of the input              * promises fulfilled.             */            race<R>(promises: Array<IThenable<R>>): IThenable<R>;            /**             * @name race             * @memberof plat.async.IPromise             * @kind function             * @access public             * @static             * @variation 1             *              * @description             * Returns a promise that fulfills as soon as any of the promises fulfill,             * or rejects as soon as any of the promises reject (whichever happens first).             *              * @typeparam {any} R The type of the input objects.             *              * @param {Array<R>} promises An Array of anything to 'race'. Objects that aren't promises will             * be cast.             *              * @returns {plat.async.IThenable<R>} A promise that fulfills when one of the input              * promises fulfilled.             */            race<R>(promises: Array<R>): IThenable<R>;            /**             * @name resolve             * @memberof plat.async.IPromise             * @kind function             * @access public             * @static             *              * @description             * Returns a promise that resolves with the input value.             *              * @typeparam {any} R The value with which to resolve the promise.             *              * @param {R} value The value to resolve.             *              * @returns {plat.async.IThenable<R>} A promise that will resolve with the associated value.             */            resolve<R>(value: R): IThenable<R>;            /**             * @name reject             * @memberof plat.async.IPromise             * @kind function             * @access public             * @static             *              * @description             * Returns a promise that rejects with the input value.             *              * @param {any} value The value to reject.             *              * @returns {plat.async.IThenable<any>} A promise that will reject with the error.             */            reject(error: any): IThenable<any>;        }        /**         * @name HttpRequest         * @memberof plat.async         * @kind class         * @exported false         *          * @implements {plat.async.IHttpRequest}         *          * @description         * HttpRequest provides a wrapper for the XMLHttpRequest object. Allows for         * sending AJAX requests to a server. This class does not support          * synchronous requests.         */        class HttpRequest implements IHttpRequest {            /**             * @name clearTimeout             * @memberof plat.async.HttpRequest             * @kind property             * @access public             *              * @type {plat.IRemoveListener}             *              * @description             * The timeout ID associated with the specified timeout             */            clearTimeout: plat.IRemoveListener;            /**             * @name xhr             * @memberof plat.async.HttpRequest             * @kind property             * @access public             *              * @type {XMLHttpRequest}             *              * @description             * The created XMLHttpRequest             */            xhr: XMLHttpRequest;            /**             * @name jsonpCallback             * @memberof plat.async.HttpRequest             * @kind property             * @access public             *              * @type {string}             *              * @description             * The JSONP callback name             */            jsonpCallback: string;            /**             * @name $Browser             * @memberof plat.async.HttpRequest             * @kind property             * @access public             *              * @type {web.IBrowser}             *              * @description             * The plat.IBrowser injectable instance             */            $Browser: web.IBrowser = acquire(__Browser);            /**             * @name $Window             * @memberof plat.async.HttpRequest             * @kind property             * @access public             *              * @type {Window}             *              * @description             * The injectable instance of type Window             */            $Window: Window = acquire(__Window);            /**             * @name $Document             * @memberof plat.async.HttpRequest             * @kind property             * @access public             *              * @type {Document}             *              * @description             * The injectable instance of type Document             */            $Document: Document = acquire(__Document);            /**             * @name $config             * @memberof plat.async.HttpRequest             * @kind property             * @access public             *              * @type {plat.async.IHttpConfig}             *              * @description             * The configuration for an HTTP Request             */            $config: IHttpConfig = acquire(__HttpConfig);            /**             * @name __fileSupported             * @memberof plat.async.HttpRequest             * @kind property             * @access private             *              * @type {boolean}             *              * @description             * Whether or not the browser supports the File API.             */            private __fileSupported = (<ICompat>acquire(__Compat)).fileSupported;            /**             * @name __options             * @memberof plat.async.HttpRequest             * @kind property             * @access public             *              * @type {plat.async.IHttpConfig}             *              * @description             * The configuration for the specific HTTP Request             */            private __options: IHttpConfig;            /**             * @name constructor             * @memberof plat.async.HttpRequest             * @kind function             * @access public             *              * @description             * The constructor for a {@link plat.async.HttpRequest|HttpRequest}.             *              * @param {plat.async.IHttpConfig} options The IHttpConfigStatic used to customize this HttpRequest.             *              * @returns {plat.async.HttpRequest}             */            constructor(options: IHttpConfig) {                this.__options = extend({}, this.$config, options);            }            /**             * @name execute             * @memberof plat.async.HttpRequest             * @kind function             * @access public             *              * @description             * Executes an XMLHttpRequest and resolves an {@link plat.async.IAjaxPromise|IAjaxPromise} upon completion.             *              * @typeparam {any} R The response type for the XMLHttpRequest object.             *              * @returns {plat.async.IAjaxPromise} A promise that fulfills when the XMLHttpRequest is done.              */            execute<R>(): IAjaxPromise<R> {                var options = this.__options,                    url = options.url;                if (!isString(url) || isEmpty(url.trim())) {                    return this._invalidOptions();                }                options.url = this.$Browser.urlUtils(url).toString();                var isCrossDomain = options.isCrossDomain || false,                    xDomain = false;                // check if forced cross domain call or cors is not supported (IE9)                if (isCrossDomain) {                    xDomain = true;                } else {                    this.xhr = new XMLHttpRequest();                    if (isUndefined(this.xhr.withCredentials)) {                        xDomain = this.$Browser.isCrossDomain(url);                    }                }                if (xDomain) {                    this.xhr = null;                    this.jsonpCallback = options.jsonpCallback || uniqueId('plat_callback');                    return this.executeJsonp();                }                return this._sendXhrRequest();            }            /**             * @name executeJsonp             * @memberof plat.async.HttpRequest             * @kind function             * @access public             *              * @description             * Executes an JSONP request and resolves an {@link plat.async.IAjaxPromise|IAjaxPromise} upon completion.             *              * @typeparam {any} R The response type for the JSONP callback parameter.             *              * @returns {plat.async.IAjaxPromise} A promise that fulfills when the JSONP request is done.              */            executeJsonp<R>(): IAjaxPromise<R> {                var options = this.__options,                    url = options.url;                if (!isString(url) || isEmpty(url.trim())) {                    return this._invalidOptions();                }                options.url = this.$Browser.urlUtils(url).toString();                if (isNull(this.jsonpCallback)) {                    this.jsonpCallback = options.jsonpCallback || uniqueId('plat_callback');                }                return new AjaxPromise((resolve, reject) => {                    var $window = <any>this.$Window,                        $document = this.$Document,                        scriptTag = $document.createElement('script'),                        jsonpCallback = this.jsonpCallback,                        jsonpIdentifier = options.jsonpIdentifier || 'callback';                    scriptTag.src = url + '?' + jsonpIdentifier + '=' + jsonpCallback;                    var oldValue = $window[jsonpCallback];                    $window[jsonpCallback] = (response: any) => {                        // clean up                        if (isFunction(this.clearTimeout)) {                            this.clearTimeout();                        }                        $document.head.removeChild(scriptTag);                        if (!isUndefined(oldValue)) {                            $window[jsonpCallback] = oldValue;                        } else {                            deleteProperty($window, jsonpCallback);                        }                        // call callback                        resolve({                            response: response,                            // ok                            status: 200                        });                    };                    $document.head.appendChild(scriptTag);                    var timeout = options.timeout;                    if (isNumber(timeout) && timeout > 0) {                        // we first postpone to avoid always timing out when debugging, though this is not                        // a foolproof method.                        this.clearTimeout = postpone(() => {                            this.clearTimeout = defer(() => {                                reject(new AjaxError({                                    response: 'Request timed out in ' + timeout + 'ms for ' + url,                                    // request timeout                                    status: 408                                }));                                $window[jsonpCallback] = noop;                            }, timeout - 1);                        });                    }                }, { __http: this });            }            /**             * @name _xhrOnReadyStateChange             * @memberof plat.async.HttpRequest             * @kind function             * @access protected             *              * @description             * A wrapper for the XMLHttpRequest's onReadyStateChanged callback.             *              * @returns {boolean} Waits for the readyState to be complete and then              * return true in the case of a success and false in the case of              * an error.             */            _xhrOnReadyStateChange(): boolean {                var xhr = this.xhr;                if (xhr.readyState === 4) {                    var status = xhr.status;                    if (status === 0) {                        var response = xhr.response;                        if (isNull(response)) {                            try {                                response = xhr.responseText;                            } catch (e) { }                        }                        // file protocol issue **Needs to be tested more thoroughly**                        // ok if response is not empty, Not Found otherwise                        if (!isEmpty(response)) {                            return true;                        }                        return false;                    }                    // 304 is not modified                    if ((status >= 200 && status < 300) || status === 304) {                        return true;                    } else {                        return false;                    }                }                // else {} TODO: add progress for xhr if we choose to add progress to AjaxPromise            }            /**             * @name _sendXhrRequest             * @memberof plat.async.HttpRequest             * @kind function             * @access protected             *              * @description             * The function that initializes and sends the XMLHttpRequest.             *              * @returns {plat.async.IAjaxPromise} A promise that fulfills with the              * formatted {@link plat.async.IAjaxResponse|IAjaxResponse} and rejects if there is a problem with an              * {@link plat.async.IAjaxError|IAjaxError}.             */            _sendXhrRequest(): IAjaxPromise<any> {                var xhr = this.xhr,                    options = this.__options,                    method = options.method,                    url = options.url;                return new AjaxPromise((resolve, reject) => {                    xhr.onreadystatechange = () => {                        var success = this._xhrOnReadyStateChange();                        if (isNull(success)) {                            return;                        }                        var response = this._formatResponse(options.responseType, success);                        if (success) {                            resolve(response);                        } else {                            reject(new AjaxError(response));                        }                        this.xhr = options = null;                    };                    if (!isString(method)) {                        var Exception: IExceptionStatic = acquire(__ExceptionStatic);                        Exception.warn('AjaxOptions method was not of type string. Defaulting to "GET".', Exception.AJAX);                        method = 'GET';                    }                    xhr.open(                        method.toUpperCase(),                        url,                        // synchronous XHR not supported                        true,                        options.user,                        options.password                        );                    var responseType = options.responseType;                    if (!(this.__fileSupported || responseType === '' || responseType === 'text')) {                        responseType = '';                    }                    xhr.responseType = responseType;                    xhr.withCredentials = options.withCredentials;                    var mimeType = options.overrideMimeType,                        data = options.data;                    if (isString(mimeType) && !isEmpty(mimeType)) {                        xhr.overrideMimeType(mimeType);                    }                    if (isNull(data) || data === '') {                        // no data exists so set headers and send request                        this.__setHeaders();                        xhr.send();                    } else {                        var transforms = options.transforms || [],                            length = transforms.length,                            contentType = options.contentType,                            contentTypeExists = isString(contentType) && !isEmpty(contentType);                        if (length > 0) {                            // if data transforms defined, assume they're going to take care of                             // any and all transformations.                            for (var i = 0; i < length; ++i) {                                data = transforms[i](data, xhr);                            }                            // if contentType exists, assume they did not set it in                             // their headers as well                            if (contentTypeExists) {                                xhr.setRequestHeader('Content-Type', contentType);                            }                            this.__setHeaders();                            xhr.send(data);                        } else if (isObject(data)) {                            // if isObject and contentType exists we want to transform the data                            if (contentTypeExists) {                                var contentTypeLower = contentType.toLowerCase();                                if (contentTypeLower.indexOf('x-www-form-urlencoded') !== -1) {                                    // perform an encoded form transformation                                    data = this.__serializeFormData();                                    // set Content-Type header because we're assuming they didn't set it                                     // in their headers object                                    xhr.setRequestHeader('Content-Type', contentType);                                    this.__setHeaders();                                    xhr.send(data);                                } else if (contentTypeLower.indexOf('multipart/form-data') !== -1) {                                    // need to check if File is a supported object                                    if (this.__fileSupported) {                                        // use FormData                                        data = this.__appendFormData();                                        // do not set the Content-Type header due to modern browsers                                         // setting special headers for multipart/form-data                                        this.__setHeaders();                                        xhr.send(data);                                    } else {                                        // use iframe trick for older browsers (do not send a request)                                        // this case is the reason for this giant, terrible, nested if-else statement                                        this.__submitFramedFormData().then((response) => {                                            resolve(response);                                        }, () => {                                            this.xhr = null;                                        });                                    }                                } else {                                    // assume stringification is possible                                    data = JSON.stringify(data);                                    // set Content-Type header because we're assuming they didn't set it                                     // in their headers object                                    xhr.setRequestHeader('Content-Type', contentType);                                    this.__setHeaders();                                    xhr.send(data);                                }                            } else {                                // contentType does not exist so simply set defined headers and send raw data                                this.__setHeaders();                                xhr.send(data);                            }                        } else {                            // if contentType exists set Content-Type header because we're assuming they didn't set it                             // in their headers object                            if (contentTypeExists) {                                xhr.setRequestHeader('Content-Type', contentType);                            }                            this.__setHeaders();                            xhr.send(data);                        }                    }                    var timeout = options.timeout;                    if (isNumber(timeout) && timeout > 0) {                        // we first postpone to avoid always timing out when debugging, though this is not                        // a foolproof method.                        this.clearTimeout = postpone(() => {                            this.clearTimeout = defer(() => {                                reject(new AjaxError({                                    response: 'Request timed out in ' + timeout + 'ms for ' + options.url,                                    status: xhr.status,                                    getAllResponseHeaders: xhr.getAllResponseHeaders,                                    xhr: xhr                                }));                                xhr.onreadystatechange = null;                                xhr.abort();                                this.xhr = null;                            }, timeout - 1);                        });                    }                }, { __http: this });            }            /**             * @name _invalidOptions             * @memberof plat.async.HttpRequest             * @kind function             * @access protected             *              * @description             * Returns a promise that is immediately rejected due to an error.             *              * @returns {plat.async.IAjaxPromise} A promise that immediately rejects              * with an {@link plat.async.IAjaxError|IAjaxError}             */            _invalidOptions(): IAjaxPromise<any> {                return new AjaxPromise((resolve, reject) => {                    var exceptionFactory: IExceptionStatic = acquire(__ExceptionStatic);                    exceptionFactory.warn('Attempting a request without specifying a url', exceptionFactory.AJAX);                    reject(new AjaxError({                        response: 'Attempting a request without specifying a url',                        status: null,                        getAllResponseHeaders: null,                        xhr: null                    }));                });            }            /**             * @name _formatResponse             * @memberof plat.async.HttpRequest             * @kind function             * @access protected             *              * @description             * The function that formats the response from the XMLHttpRequest.             *              * @param {string} responseType The user designated responseType             * @param {boolean} success Signifies if the response was a success             *              * @returns {IAjaxResponse<any>} The {@link plat.async.IAjaxResponse|IAjaxResponse} to be returned to              * the requester.             */            _formatResponse(responseType: string, success: boolean): IAjaxResponse<any> {                var xhr = this.xhr,                    status = xhr.status,                    response = xhr.response;                // need to try, catch instead of boolean short circuit because chrome doesn't like checking                 // responseText when the responseType is anything other than empty or 'text'                if (isNull(response)) {                    try {                        response = xhr.responseText;                    } catch (e) { }                }                if (status === 0) {                    // file protocol issue **Needs to be tested more thoroughly**                    // ok if response empty, Not Found otherwise                    status = success ? 200 : 404;                }                xhr.onreadystatechange = null;                if (isFunction(this.clearTimeout)) {                    this.clearTimeout();                }                if (responseType === 'json' && isString(response)) {                    try {                        response = JSON.parse(response);                    } catch (e) { }                }                return {                    response: response,                    status: status,                    getAllResponseHeaders: xhr.getAllResponseHeaders,                    xhr: xhr                };            }            /**             * @name __setHeaders             * @memberof plat.async.HttpRequest             * @kind function             * @access private             *              * @description             * Sets the headers for an XMLHttpRequest             *              * @returns {void}             */            private __setHeaders(): void {                var headers = this.__options.headers,                    keys = Object.keys(headers || {}),                    xhr = this.xhr,                    length = keys.length,                    key: string,                    i: number;                for (i = 0; i < length; ++i) {                    key = keys[i];                    xhr.setRequestHeader(key, headers[key]);                }            }            /**             * @name __serializeFormData             * @memberof plat.async.HttpRequest             * @kind function             * @access private             *              * @description             * Serializes multipart form data in an XMLHttpRequest as a string.             *              * @returns {string}             */            private __serializeFormData(): string {                var data = this.__options.data,                    keys = Object.keys(data),                    key: string,                    val: any,                    formBuffer: Array<string> = [];                while (keys.length > 0) {                    key = keys.pop();                    val = data[key];                    if (isNull(val)) {                        val = '';                    } else if (isObject(val)) {                        // may throw a fatal error but this is an invalid case                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);                        $exception.warn('Invalid form entry with key "' + key + '" and value "' + val, $exception.AJAX);                        val = JSON.stringify(val);                    }                    formBuffer.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));                }                return formBuffer.join('&').replace(/%20/g, '+');            }            /**             * @name __appendFormData             * @memberof plat.async.HttpRequest             * @kind function             * @access private             *              * @description             * Creates FormData to add to the XMLHttpRequest.             *              * @returns {FormData}             */            private __appendFormData(): FormData {                var data = this.__options.data,                    formData = new FormData(),                    keys = Object.keys(data),                    key: string,                    val: any;                while (keys.length > 0) {                    key = keys.pop();                    val = data[key];                    if (isNull(val)) {                        formData.append(key, '');                    } else if (isObject(val)) {                        if (isFile(val)) {                            formData.append(key, val, val.name || val.fileName || 'blob');                        } else {                            // may throw a fatal error but this is an invalid case                            var $exception: IExceptionStatic = acquire(__ExceptionStatic);                            $exception.warn('Invalid form entry with key "' + key + '" and value "' + val, $exception.AJAX);                            formData.append(key, JSON.stringify(val));                        }                    } else {                        formData.append(key, val);                    }                }                return formData;            }            /**             * @name __submitFramedFormData             * @memberof plat.async.HttpRequest             * @kind function             * @access private             *              * @description             * Handles submitting multipart form data using an iframe.             *              * @returns {plat.async.IThenable} A promise that fulfills after the form data is submitted.             */            private __submitFramedFormData(): IThenable<IAjaxResponse<any>> {                var options = this.__options,                    data = options.data,                    url = options.url,                    $document = this.$Document,                    $body = $document.body,                    Promise: IPromise = acquire(__Promise),                    form = $document.createElement('form'),                    iframe = $document.createElement('iframe'),                    iframeName = uniqueId('iframe_target'),                    keys = Object.keys(data),                    key: string;                iframe.name = form.target = iframeName;                iframe.src = 'javascript:false;';                form.enctype = form.encoding = 'multipart/form-data';                form.action = url;                form.method = 'POST';                form.style.display = 'none';                while (keys.length > 0) {                    key = keys.pop();                    form.insertBefore(this.__createInput(key, data[key]), null);                }                return new Promise<IAjaxResponse<any>>((resolve, reject) => {                    this.xhr.abort = () => {                        iframe.onload = null;                        $body.removeChild(form);                        $body.removeChild(iframe);                        reject();                    };                    iframe.onload = () => {                        var content = iframe.contentDocument.body.innerHTML;                        $body.removeChild(form);                        $body.removeChild(iframe);                        resolve({                            response: content,                            status: 200,                            getAllResponseHeaders: () => ''                        });                        this.xhr = iframe.onload = null;                    };                    $body.insertBefore(form, null);                    $body.insertBefore(iframe, null);                    form.submit();                });            }            /**             * @name __createInput             * @memberof plat.async.HttpRequest             * @kind function             * @access private             *              * @description             * Creates input for form data submissions.             *              * @returns {HTMLInputElement}             */            private __createInput(key: string, val: any): HTMLInputElement {                var $document = this.$Document,                    $exception: IExceptionStatic,                    input = <HTMLInputElement>$document.createElement('input');                input.type = 'hidden';                input.name = key;                if (isNull(val)) {                    input.value = '';                } else if (isObject(val)) {                    // check if val is an pseudo File                    if (isFunction(val.slice) && !(isUndefined(val.name) || isUndefined(val.path))) {                        var fileList = $document.querySelectorAll('input[type="file"][name="' + key + '"]'),                            length = fileList.length;                        // if no inputs found, stringify the data                        if (length === 0) {                            $exception = acquire(__ExceptionStatic);                            $exception.warn('Could not find input[type="file"] with [name="' + key +                                '"]. Stringifying data instead.', $exception.AJAX);                            input.value = JSON.stringify(val);                        } else if (length === 1) {                            input = <HTMLInputElement>fileList[0];                            // swap nodes                            var clone = input.cloneNode(true);                            input.parentNode.insertBefore(clone, input);                        } else {                            // rare case but may have multiple forms with file inputs                             // that have the same name                            var fileInput: HTMLInputElement,                                path = val.path;                            while (length-- > 0) {                                fileInput = <HTMLInputElement>fileList[length];                                if (fileInput.value === path) {                                    input = fileInput;                                    // swap nodes                                    var inputClone = input.cloneNode(true);                                    input.parentNode.insertBefore(inputClone, input);                                    break;                                }                            }                            // could not find the right file                            if (length === -1) {                                $exception = acquire(__ExceptionStatic);                                $exception.warn('Could not find input[type="file"] with [name="' + key + '"] and [value="' +                                    val.path + '"]. Stringifying data instead.', $exception.AJAX);                                input.value = JSON.stringify(val);                            }                        }                    } else {                        // may throw a fatal error but this is an invalid case                        $exception = acquire(__ExceptionStatic);                        $exception.warn('Invalid form entry with key "' + key + '" and value "' + val, $exception.AJAX);                        input.value = JSON.stringify(val);                    }                } else {                    input.value = val;                }                return input;            }        }        /**         * @name IHttpRequest         * @memberof plat.async         * @kind interface         * @exported false         *          * @description         * IHttpRequest provides a wrapper for the XMLHttpRequest object. Allows for         * sending AJAX requests to a server.         */        interface IHttpRequest {            /**             * @name execute             * @memberof plat.async.IHttpRequest             * @kind function             * @access public             *              * @description             * Executes an XMLHttpRequest and resolves an {@link plat.async.IAjaxPromise|IAjaxPromise} upon completion.             *              * @typeparam {any} R The response type for the XMLHttpRequest object.             *              * @returns {plat.async.IAjaxPromise} A promise that fulfills when the XMLHttpRequest is done.              */            execute<R>(): IAjaxPromise<R>;            /**             * @name executeJsonp             * @memberof plat.async.IHttpRequest             * @kind function             * @access public             *              * @description             * Executes an JSONP request and resolves an {@link plat.async.IAjaxPromise|IAjaxPromise} upon completion.             *              * @typeparam {any} R The response type for the JSONP callback parameter.             *              * @returns {plat.async.IAjaxPromise} A promise that fulfills when the JSONP request is done.              */            executeJsonp<R>(): IAjaxPromise<R>;        }        /**         * @name IHttpConfig         * @memberof plat.async         * @kind interface         *          * @extends {plat.async.IJsonpConfig}         *          * @description         * Describes an object which contains Ajax configuration properties.         */        export interface IHttpConfig extends IJsonpConfig {            /**             * @name method             * @memberof plat.async.IHttpConfig             * @kind property             * @access public             * @optional             *              * @type {string}             *              * @description             * The HTTP method type of XmlHttpRequest such as 'GET', 'POST', 'PUT',              * 'DELETE', etc. Ignored for non-HTTP urls. Defaults to 'GET'.             */            method?: string;            /**             * @name timeout             * @memberof plat.async.IHttpConfig             * @kind property             * @access public             * @optional             *              * @type {number}             *              * @description             * The number of milliseconds a request can take before              * automatically being terminated. A value of 0              * means there is no timeout.             */            timeout?: number;            /**             * @name user             * @memberof plat.async.IHttpConfig             * @kind property             * @access public             * @optional             *              * @type {string}             *              * @description             * An optional user string for the XmlHttpRequest             */            user?: string;            /**             * @name password             * @memberof plat.async.IHttpConfig             * @kind property             * @access public             * @optional             *              * @type {string}             *              * @description             * An optional password string for the XmlHttpRequest             */            password?: string;            /**             * @name responseType             * @memberof plat.async.IHttpConfig             * @kind property             * @access public             * @optional             *              * @type {string}             *              * @description             * The XMLHttpRequestResponseType. The response should              * still be checked when received due to browser              * incompatibilities. If a browser does not support a              * response type it will return the value as a string.              * The response type does not affect JSONP callback              * arguments.             *              * @see config.XMLHttpRequestResponseType             */            responseType?: string;            /**             * @name contentType             * @memberof plat.async.IHttpConfig             * @kind property             * @access public             * @optional             *              * @type {string}             *              * @description             * The Content-Type header for XMLHttpRequest when              * data is being sent. The default is              * 'application/json;charset=utf-8;'.             */            contentType?: string;            /**             * @name overrideMimeType             * @memberof plat.async.IHttpConfig             * @kind property             * @access public             * @optional             *              * @type {string}             *              * @description             * A string to override the MIME type returned by the server.             */            overrideMimeType?: string;            /**             * @name headers             * @memberof plat.async.IHttpConfig             * @kind property             * @access public             * @optional             *              * @type {any}             *              * @description             * A key/value pair object where the key is a DOMString header key             * and the value is the DOMString header value.             */            headers?: any;            /**             * @name withCredentials             * @memberof plat.async.IHttpConfig             * @kind property             * @access public             * @optional             *              * @type {boolean}             *              * @description             * Indicates whether or not cross-site Access-Control requests              * should be made using credentials such as cookies or              * authorization headers. The default is false.             */            withCredentials?: boolean;            /**             * @name data             * @memberof plat.async.IHttpConfig             * @kind property             * @access public             * @optional             *              * @type {any}             *              * @description             * The request payload             */            data?: any;            /**             * @name transforms             * @memberof plat.async.IHttpConfig             * @kind property             * @access public             * @optional             *              * @type {plat.async.IHttpTransformFunction}             *              * @description             * An array of data transform functions that fire in order and consecutively              * pass the returned result from one function to the next.             */            transforms?: Array<IHttpTransformFunction>;            /**             * @name isCrossDomain             * @memberof plat.async.IHttpConfig             * @kind property             * @access public             * @optional             *              * @type {boolean}             *              * @description             * Forces a JSONP, cross-domain request when set to true.             * The default is false.             */            isCrossDomain?: boolean;        }        /**         * @name IHttpTransformFunction         * @memberof plat.async         * @kind interface         *          * @description         * A function that is used to transform XMLHttpRequest data.         */        export interface IHttpTransformFunction {            /**             * @memberof plat.async.IHttpTransformFunction             * @kind function             * @access public             *              * @description             * The method signature for {@link plat.async.IHttpTransformFunction|IHttpTransformFunction}.             *              * @param {any} data The data for the XMLHttpRequest.             * @param {XMLHttpRequest} xhr The XMLHttpRequest for the data.             *              * @returns {any} The transformed data.             */            (data: any, xhr: XMLHttpRequest): any;        }        /**         * @name IJsonpConfig         * @memberof plat.async         * @kind interface         *          * @description         * Describes an object which contains JSONP configuration properties.         */        export interface IJsonpConfig {            /**             * @name url             * @memberof plat.async.IJsonpConfig             * @kind property             * @access public             *              * @type {string}             *              * @description             * The url for the JSONP callback              * (without the `?{callback}={callback_name}` parameter in the url)              * or for the XmlHttpRequest.             */            url: string;            /**             * @name jsonpIdentifier             * @memberof plat.async.IJsonpConfig             * @kind property             * @access public             * @optional             *              * @type {string}             *              * @description             * The identifier the server uses to get the name of the JSONP             * callback. The default is 'callback' as seen in              * http://www.platyfi.com/data?callback=plat_fnName.             */            jsonpIdentifier?: string;            /**             * @name jsonpCallback             * @memberof plat.async.IJsonpConfig             * @kind property             * @access public             * @optional             *              * @type {string}             *              * @description             * A specified name for the JSONP callback (in case the server has              * it hardcoded and/or does not get it from the given url). The              * default is a unique plat id generated separately for              * each JSONP callback seen as 'plat_callback00' in             * http://www.platyfi.com/data?callback=plat_callback00.             */            jsonpCallback?: string;        }        /**         * @name IAjaxResponse         * @memberof plat.async         * @kind interface         *          * @description         * Describes an object that is the response to an AJAX request.         *          * @typeparam {any} R The type of the AJAX response.         */        export interface IAjaxResponse<R> {            /**             * @name response             * @memberof plat.async.IAjaxResponse             * @kind property             * @access public             *              * @type {R}             *              * @description             * The AJAX response or responseText. The response should              * be checked when received due to browser              * incompatibilities with responseType. If a browser does              * not support a response type it will return the value as              * a string.             */            response: R;            /**             * @name status             * @memberof plat.async.IAjaxResponse             * @kind property             * @access public             *              * @type {number}             *              * @description             * The XHR status. Resolves as 200 for JSONP.             */            status: number;            /**             * @name getAllResponseHeaders             * @memberof plat.async.IAjaxResponse             * @kind function             * @access public             *              * @description             * A method for getting the XHR response headers.             *              * @returns {void}             */            getAllResponseHeaders?: () => string;            /**             * @name xhr             * @memberof plat.async.IAjaxResponse             * @kind property             * @access public             * @optional             *              * @type {XMLHttpRequest}             *              * @description             * The XMLHttpRequest object associated with the AJAX call             */            xhr?: XMLHttpRequest;        }        /**         * @name IAjaxResolveFunction         * @memberof plat.async         * @kind interface         *          * @description         * Describes the AjaxPromise's resolve function         *          * @typeparam {any} R The type of the {@link plat.async.IAjaxResponse|IAjaxResponse} object.         */        export interface IAjaxResolveFunction<R> {            /**             * @memberof plat.async.IAjaxResolveFunction             * @kind function             * @access public             *              * @description             * The method signature for an {@link plat.async.IAjaxResolveFunction|IAjaxResolveFunction}.             *              * @param {(value?: plat.async.IAjaxResponse<R>) => any} resolve The function to call when the              * AJAX call has successfully fulfilled.             * @param {(reason?: plat.async.IAjaxError) => any} reject The function to call when the              * AJAX call fails.             *              * @returns {void}             */            (resolve: (value?: IAjaxResponse<R>) => any, reject: (reason?: IAjaxError) => any): void;        }        /**         * @name AjaxError         * @memberof plat.async         * @kind class         * @exported false         *          * @implements {plat.async.IAjaxError}         *          * @description         * A class that forms an Error object with an {@link plat.async.IAjaxResponse|IAjaxResponse}.         */        class AjaxError implements IAjaxError {            /**             * @name name             * @memberof plat.async.AjaxError             * @kind property             * @access public             *              * @type {string}             *              * @description             * The name of the Error ('AjaxError')             */            name: string = 'AjaxError';            /**             * @name message             * @memberof plat.async.AjaxError             * @kind property             * @access public             *              * @type {string}             *              * @description             * The Error message             */            message: string;            /**             * @name response             * @memberof plat.async.AjaxError             * @kind property             * @access public             *              * @type {any}             *              * @description             * The response from the XMLHttpRequest             */            response: any;            /**             * @name status             * @memberof plat.async.AjaxError             * @kind property             * @access public             *              * @type {number}             *              * @description             * The status code from the XMLHttpRequest             */            status: number;            /**             * @name getAllResponseHeaders             * @memberof plat.async.AjaxError             * @kind function             * @access public             *              * @description             * A method for getting the XHR response headers.             *              * @returns {void}             */            getAllResponseHeaders: () => string;            /**             * @name xhr             * @memberof plat.async.AjaxError             * @kind property             * @access public             *              * @type {XMLHttpRequest}             *              * @description             * The XMLHttpRequest object associated with the AJAX call             */            xhr: XMLHttpRequest;            /**             * @name constructor             * @memberof plat.async.AjaxError             * @kind function             * @access public             *              * @description             * The constructor for an {@link plat.async.AjaxError|AjaxError}.             *              * @param {plat.async.IAjaxResponse} response The {@link plat.async.IAjaxResponse|IAjaxResponse} object.             *              * @returns {plat.async.AjaxError}             */            constructor(response: IAjaxResponse<any>) {                Error.apply(this);                this.response = this.message = response.response;                this.status = response.status;                this.getAllResponseHeaders = response.getAllResponseHeaders;                this.xhr = response.xhr;            }            /**             * @name toString             * @memberof plat.async.AjaxError             * @kind function             * @access public             *              * @description             * Outputs a formatted string describing the {@link plat.async.AjaxError|AjaxError}.             *              * @returns {string}             */            toString(): string {                var response = this.response,                    responseText = response;                if (isObject(response) && !response.hasOwnProperty('toString')) {                    responseText = JSON.stringify(response);                }                return 'Request failed with status: ' + this.status + ' and response: ' + responseText;            }        }        // have to bypass TS flags in order to properly extend Error        (<any>AjaxError).prototype = Error.prototype;        /**         * @name IAjaxError         * @memberof plat.async         * @kind interface         *          * @implements {plat.async.IAjaxResponse}         *          * @description         * Describes an object that forms an Error object with an {@link plat.async.IAjaxResponse|IAjaxResponse}.         */        export interface IAjaxError extends Error, IAjaxResponse<any> { }        /**         * @name AjaxPromise         * @memberof plat.async         * @kind class         *          * @extends {plat.async.Promise}         * @implements {plat.async.IAjaxPromise}         *          * @description         * Describes a type of {@link plat.async.Promise|Promise} that fulfills with an {@link plat.async.IAjaxResponse|IAjaxResponse} and can be optionally cancelled.         *          * @typeparam {any} R The type of the response object in the {@link plat.async.IAjaxResponse|IAjaxResponse}.         */        export class AjaxPromise<R> extends Promise<IAjaxResponse<R>> implements IAjaxPromise<R> {            /**             * @name $Window             * @memberof plat.async.AjaxPromise             * @kind property             * @access public             * @readonly             *              * @type {Window}             *              * @description             * The Window object.             */            $Window: Window = acquire(__Window);            /**             * @name __http             * @memberof plat.async.AjaxPromise             * @kind property             * @access private             * @readonly             *              * @type {plat.async.HttpRequest}             *              * @description             * The {@link plat.async.HttpRequest|HttpRequest} object.             */            private __http: HttpRequest;            /**             * @name constructor             * @memberof plat.async.AjaxPromise             * @kind function             * @access public             * @variation 0             *              * @description             * The constructor method for the {@link plat.async.AjaxPromise}.             *              * @param {plat.async.IAjaxResolveFunction} resolveFunction The promise resolve function.             *              * @returns {plat.async.AjaxPromise}             */            constructor(resolveFunction: IAjaxResolveFunction<R>);            /**             * @name constructor             * @memberof plat.async.AjaxPromise             * @kind function             * @access public             * @variation 1             *              * @description             * The constructor method for the {@link plat.async.AjaxPromise}.             *              * @param {plat.async.IAjaxResolveFunction} resolveFunction The promise resolve function.             * @param promise The promise object to allow for cancelling the {@link plat.async.AjaxPromise}.             *              * @returns {plat.async.AjaxPromise}             */            constructor(resolveFunction: IAjaxResolveFunction<R>, promise: any);            constructor(resolveFunction: IAjaxResolveFunction<R>, promise?: any) {                super(resolveFunction);                if (!isNull(promise)) {                    this.__http = promise.__http;                }            }            /**             * @name cancel             * @memberof plat.async.AjaxPromise             * @kind function             * @access public             *              * @description             * A method to cancel the AJAX call associated with this {@link plat.async.AjaxPromise}.             *              * @returns {void}             */            cancel(): void {                var http = this.__http,                    xhr = http.xhr,                    jsonpCallback = http.jsonpCallback;                if (isFunction(http.clearTimeout)) {                    http.clearTimeout();                }                if (!isNull(xhr)) {                    xhr.onreadystatechange = null;                    xhr.abort();                    http.xhr = null;                } else if (!isNull(jsonpCallback)) {                    (<any>this.$Window)[jsonpCallback] = noop;                }                (<any>this).__subscribers = [];            }            /**             * @name then             * @memberof plat.async.AjaxPromise             * @kind function             * @access public             * @variation 0             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the              * next then method in the promise chain.             *              * @param {(success: plat.async.IAjaxResponse<R>) => plat.async.IAjaxThenable<U>} onFulfilled A method called when/if the promise fulfills.              * If undefined the next onFulfilled method in the promise chain will be called.             * @param {(error: plat.async.IAjaxError) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: IAjaxResponse<R>) => U,                onRejected?: (error: IAjaxError) => any): IAjaxThenable<U>;            /**             * @name then             * @memberof plat.async.AjaxPromise             * @kind function             * @access public             * @variation 1             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the              * next then method in the promise chain.             *              * @param {(success: plat.async.IAjaxResponse<R>) => plat.async.IAjaxThenable<U>} onFulfilled A method called when/if the promise fulfills.              * If undefined the next onFulfilled method in the promise chain will be called.             * @param {(error: plat.async.IAjaxError) => U} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: IAjaxResponse<R>) => IThenable<U>,                onRejected?: (error: IAjaxError) => IThenable<U>): IAjaxThenable<U>;            /**             * @name then             * @memberof plat.async.AjaxPromise             * @kind function             * @access public             * @variation 2             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the              * next then method in the promise chain.             *              * @param {(success: plat.async.IAjaxResponse<R>) => U} onFulfilled A method called when/if the promise fulfills.              * If undefined the next onFulfilled method in the promise chain will be called.             * @param {(error: plat.async.IAjaxError) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: IAjaxResponse<R>) => IThenable<U>,                onRejected?: (error: IAjaxError) => any): IAjaxThenable<U>;            /**             * @name then             * @memberof plat.async.AjaxPromise             * @kind function             * @access public             * @variation 3             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the              * next then method in the promise chain.             *              * @param {(success: plat.async.IAjaxResponse<R>) => U} onFulfilled A method called when/if the promise fulfills.              * If undefined the next onFulfilled method in the promise chain will be called.             * @param {(error: plat.async.IAjaxError) => U} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: IAjaxResponse<R>) => U,                onRejected?: (error: IAjaxError) => IThenable<U>): IAjaxThenable<U>;            then<U>(onFulfilled: (success: IAjaxResponse<R>) => U,                onRejected?: (error: IAjaxError) => any): IAjaxThenable<U> {                return <IAjaxThenable<U>><any>super.then<U>(onFulfilled, onRejected);            }            catch<U>(onRejected: (error: any) => IAjaxThenable<U>): IAjaxThenable<U>;            catch<U>(onRejected: (error: any) => U): IAjaxThenable<U>;            catch<U>(onRejected: (error: any) => any): IAjaxThenable<U> {                return <IAjaxThenable<U>><any>super.catch<U>(onRejected);            }        }        /**         * @name IAjaxThenable         * @memberof plat.async         * @kind interface         *          * @extends {plat.async.IThenable}         *          * @description          * Describes a type of {@link plat.async.IThenable|IThenable} that can optionally cancel it's associated AJAX call.         *          * @typeparam {any} R The return type for the {@link plat.async.IThenable|IThenable}.         */        export interface IAjaxThenable<R> extends IThenable<R> {            /**             * @name cancel             * @memberof plat.async.IAjaxThenable             * @kind function             * @access public             *              * @description             * A method to cancel the AJAX call associated with this {@link plat.async.AjaxPromise}.             *              * @returns {void}             */            cancel(): void;            /**             * @name then             * @memberof plat.async.IAjaxThenable             * @kind function             * @access public             * @variation 0             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the              * next then method in the promise chain.             *              * @param {(success: R) => plat.async.IAjaxThenable<U>} onFulfilled A method called when/if the promise fulfills.              * If undefined the next onFulfilled method in the promise chain will be called.             * @param {(error: any) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: R) => IAjaxThenable<U>, onRejected?: (error: any) => IAjaxThenable<U>): IAjaxThenable<U>;            /**             * @name then             * @memberof plat.async.IAjaxThenable             * @kind function             * @access public             * @variation 1             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the              * next then method in the promise chain.             *              * @param {(success: R) => plat.async.IAjaxThenable<U>} onFulfilled A method called when/if the promise fulfills.              * If undefined the next onFulfilled method in the promise chain will be called.             * @param {(error: any) => U} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: R) => IAjaxThenable<U>, onRejected?: (error: any) => U): IAjaxThenable<U>;            /**             * @name then             * @memberof plat.async.IAjaxThenable             * @kind function             * @access public             * @variation 2             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the              * next then method in the promise chain.             *              * @param {(success: R) => U} onFulfilled A method called when/if the promise fulfills.              * If undefined the next onFulfilled method in the promise chain will be called.             * @param {(error: any) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => IAjaxThenable<U>): IAjaxThenable<U>;            /**             * @name then             * @memberof plat.async.IAjaxThenable             * @kind function             * @access public             * @variation 3             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the              * next then method in the promise chain.             *              * @param {(success: R) => U} onFulfilled A method called when/if the promise fulfills.              * If undefined the next onFulfilled method in the promise chain will be called.             * @param {(error: any) => U} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => U): IAjaxThenable<U>;            /**             * @name catch             * @memberof plat.async.IAjaxThenable             * @kind function             * @access public             * @variation 0             *              * @description             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}             *              * @param {(error: any) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            catch<U>(onRejected: (error: any) => IAjaxThenable<U>): IAjaxThenable<U>;            /**             * @name catch             * @memberof plat.async.IAjaxThenable             * @kind function             * @access public             * @variation 1             *              * @description             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}             *              * @param {(error: any) => U} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            catch<U>(onRejected: (error: any) => U): IAjaxThenable<U>;        }        /**         * @name IAjaxPromise         * @memberof plat.async         * @kind interface         *          * @extends {plat.async.IAjaxThenable}         *          * @description         * Describes a type of {@link plat.async.IPromise|IPromise} that fulfills with an {@link plat.async.IAjaxResponse|IAjaxResponse} and can be optionally cancelled.         *          * @typeparam {any} R The type of the response object in the {@link plat.async.IAjaxResponse|IAjaxResponse}.         */        export interface IAjaxPromise<R> extends IAjaxThenable<IAjaxResponse<R>> {            /**             * @name cancel             * @memberof plat.async.IAjaxPromise             * @kind function             * @access public             *              * @description             * A method to cancel the AJAX call associated with this {@link plat.async.AjaxPromise}.             *              * @returns {void}             */            cancel(): void;            /**             * @name then             * @memberof plat.async.IAjaxPromise             * @kind function             * @access public             * @variation 0             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the              * next then method in the promise chain.             *              * @param {(success: plat.async.IAjaxResponse<R>) => plat.async.IAjaxThenable<U>} onFulfilled A method called when/if the promise fulfills.              * If undefined the next onFulfilled method in the promise chain will be called.             * @param {(error: plat.async.IAjaxError) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: IAjaxResponse<R>) => IAjaxThenable<U>, onRejected?: (error: IAjaxError) => IAjaxThenable<U>): IAjaxThenable<U>;            /**             * @name then             * @memberof plat.async.IAjaxPromise             * @kind function             * @access public             * @variation 1             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the              * next then method in the promise chain.             *              * @param {(success: plat.async.IAjaxResponse<R>) => plat.async.IAjaxThenable<U>} onFulfilled A method called when/if the promise fulfills.              * If undefined the next onFulfilled method in the promise chain will be called.             * @param {(error: plat.async.IAjaxError) => U} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: IAjaxResponse<R>) => IAjaxThenable<U>, onRejected?: (error: IAjaxError) => U): IAjaxThenable<U>;            /**             * @name then             * @memberof plat.async.IAjaxPromise             * @kind function             * @access public             * @variation 2             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the              * next then method in the promise chain.             *              * @param {(success: plat.async.IAjaxResponse<R>) => U} onFulfilled A method called when/if the promise fulfills.              * If undefined the next onFulfilled method in the promise chain will be called.             * @param {(error: plat.async.IAjaxError) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: IAjaxResponse<R>) => U, onRejected?: (error: IAjaxError) => IAjaxThenable<U>): IAjaxThenable<U>;            /**             * @name then             * @memberof plat.async.IAjaxPromise             * @kind function             * @access public             * @variation 3             *              * @description             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @typeparam {any} U The type of the object returned from the fulfill/reject callbacks, which will be carried to the              * next then method in the promise chain.             *              * @param {(success: plat.async.IAjaxResponse<R>) => U} onFulfilled A method called when/if the promise fulfills.              * If undefined the next onFulfilled method in the promise chain will be called.             * @param {(error: plat.async.IAjaxError) => U} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: IAjaxResponse<R>) => U, onRejected?: (error: IAjaxError) => U): IAjaxThenable<U>;            /**             * @name catch             * @memberof plat.async.IAjaxPromise             * @kind function             * @access public             * @variation 0             *              * @description             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}             *              * @param {(error: plat.async.IAjaxError) => plat.async.IAjaxThenable<U>} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            catch<U>(onRejected: (error: IAjaxError) => IAjaxThenable<U>): IAjaxThenable<U>;            /**             * @name catch             * @memberof plat.async.IAjaxPromise             * @kind function             * @access public             * @variation 1             *              * @description             * A wrapper method for {@link plat.async.Promise|Promise.then(undefined, onRejected);}             *              * @param {(error: plat.async.IAjaxError) => U} onRejected A method called when/if the promise rejects.              * If undefined the next onRejected method in the promise chain will be called.             */            catch<U>(onRejected: (error: IAjaxError) => U): IAjaxThenable<U>;        }        /**         * @name IHttpResponseType         * @memberof plat.async         * @kind interface         *          * @description         * Describes an object that provides value mappings for XMLHttpRequestResponseTypes         */        export interface IHttpResponseType {            /**             * @name DEFAULT             * @memberof plat.async.IHttpResponseType             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * The default response type (empty string)             */            DEFAULT: string;            /**             * @name ARRAYBUFFER             * @memberof plat.async.IHttpResponseType             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * The arrayBuffer type ('arrayBuffer')             */            ARRAYBUFFER: string;            /**             * @name BLOB             * @memberof plat.async.IHttpResponseType             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * The blob type ('blob')             */            BLOB: string;            /**             * @name DOCUMENT             * @memberof plat.async.IHttpResponseType             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * The document type ('document')             */            DOCUMENT: string;            /**             * @name JSON             * @memberof plat.async.IHttpResponseType             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * The json type ('json')             */            JSON: string;            /**             * @name TEXT             * @memberof plat.async.IHttpResponseType             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * The text type ('text')             */            TEXT: string;        }        /**         * @name IHttpContentType         * @memberof plat.async         * @kind interface         *          * @description         * Describes an object that provides Content-Type mappings for Http POST requests.         */        export interface IHttpContentType {            /**             * @name ENCODED_FORM             * @memberof plat.async.IHttpContentType             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * Standard denotation for form encoded data. All objects are converted              * to string key-value pairs.             */            ENCODED_FORM: string;            /**             * @name JSON             * @memberof plat.async.IHttpContentType             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * Standard denotation for JavaScript Object Notation (JSON).             */            JSON: string;            /**             * @name MULTIPART_FORM             * @memberof plat.async.IHttpContentType             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * Standard denotation for a multi-part Webform. Associated with              * an entype of 'multipart/form-data'.             */            MULTIPART_FORM: string;            /**             * @name OCTET_STREAM             * @memberof plat.async.IHttpContentType             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * Standard denotation for arbitrary binary data.             */            OCTET_STREAM: string;            /**             * @name XML             * @memberof plat.async.IHttpContentType             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * Standard denotation for XML files.             */            XML: string;            /**             * @name PLAIN_TEXT             * @memberof plat.async.IHttpContentType             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * Standard denotation for textual data.             */            PLAIN_TEXT: string;            /**             * @name HTML             * @memberof plat.async.IHttpContentType             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * Standard denotation for HTML.             */            HTML: string;        }        /**         * @name Http         * @memberof plat.async         * @kind class         *          * @implements {plat.async.IHttp}         *          * @description         * The instantiated class of the injectable for making          * AJAX requests.         */        export class Http implements IHttp {            /**             * @name config             * @memberof plat.async.Http             * @kind property             * @access public             * @static             *              * @type {plat.async.IHttpConfig}             *              * @description             * Default Http config             */            static config: IHttpConfig = {                url: null,                method: 'GET',                responseType: '',                transforms: [],                headers: {},                withCredentials: false,                timeout: null,                jsonpIdentifier: 'callback',                contentType: 'application/json;charset=utf-8;'            };            /**             * @name responseType             * @memberof plat.async.Http             * @kind property             * @access public             *              * @type {plat.async.IHttpResponseType}             *              * @description             * Provides value mappings for XMLHttpRequestResponseTypes             */            responseType: IHttpResponseType = {                DEFAULT: '',                ARRAYBUFFER: 'arraybuffer',                BLOB: 'blob',                DOCUMENT: 'document',                JSON: 'json',                TEXT: 'text'            };            /**             * @name contentType             * @memberof plat.async.Http             * @kind property             * @access public             *              * @type {plat.async.IHttpContentType}             *              * @description             * Provides Content-Type mappings for Http POST requests.             */            contentType: IHttpContentType = {                ENCODED_FORM: 'application/x-www-form-urlencoded;charset=utf-8;',                JSON: 'application/json;charset=utf-8;',                MULTIPART_FORM: 'multipart/form-data;',                OCTET_STREAM: 'application/octet-stream;charset=utf-8;',                XML: 'application/xml;charset=utf-8;',                PLAIN_TEXT: 'text/plain;',                HTML: 'text/html;'            };            /**             * @name ajax             * @memberof plat.async.Http             * @kind function             * @access public             *              * @description             * A wrapper method for the Http class that creates and executes a new Http with             * the specified {@link plat.async.IAjaxOptions|IAjaxOptions}. This function will check if              * XMLHttpRequest level 2 is present, and will default to JSONP if it isn't and              * the request is cross-domain.             *              * @typeparam {any} R The type of the {@link plat.async.IAjaxPromise|IAjaxPromise}             *              * @param {plat.async.IHttpConfig} options The {@link plat.async.IAjaxOptions|IAjaxOptions} for either the XMLHttpRequest              * or the JSONP callback.             *              * @returns {plat.async.IAjaxPromise} A promise, when fulfilled             * or rejected, will return an {@link plat.async.IAjaxResponse|IAjaxResponse} object.             */            ajax<R>(options: IHttpConfig): IAjaxPromise<R> {                return new HttpRequest(options).execute<R>();            }            /**             * @name jsonp             * @memberof plat.async.Http             * @kind function             * @access public             *              * @description             * A direct method to force a cross-domain JSONP request.             *              * @typeparam {any} R The type of the {@link plat.async.IAjaxPromise|IAjaxPromise}             *              * @param {plat.async.IJsonpConfig} options The {@link plat.async.IJsonpConfig|IJsonpConfig}              *              * @returns {plat.async.IAjaxPromise} A promise, when fulfilled or rejected, will return an              * {@link plat.async.IAjaxResponse|IAjaxResponse} object.             */            jsonp<R>(options: IJsonpConfig): IAjaxPromise<R> {                return new HttpRequest(options).executeJsonp<R>();            }            /**             * @name json             * @memberof plat.async.Http             * @kind function             * @access public             *              * @description             * Makes an ajax request, specifying responseType: 'json'.             *              * @typeparam {any} R The type of the {@link plat.async.IAjaxPromise|IAjaxPromise}             *              * @param {plat.async.IHttpConfig} options The {@link plat.async.IHttpConfig|IHttpConfig}              * for either the XMLHttpRequest or the JSONP callback.             *              * @returns {plat.async.IAjaxPromise} A promise, when fulfilled or rejected,              * will return an {@link plat.async.IAjaxResponse|IAjaxResponse} object, with the response              * being a parsed JSON object (assuming valid JSON).             */            json<R>(options: IHttpConfig): IAjaxPromise<R> {                return new HttpRequest(extend({}, options, { responseType: 'json' })).execute<R>();            }        }        /**         * The Type for referencing the '$Http' injectable as a dependency.         */        export function IHttp(): IHttp {            return new Http();        }        register.injectable(__Http, IHttp);        /**         * @name IHttp         * @memberof plat.async         * @kind interface         *          * @description         * The interface of the injectable for making          * AJAX requests.         */        export interface IHttp {            /**             * @name responseType             * @memberof plat.async.IHttp             * @kind property             * @access public             *              * @type {plat.async.IHttpResponseType}             *              * @description             * Provides value mappings for             * XMLHttpRequestResponseTypes             */            responseType: IHttpResponseType;            /**             * @name contentType             * @memberof plat.async.IHttp             * @kind property             * @access public             *              * @type {plat.async.IHttpContentType}             *              * @description             * Provides Content-Type mappings for Http POST requests.             */            contentType: IHttpContentType;            /**             * @name ajax             * @memberof plat.async.IHttp             * @kind function             * @access public             *              * @description             * A wrapper method for the Http class that creates and executes a new Http with             * the specified {@link plat.async.IAjaxOptions|IAjaxOptions}. This function will check if              * XMLHttpRequest level 2 is present, and will default to JSONP if it isn't and              * the request is cross-domain.             *              * @typeparam {any} R The type of the {@link plat.async.IAjaxPromise|IAjaxPromise}             *              * @param {plat.async.IHttpConfig} options The {@link plat.async.IAjaxOptions|IAjaxOptions} for either the XMLHttpRequest              * or the JSONP callback.             *              * @returns {plat.async.AjaxPromise} A promise, when fulfilled             * or rejected, will return an {@link plat.async.IAjaxResponse|IAjaxResponse} object.             */            ajax<R>(options: IHttpConfig): IAjaxPromise<R>;            /**             * @name jsonp             * @memberof plat.async.IHttp             * @kind function             * @access public             *              * @description             * A direct method to force a cross-domain JSONP request.             *              * @typeparam {any} R The type of the {@link plat.async.IAjaxPromise|IAjaxPromise}             *              * @param {plat.async.IJsonpConfig} options The {@link plat.async.IJsonpConfig|IJsonpConfig}              *              * @returns {plat.async.IAjaxPromise} A promise, when fulfilled or rejected, will return an              * {@link plat.async.IAjaxResponse|IAjaxResponse} object.             */            jsonp? <R>(options: IJsonpConfig): IAjaxPromise<R>;            /**             * @name json             * @memberof plat.async.IHttp             * @kind function             * @access public             *              * @description             * Makes an ajax request, specifying responseType: 'json'.             *              * @typeparam {any} R The type of the {@link plat.async.IAjaxPromise|IAjaxPromise}             *              * @param {plat.async.IHttpConfig} options The {@link plat.async.IHttpConfig|IHttpConfig}              * for either the XMLHttpRequest or the JSONP callback.             *              * @returns {plat.async.IAjaxPromise} A promise, when fulfilled or rejected,              * will return an {@link plat.async.IAjaxResponse|IAjaxResponse} object, with the response              * being a parsed JSON object (assuming valid JSON).             */            json? <R>(options: IHttpConfig): IAjaxPromise<R>;        }        /**         * The Type for referencing the '$HttpConfig' injectable as a dependency.         */        export function IHttpConfig(): IHttpConfig {            return Http.config;        }        register.injectable(__HttpConfig, IHttpConfig);    }    export module storage {        var caches: IObject<Cache<any>> = {};        var internalCaches: any = {};        /**         * A Cache class, for use with the $CacheFactory injectable. Used for storing objects.         * Takes in a generic type corresponding to the type of objects it contains.         *          */        export class Cache<T> implements ICache<T> {            /**             * Method for creating a new Cache. Takes a generic type to denote the             * type of objects stored in the new Cache.  If the Cache already exists             * in the $CacheFactory, a new Cache will not be created.             *              * @static             * @param id The id of the new Cache.             * @param options ICacheOptions for customizing the Cache.             */            static create<T>(id: string, options?: ICacheOptions): ICache<T> {                var cache: ICache<T> = caches[id];                if (isNull(cache)) {                    cache = caches[id] = new Cache<T>(id, options);                }                return cache;            }            /**             * Gets a cache out of the $CacheFactory if it exists.             *              * @static             * @param id The identifier used to search for the cache.             *              * @returns {Cache<T>|undefined}             */            static fetch<T>(id: string): ICache<T> {                return caches[id];            }            /**             * Clears the CacheFactory and all of its caches.             *              * @static             */            static clear(): void {                var keys = Object.keys(caches),                    length = keys.length;                for (var i = 0; i < length; ++i) {                    caches[keys[i]].clear();                }                caches = <IObject<Cache<any>>>{};            }            private __size: number;            private __id: string;            private __options: ICacheOptions;            /**             * @param id The id to use to retrieve the cache from the CacheFactory.             * @param options The ICacheOptions for customizing the cache.             */            constructor(id: string, options?: ICacheOptions) {                this.__id = id;                this.__options = options;                this.__size = 0;                if (isNull(options)) {                    this.__options = {                        timeout: 0                    };                }                internalCaches[id] = {};            }            info(): ICacheInfo {                return {                    id: this.__id,                    size: this.__size,                    options: this.__options                };            }            put(key: string, value: T): T {                var val = internalCaches[this.__id][key];                internalCaches[this.__id][key] = value;                if (isUndefined(val)) {                    this.__size++;                }                var timeout = this.__options.timeout;                if (isNumber(timeout) && timeout > 0) {                    defer(<(key?: string) => void>this.remove, timeout, [key], this);                }                return value;            }            read(key: string): T {                return internalCaches[this.__id][key];            }            remove(key: string): void {                deleteProperty(internalCaches[this.__id], key);                this.__size--;            }            clear(): void {                internalCaches[this.__id] = {};                this.__size = 0;            }            dispose(): void {                this.clear();                deleteProperty(caches, this.__id);            }        }        /**         * The Type for referencing the '$CacheFactory' injectable as a dependency.         */        export function ICacheFactory(): ICacheFactory {            return Cache;        }        register.injectable(__CacheFactory, ICacheFactory, null, __FACTORY);        /**         * Used to manage all the defined caches for the current application session.         */        export interface ICacheFactory {            /**             * Method for creating a new ICache. Takes a generic type to denote the             * type of objects stored in the new ICache.  If the ICache already exists             * in the ICacheStatic, a new ICache will not be created.             *              * @param id The id of the new ICache.             * @param options ICacheOptions for customizing the ICache.             *              * @returns {ICache} The newly created ICache object.             */            create<T>(id: string, options?: ICacheOptions): ICache<T>;            /**             * Gets a cache out of the ICacheStatic if it exists.             *              * @param id The identifier used to search for the cache.             *              * @returns {ICache|undefined}             */            fetch<T>(id: string): ICache<T>;            /**             * Clears the ICacheStatic and all of its caches.             */            clear(): void;        }        /**         * The ICache interface describing a cache. Takes in a generic type         * corresponding to the type of objects stored in the cache.         */        export interface ICache<T> {            /**             * Method for accessing information about an ICache.             */            info(): ICacheInfo;            /**             * Method for inserting an object into an ICache.             *              * @param key The key to use for storage/retrieval of the object.             * @param value The value to store with the associated key.             *              * @returns {T} The value inserted into an ICache.             */            put(key: string, value: T): T;            /**             * Method for retrieving an object from an ICache.             *              * @param key The key to search for in an ICache.             *              * @returns {T|undefined} The value found at the associated key.              * Returns undefined for an ICache miss.             */            read(key: string): T;            /**             * Method for removing an object from an ICache.             *              * @param key The key to remove from an ICache.             */            remove(key: string): void;            /**             * Method for clearing an ICache, removing all of its keys.             */            clear(): void;            /**             * Method for removing an ICache from the $CacheFactory.             */            dispose(): void;        }        /**         * A cache for persisting NodeManager trees.         */        var managerCache = Cache.create<processing.INodeManager>('__managerCache');        /**         * The Type for referencing the '$ManagerCache' injectable as a dependency.         */        export function IManagerCache(): typeof managerCache {            return managerCache;        }        register.injectable(__ManagerCache, IManagerCache);        /**         * Options for a cache.         */        export interface ICacheOptions {            /**             * Specifies a timeout for a cache value. When a value              * is put in the cache, it will be valid for the given             * period of time (in milliseconds). After the timeout              * is reached, the value will automatically be removed             * from the cache.             */            timeout?: number;        }        /**         * Contains information about an ICache.         */        export interface ICacheInfo {            /**             * A unique id for the ICache object, used to              * retrieve the ICache out of the $CacheFactory.             */            id: string;            /**             * Represents the number of items in the ICache.             */            size: number;            /**             * Represents the ICacheOptions that the ICache is             * using.             */            options: ICacheOptions;        }        /**         * Used for caching compiled nodes. This class will         * clone a template when you put it in the cache. It will         * also clone the template when you retrieve it.         */        export class TemplateCache extends Cache<any> implements ITemplateCache {            $Promise: async.IPromise = acquire(__Promise);            constructor() {                super('__templateCache');            }            put(key: string, value: Node): async.IThenable<DocumentFragment>;            put(key: string, value: async.IThenable<Node>): async.IThenable<DocumentFragment>;            put(key: string, value: any): async.IThenable<DocumentFragment> {                super.put(key, this.$Promise.resolve<DocumentFragment>(value));                if (isDocumentFragment(value)) {                    value = value.cloneNode(true);                } else if (isNode(value)) {                    var fragment = document.createDocumentFragment();                    fragment.appendChild(value.cloneNode(true));                    value = fragment;                }                return this.$Promise.resolve<DocumentFragment>(value);            }            read(key: string): async.IThenable<DocumentFragment> {                var promise: async.IThenable<DocumentFragment> = super.read(key);                if (isNull(promise)) {                    return <any>this.$Promise.reject(null);                }                return promise.then((node) => {                    return this.put(key, node);                }, (error: Error) => {                    var $exception: IExceptionStatic = acquire(__ExceptionStatic);                    $exception.warn('Error retrieving template from promise.', $exception.TEMPLATE);                    return <DocumentFragment>null;                });            }        }        /**         * The Type for referencing the '$TemplateCache' injectable as a dependency.         */        export function ITemplateCache(): ITemplateCache {            return new TemplateCache();        }        register.injectable(__TemplateCache, ITemplateCache);        /**         * Interface for TemplateCache, used to manage all templates. Returns a unique template          * for every read, to avoid having to call cloneNode.         */        export interface ITemplateCache extends ICache<async.IThenable<DocumentFragment>> {            /**             * Stores a Node in the cache as a DocumentFragment.             *              * @param key The key used to store the value.             * @param value The Node.             */            put(key: string, value: Node): async.IThenable<DocumentFragment>;            /**             * Stores a Promise in the cache.             *              * @param key The key used to store the value.             * @param value The Promise.             */            put(key: string, value: async.IThenable<Node>): async.IThenable<DocumentFragment>;            /**             * Method for retrieving a Node from an ITemplateCache. The returned DocumentFragment will be              * cloned to avoid manipulating the cached template.              *              * @param key The key to search for in an ITemplateCache.             */            read(key: string): async.IThenable<DocumentFragment>;        }        /**         * A base class for storing data with a designated storage type.         */        export class BaseStorage implements IBaseStorage {            constructor() {                forEach((<Storage>(<any>this).__storage), (value, key) => {                    (<any>this)[key] = value;                });            }            get length(): number {                return (<Storage>(<any>this).__storage).length;            }            clear() {                (<Storage>(<any>this).__storage).clear();            }            getItem<T>(key: string): T {                return (<Storage>(<any>this).__storage).getItem(key);            }            key(index: number): string {                return (<Storage>(<any>this).__storage).key(index);            }            removeItem(key: string): void {                (<Storage>(<any>this).__storage).removeItem(key);            }            setItem(key: string, data: any): void {                (<Storage>(<any>this).__storage).setItem(key, data);                (<any>this)[key] = this.getItem(key);            }        }        /**         * An object designed for storing data with a designated storage type.         */        export interface IBaseStorage {            /**             * Returns the number of items in storage.             */            length: number;            /**             * Clears storage, deleting all of its keys.             */            clear(): void;            /**             * Gets an item out of storage with the assigned key.             *              * @param key The key of the item to retrieve from storage.             * @returns {T} The item retrieved from storage.             */            getItem<T>(key: string): T;            /**             * Allows for iterating over storage keys with an index. When             * called with an index, it will return the key at that index in              * storage.             *              * @param index The index used to retrieve the associated key.             * @returns {string} The key at the given index.             */            key(index: number): string;            /**             * Searches in storage for an item and removes it if it              * exists.             *              * @param key the Key of the item to remove from storage.             */            removeItem(key: string): void;            /**             * Adds data to storage with the designated key.             *              * @param key The key of the item to store in storage.             * @param data The data to store in storage with the key.             */            setItem(key: string, data: any): void;        }        /**         * A class used to wrap local storage into an injectable.         */        export class LocalStorage extends BaseStorage implements ILocalStorage {            /* tslint:disable:no-unused-variable */            private __storage: Storage = (<Window>acquire(__Window)).localStorage;            /* tslint:enable:no-unused-variable */        }        /**         * The Type for referencing the '$LocalStorage' injectable as a dependency.         */        export function ILocalStorage(): ILocalStorage {            return new LocalStorage();        }        register.injectable(__LocalStorage, ILocalStorage);        /**         * Describes an object used to wrap local storage into an injectable.         */        export interface ILocalStorage {            /**             * Returns the number of items in localStorage.             */            length: number;            /**             * Clears localStorage, deleting all of its keys.             */            clear(): void;            /**             * Gets an item out of local storage with the assigned key.             *              * @param key The key of the item to retrieve from localStorage.             * @returns {T} The item retrieved from localStorage.             */            getItem<T>(key: string): T;            /**             * Allows for iterating over localStorage keys with an index. When             * called with an index, it will return the key at that index in              * localStorage.             *              * @param index The index used to retrieve the associated key.             * @returns {string} The key at the given index.             */            key(index: number): string;            /**             * Searches in localStorage for an item and removes it if it              * exists.             *              * @param key the Key of the item to remove from localStorage.             */            removeItem(key: string): void;            /**             * Adds data to localStorage with the designated key.             *              * @param key The key of the item to store in localStorage.             * @param data The data to store in localStorage with the key.             */            setItem(key: string, data: any): void;        }        /**         * A class for wrapping SessionStorage as an injectable.         */        export class SessionStorage extends BaseStorage implements ISessionStorage {            /* tslint:disable:no-unused-variable */            private __storage: Storage = (<Window>acquire(__Window)).sessionStorage;            /* tslint:enable:no-unused-variable */        }        /**         * The Type for referencing the '$SessionStorage' injectable as a dependency.         */        export function ISessionStorage(): ISessionStorage {            return new SessionStorage();        }        register.injectable(__SessionStorage, ISessionStorage);        /**         * Describes an object used to wrap session storage into an injectable.         */        export interface ISessionStorage {            /**             * Returns the number of items in sessionStorage.             */            length: number;            /**             * Clears sessionStorage, deleting all of its keys.             */            clear(): void;            /**             * Gets an item out of session storage with the assigned key.             *              * @param key The key of the item to retrieve from sessionStorage.             * @returns {T} The item retrieved from sessionStorage.             */            getItem<T>(key: string): T;            /**             * Allows for iterating over sessionStorage keys with an index. When             * called with an index, it will return the key at that index in              * sessionStorage.             *              * @param index The index used to retrieve the associated key.             * @returns {string} The key at the given index.             */            key(index: number): string;            /**             * Searches in sessionStorage for an item and removes it if it              * exists.             *              * @param key the Key of the item to remove from sessionStorage.             */            removeItem(key: string): void;            /**             * Adds data to sessionStorage with the designated key.             *              * @param key The key of the item to store in sessionStorage.             * @param data The data to store in sessionStorage with the key.             */            setItem(key: string, data: any): void;        }    }    /* tslint:disable:no-unused-variable */    /**     * An object used to create ITokenDetails for every operator.     */    var OPERATORS: plat.IObject<plat.expressions.ITokenDetails> = {        'u+': {            precedence: 4, associativity: 'rtl',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any): any => +a(context, aliases)        },        '+': {            precedence: 6, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) + b(context, aliases)        },        'u-': {            precedence: 4, associativity: 'rtl',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any): any => -a(context, aliases)        },        '-': {            precedence: 6, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) - b(context, aliases)        },        '*': {            precedence: 5, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) * b(context, aliases)        },        '/': {            precedence: 5, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) / b(context, aliases)        },        '%': {            precedence: 5, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) % b(context, aliases)        },        '?': {            precedence: 15, associativity: 'rtl',            fn: (context: any, aliases: any): void => undefined        },        ':': {            precedence: 15, associativity: 'rtl',            fn: (context: any, aliases: any): void => undefined        },        '>': {            precedence: 8, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) > b(context, aliases)        },        '<': {            precedence: 8, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) < b(context, aliases)        },        '!': {            precedence: 4, associativity: 'rtl',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any): any => !a(context, aliases)        },        '~': {            precedence: 4, associativity: 'rtl',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any): any => ~a(context, aliases)        },        '&': {            precedence: 10, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) & b(context, aliases)        },        '|': {            precedence: 12, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) | b(context, aliases)        },        '>>': {            precedence: 7, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) >> b(context, aliases)        },        '<<': {            precedence: 7, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) << b(context, aliases)        },        '>>>': {            precedence: 7, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) >>> b(context, aliases)        },        '&&': {            precedence: 13, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) && b(context, aliases)        },        '||': {            precedence: 14, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) || b(context, aliases)        },        '==': {            precedence: 9, associativity: 'ltr',            /* tslint:disable:triple-equals */            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) == b(context, aliases)            /* tslint:enable:triple-equals */        },        '===': {            precedence: 9, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) === b(context, aliases)        },        '!=': {            precedence: 9, associativity: 'ltr',            /* tslint:disable:triple-equals */            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) != b(context, aliases)            /* tslint:enable:triple-equals */        },        '!==': {            precedence: 9, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) !== b(context, aliases)        },        '>=': {            precedence: 8, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) >= b(context, aliases)        },        '<=': {            precedence: 8, associativity: 'ltr',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): any => a(context, aliases) <= b(context, aliases)        },        '=': {            precedence: 17, associativity: 'rtl',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): void => {                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);                $exception.fatal('Assignment operators are not supported', $exception.PARSE);            }        },        '++': {            precedence: 3, associativity: '',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any): void => {                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);                $exception.fatal('Assignment operators are not supported', $exception.PARSE);            }        },        '--': {            precedence: 3, associativity: '',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any): void => {                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);                $exception.fatal('Assignment operators are not supported', $exception.PARSE);            }        },        '+=': {            precedence: 17, associativity: 'rtl',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): void => {                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);                $exception.fatal('Assignment operators are not supported', $exception.PARSE);            }        },        '-=': {            precedence: 17, associativity: 'rtl',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): void => {                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);                $exception.fatal('Assignment operators are not supported', $exception.PARSE);            }        },        '*=': {            precedence: 17, associativity: 'rtl',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): void => {                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);                $exception.fatal('Assignment operators are not supported', $exception.PARSE);            }        },        '/=': {            precedence: 17, associativity: 'rtl',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): void => {                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);                $exception.fatal('Assignment operators are not supported', $exception.PARSE);            }        },        '%=': {            precedence: 17, associativity: 'rtl',            fn: (context: any, aliases: any,                a: (context: any, aliases: any) => any,                b: (context: any, aliases: any) => any): void => {                var $exception: plat.IExceptionStatic = plat.acquire(__ExceptionStatic);                $exception.fatal('Assignment operators are not supported', $exception.PARSE);            }        }    };        /**     * An object used to create ITokenDetails for every accessor.     */    var ACCESSORS: plat.IObject<plat.expressions.ITokenDetails> = {        '()': { precedence: 2, associativity: null, fn: null },        '[]': { precedence: 2, associativity: null, fn: null },        '.': { precedence: 2, associativity: null, fn: null },        '{}': { precedence: 1, associativity: null, fn: null }    };        /**     * An object used to create ITokenDetails for every delimiter.     */    var DELIMITERS: plat.IObject<plat.expressions.ITokenDetails> = {        '{': { precedence: 1, associativity: null, fn: null },        '}': { precedence: 1, associativity: null, fn: null },        '[': { precedence: 2, associativity: null, fn: null },        ']': { precedence: 2, associativity: null, fn: null },        '(': { precedence: 2, associativity: null, fn: null },        ')': { precedence: 2, associativity: null, fn: null },        '.': { precedence: 2, associativity: null, fn: null },        ',': { precedence: 18, associativity: null, fn: null },        '\'': { precedence: 0, associativity: null, fn: null },        '"': { precedence: 0, associativity: null, fn: null }    };        /**     * An object used to get literal values from string values of false, true, and undefined     */    var KEYWORDS: plat.IObject<any> = {        false: false,        true: true,        null: null,        undefined: 'undefined'    };        /**     * Checks if a string is in the DELIMITERS array.     *      * @param key The string to index into the DELIMITERS array.     * @returns {Boolean}     */    function isDelimiter(key: string): boolean {        return !isNull(DELIMITERS[key]);    }        /**     * Checks if a string is in the ACCESSORS array.     *      * @param key The string to index into the ACCESSORS array.     * @returns {Boolean}     */    function isAccessor(key: string): boolean {        return !isNull(ACCESSORS[key]);    }        /**     * Checks if a string is in the OPERATORS array.     *      * @param key The string to index into the OPERATORS array.     * @returns {Boolean}     */    function isOperator(key: string): boolean {        return !isNull(OPERATORS[key]);    }        /**     * Checks if a string is in the KEYWORDS array.     *      * @param key The string to index into the KEYWORDS array.     * @returns {Boolean}     */    function isKeyword(key: string): boolean {        return !isUndefined(KEYWORDS[key]);    }    /* tslint:enable:no-unused-variable */        /**     * @name observable     * @memberof plat     * @kind namespace     *      * @description     * Holds all observable interfaces and classes.     */    export module observable {        var arrayMethods = ['push', 'pop', 'reverse', 'shift', 'sort', 'splice', 'unshift'];        /**         * Manages observable properties on control.         * Facilitates in data-binding and managing context inheritance.         */        export class ContextManager implements IContextManager {            /**             * A set of functions to be fired when a particular observed array is mutated.             */            static observedArrayListeners: IObject<IObject<Array<(ev: IArrayMethodInfo<any>) => void>>> = {};            /**             * Gets the ContextManager associated to the given control. If no              * ContextManager exists, one is created for that control.             *              * @static             * @param control The control on which to locate the ContextManager             */            static getManager(control: IControl): IContextManager;            static getManager(control: any): IContextManager {                var contextManager: IContextManager,                    managers = ContextManager.__managers,                    uid = control.uid,                    manager = managers[uid];                if (!isNull(manager)) {                    contextManager = manager;                    return contextManager;                }                contextManager = managers[uid] = new ContextManager();                contextManager.context = control;                return contextManager;            }            /**             * Removes all the listeners for a given control's uid.             *              * @static             * @param control The control whose manager is being disposed.             * @param persist Whether or not the control's context needs to              * be persisted post-disposal or can be set to null.             */            static dispose(control: IControl, persist?: boolean): void;            static dispose(control: ui.ITemplateControl, persist?: boolean) {                if (isNull(control)) {                    return;                }                var uid = control.uid,                    controls = ContextManager.__controls,                    identifiers = controls[uid] || {},                    managers = ContextManager.__managers,                    manager = managers[uid];                if (!isNull(manager)) {                    manager.dispose();                    deleteProperty(managers, uid);                }                var keys = Object.keys(identifiers),                    identifier: string,                    listeners: Array<IRemoveListener>;                while (keys.length > 0) {                    identifier = keys.shift();                    listeners = identifiers[identifier];                    while (listeners.length > 0) {                        listeners.shift()();                    }                }                var arrayListeners = ContextManager.observedArrayListeners,                    remove = ContextManager.removeArrayListeners;                keys = Object.keys(arrayListeners);                length = keys.length;                for (var i = 0; i < length; ++i) {                    remove(keys[i], uid);                }                deleteProperty(controls, uid);                if (!isNull(control.context)) {                    ContextManager.defineProperty(control, 'context', persist ? _clone(control.context, true) : null, true, true);                }            }            /**             * Removes all listeners for an Array associated with a given uid.             *              * @static             * @param absoluteIdentifier The identifier used to locate the array.             * @param uid The uid used to search for listeners.             */            static removeArrayListeners(absoluteIdentifier: string, uid: string): void {                var listeners = ContextManager.observedArrayListeners[absoluteIdentifier];                if (!isNull(listeners)) {                    deleteProperty(listeners, uid);                }            }            /**             * Safely retrieves the local context given a root context and an Array of             * property strings.             *              * @static             * @param rootContext The root object in which to find a local context.             * @param split The string array containing properties used to index into             * the rootContext.             */            static getContext(rootContext: any, split: Array<string>): any {                if (isNull(rootContext)) {                    return rootContext;                }                split = split.slice(0);                while (split.length > 0) {                    rootContext = rootContext[split.shift()];                    if (isNull(rootContext)) {                        return rootContext;                    }                }                return rootContext;            }            /**             * Defines an object property with the associated value. Useful for unobserving objects.             *              * @param obj The object on which to define the property.             * @param key The property key.             * @param value The value used to define the property.             * @param enumerable Whether or not the property should be enumerable (able to be iterated              * over in a loop)             * @param configurable Whether or not the property is able to be reconfigured.             */            static defineProperty(obj: any, key: string, value: any, enumerable?: boolean, configurable?: boolean): void {                Object.defineProperty(obj, key, {                    value: value,                    enumerable: !!enumerable,                    configurable: !!configurable                });            }            /**             * Defines an object property with only a getter function. Useful for creating constant values              * or overwriting constant values.             *              * @param obj The object on which to define the property.             * @param key The property key.             * @param value The value used to define the property.             * @param enumerable Whether or not the property should be enumerable (able to be iterated              * over in a loop)             * @param configurable Whether or not the property is able to be reconfigured.             */            static defineGetter(obj: any, key: string, value: any, enumerable?: boolean, configurable?: boolean): void {                Object.defineProperty(obj, key, {                    get: () => value,                    enumerable: !!enumerable,                    configurable: !!configurable                });            }            /**             * Pushes the function for removing an observed property upon adding the property.             *              * @static             * @param identifer The identifier for which the remove listener is being pushed.             * @param uid The uid of the control observing the identifier.             * @param listener The function for removing the observed property.             */            static pushRemoveListener(identifier: string, uid: string, listener: IRemoveListener) {                var controls = ContextManager.__controls,                    control = controls[uid],                    listeners: Array<IRemoveListener>;                if (isNull(control)) {                    control = controls[uid] = {};                }                listeners = control[identifier];                if (isNull(listeners)) {                    listeners = control[identifier] = [];                }                listeners.push(listener);            }            /**             * Removes a specified identifier from being observed for a given set of control uids.             *              * @static             * @param uids The set of uids for which to remove the specified identifier.             * @param identifier The identifier to stop observing.             */            static removeIdentifier(uids: Array<string>, identifier: string): void {                var length = uids.length,                    controls = ContextManager.__controls,                    uid: string,                    identifiers: IObject<Array<IRemoveListener>>;                for (var i = 0; i < length; ++i) {                    uid = uids[i];                    identifiers = controls[uid];                    if (isNull(identifiers)) {                        continue;                    }                    deleteProperty(identifiers, identifier);                }            }            /**             * Ensures that an identifier path will exist on a given control. Will create              * objects/arrays if necessary.             *              * @param control The control on which to create the context.             * @param identifier The period-delimited identifier string used to create              * the context path.             */            static createContext(control: ui.ITemplateControl, identifier: string) {                var split = identifier.split('.'),                    property: string,                    temp: any,                    context = control.context;                if (!isObject(context)) {                    if (isNull(context)) {                        context = control.context = {};                    } else {                        var Exception: IExceptionStatic = acquire(__ExceptionStatic);                        Exception.warn('A child control is trying to create a child context that has ' +                            'a parent control with a primitive type context', Exception.BIND);                        return {};                    }                }                while (split.length > 0) {                    property = split.shift();                    temp = context[property];                    if (isNull(temp)) {                        if (isNumber(Number(split[0]))) {                            temp = context[property] = [];                        } else {                            temp = context[property] = {};                        }                    }                    context = temp;                }                return context;            }            private static __managers: IObject<IContextManager> = {};            private static __controls: IObject<IObject<Array<IRemoveListener>>> = {};            $Compat: ICompat = acquire(__Compat);            context: any;            private __identifiers: IObject<Array<IListener>> = {};            private __identifierHash: IObject<Array<string>> = {};            private __lengthListeners: IObject<IListener> = {};            private __contextObjects: IObject<any> = {};            private __isArrayFunction: boolean = false;            private __observedIdentifier: string;            getContext(split: Array<string>): any {                var join = split.join('.'),                    context = this.__contextObjects[join];                if (isNull(context)) {                    context = this.__contextObjects[join] = this._getImmediateContext(join);                }                return context;            }            observe(absoluteIdentifier: string, observableListener: IListener): IRemoveListener {                if (isEmpty(absoluteIdentifier)) {                    return noop;                }                var split = absoluteIdentifier.split('.'),                    key = split.pop(),                    context = this.context,                    hasIdentifier = this._hasIdentifier(absoluteIdentifier),                    hasObservableListener = !isNull(observableListener),                    join = key;                if (split.length > 0) {                    join = split.join('.');                    context = this.__contextObjects[join];                    if (isNull(context)) {                        context = this.__contextObjects[join] = this._getImmediateContext(join);                    }                }                if (!isObject(context)) {                    if (hasObservableListener) {                        if (key === 'length') {                            this.__lengthListeners[absoluteIdentifier] = observableListener;                            ContextManager.pushRemoveListener(absoluteIdentifier, uid, () => {                                deleteProperty(this.__lengthListeners, absoluteIdentifier);                            });                        }                        return this._addObservableListener(absoluteIdentifier, observableListener);                    }                    return noop;                }                // set observedIdentifier to null                this.__observedIdentifier = null;                this.__contextObjects[absoluteIdentifier] = context[key];                // if observedIdentifier is not null, the primitive is already being watched                var observedIdentifier = this.__observedIdentifier,                    isObserved = !isNull(observedIdentifier),                    removeCallback = noop;                if (isObserved) {                    hasIdentifier = true;                }                if (hasObservableListener) {                    var removeObservedCallback = noop,                        removeAbsoluteCallback = this._addObservableListener(absoluteIdentifier, observableListener);                    if (isObserved && absoluteIdentifier !== observedIdentifier) {                        removeObservedCallback = this._addObservableListener(observedIdentifier, observableListener);                    }                    removeCallback = () => {                        removeAbsoluteCallback();                        removeObservedCallback();                    };                }                // check if value is defined and context manager hasn't seen this identifier                if (!hasIdentifier) {                    if (key === 'length' && isArray(context)) {                        var property = split.pop(),                            parentContext = this.getContext(split),                            uid = observableListener.uid;                        this.__observedIdentifier = null;                        access(parentContext, property);                        if (isString(this.__observedIdentifier)) {                            join = this.__observedIdentifier;                        }                        var removeObservableListener = removeCallback,                            removeListener = this.observeArray(uid, noop, join, context, null),                            removeArrayObserve = this.observe(join, {                                uid: uid,                                listener: (newValue: Array<any>, oldValue: Array<any>) => {                                    removeListener();                                    removeListener = this.observeArray(uid, noop, join, newValue, oldValue);                                }                            });                        removeCallback = () => {                            removeObservableListener();                            removeArrayObserve();                            removeListener();                        };                    } else {                        this._define(absoluteIdentifier, context, key);                    }                }                return removeCallback;            }            observeArray(uid: string, listener: (ev: IArrayMethodInfo<any>) => void,                absoluteIdentifier: string, array: Array<any>, oldArray: Array<any>): IRemoveListener {                var length = arrayMethods.length,                    method: string,                    i: number,                    $compat = this.$Compat,                    proto = $compat.proto,                    setProto = $compat.setProto;                if (isArray(oldArray)) {                    if (setProto) {                        (<any>Object).setPrototypeOf(oldArray, Object.create(Array.prototype));                    } else if (proto) {                        (<any>oldArray).__proto__ = Object.create(Array.prototype);                    } else {                        length = arrayMethods.length;                        for (i = 0; i < length; ++i) {                            method = arrayMethods[i];                            (<any>oldArray)[method] = (<any>Array.prototype)[method];                        }                    }                }                if (isNull(array)) {                    return noop;                }                var split = absoluteIdentifier.split('.'),                    property = split.pop(),                    context = this.getContext(split);                this.__observedIdentifier = null;                access(context, property);                if (isString(this.__observedIdentifier)) {                    absoluteIdentifier = this.__observedIdentifier;                }                var observedArrayCallbacks = ContextManager.observedArrayListeners[absoluteIdentifier];                if (isNull(observedArrayCallbacks)) {                    observedArrayCallbacks = ContextManager.observedArrayListeners[absoluteIdentifier] = {};                }                var arrayCallbacks = observedArrayCallbacks[uid];                if (isNull(arrayCallbacks)) {                    arrayCallbacks = observedArrayCallbacks[uid] = [];                }                var removeListener = () => {                    arrayCallbacks.splice(arrayCallbacks.indexOf(listener), 1);                };                arrayCallbacks.push(listener);                if (proto) {                    var obj = Object.create(Array.prototype);                    for (i = 0; i < length; ++i) {                        method = arrayMethods[i];                        obj[method] = this._overwriteArrayFunction(absoluteIdentifier, method);                    }                    if (setProto) {                        (<any>Object).setPrototypeOf(array, obj);                    } else {                        (<any>array).__proto__ = obj;                    }                    return removeListener;                }                for (i = 0; i < length; ++i) {                    method = arrayMethods[i];                    ContextManager.defineProperty(array, method,                        this._overwriteArrayFunction(absoluteIdentifier, method), false, true);                }                return removeListener;            }            dispose(): void {                this.context = null;                this.__identifiers = {};                this.__identifierHash = {};                this.__contextObjects = {};            }            /**             * Gets the immediate context of identifier by splitting on '.'              * and observes the objects along the way.             *              * @param identifier The identifier being observed.             */            _getImmediateContext(identifier: string): any {                if (isNull(this.__identifiers[identifier])) {                    this.observe(identifier, null);                }                var split = identifier.split('.'),                    context = this.context;                while (split.length > 0) {                    context = context[split.shift()];                    if (isNull(context)) {                        break;                    }                }                return context;            }            /**             * Obtains the old value and new value of a given context              * property on a property changed event.             *              * @param split The split identifier of the property that changed.             * @param newRootContext The new context.             * @param oldRootContext The old context.             */            _getValues(split: Array<string>, newRootContext: any, oldRootContext: any): { newValue: any; oldValue: any; } {                var property: string,                    doNew = true,                    doOld = true;                while (split.length > 1) {                    property = split.shift();                    if (doNew) {                        newRootContext = newRootContext[property];                        if (isNull(newRootContext)) {                            doNew = false;                        }                    }                    if (doOld) {                        oldRootContext = oldRootContext[property];                        if (isNull(oldRootContext)) {                            doOld = false;                        }                    }                    if (!(doNew || doOld)) {                        return null;                    }                }                property = split[0];                var newValue: any,                    oldValue: any;                if (!isNull(newRootContext)) {                    newValue = newRootContext[property];                }                if (!isNull(oldRootContext)) {                    oldValue = oldRootContext[property];                }                return {                    newValue: newValue,                    oldValue: oldValue                };            }            /**             * Notifies all child properties being observed that a parent property              * has changed.             *              * @param identifier The identifier for the property that changed.             * @param newValue The new value of the property.             * @param oldValue The old value of the property.             */            _notifyChildProperties(identifier: string, newValue: any, oldValue: any): void {                var mappings = this.__identifierHash[identifier];                if (isNull(mappings)) {                    return;                }                var length = mappings.length,                    binding: string,                    property: string,                    parentProperty: string,                    split: Array<string>,                    values: IObject<any> = {},                    value: any,                    key: string,                    start = identifier.length + 1,                    newParent: any,                    oldParent: any,                    newChild: any,                    oldChild: any;                if (length === 0) {                    deleteProperty(this.__identifierHash, identifier);                    return;                }                for (var i = 0; i < length; ++i) {                    binding = mappings[i];                    property = binding.slice(start);                    split = property.split('.');                    key = split.pop();                    parentProperty = split.join('.');                    if (isEmpty(parentProperty)) {                        newParent = newValue;                        oldParent = oldValue;                        newChild = isNull(newParent) ? undefined : newParent[key];                        oldChild = isNull(oldParent) ? undefined : oldParent[key];                        if (key === 'length' && !isArray(oldParent) && isArray(newParent)) {                            var lengthListener = this.__lengthListeners[binding];                            if (!isNull(lengthListener)) {                                var uid = lengthListener.uid,                                    arraySplit = identifier.split('.'),                                    arrayKey = arraySplit.pop(),                                    arrayParent = this.getContext(arraySplit),                                    join: string;                                this.__observedIdentifier = null;                                access(arrayParent, arrayKey);                                join = isString(this.__observedIdentifier) ? this.__observedIdentifier : arraySplit.join('.');                                var removeListener = this.observeArray(uid, noop, join, newParent, null);                                this.observe(join, {                                    uid: uid,                                    listener: (nValue: Array<any>, oValue: Array<any>) => {                                        removeListener();                                        removeListener = this.observeArray(uid, noop, join, nValue, oValue);                                    }                                });                                deleteProperty(this.__lengthListeners, binding);                            }                        }                    } else {                        value = values[parentProperty];                        if (isNull(value)) {                            value = values[parentProperty] = this._getValues(split, newValue, oldValue);                            if (isNull(value)) {                                this._execute(binding, null, null);                                continue;                            }                        }                        newParent = value.newValue;                        oldParent = value.oldValue;                        newChild = isNull(newParent) ? undefined : newParent[key];                        oldChild = isNull(oldParent) ? undefined : oldParent[key];                    }                    values[property] = {                        newValue: newChild,                        oldValue: oldChild                    };                    if (isObject(newParent) && (!isArray(newParent) || newParent.length > key)) {                        this._define(binding, newParent, key);                    }                    this._execute(binding, newChild, oldChild);                }                values = null;            }            /**             * Adds a listener to be fired for a particular identifier.             *              * @param absoluteIdentifier The identifier being observed.             * @param observableListener The function and associated uid to be fired              * for this identifier.             */            _addObservableListener(absoluteIdentifier: string, observableListener: IListener): IRemoveListener {                var uid = observableListener.uid,                    remove = () => {                        this._removeCallback(absoluteIdentifier, observableListener);                    },                    split = absoluteIdentifier.split('.'),                    property = split.pop(),                    isLength = property === 'length',                    context: any;                if (isLength) {                    property = split.pop();                    context = this.getContext(split);                }                if (isObject(context)) {                    this.__observedIdentifier = null;                    access(context, property);                    if (isString(this.__observedIdentifier)) {                        absoluteIdentifier = this.__observedIdentifier + (isLength ? '.length' : '');                    }                }                this.__add(absoluteIdentifier, observableListener);                ContextManager.pushRemoveListener(absoluteIdentifier, uid, remove);                return remove;            }            /**             * Observes a property on a given context specified by an identifier.             *              * @param identifier The full identifier path for the property being observed.             * @param immediateContext The object whose property will be observed.             * @param key The property key for the value on the immediateContext that's              * being observed.             */            _define(identifier: string, immediateContext: any, key: string): void {                var value = immediateContext[key];                if (isObject(value)) {                    this.__defineObject(identifier, immediateContext, key);                } else {                    this.__definePrimitive(identifier, immediateContext, key);                }            }            /**             * Intercepts an array function for observation.             *              * @param absoluteIdentifier The full identifier path for the observed array.             * @param method The array method being called.             */            _overwriteArrayFunction(absoluteIdentifier: string, method: string): (...args: any[]) => any {                var callbackObjects = ContextManager.observedArrayListeners[absoluteIdentifier],                    _this = this;                // we can't use a fat-arrow function here because we need the array context.                return function observedArrayFn(...args: any[]) {                    var oldArray = this.slice(0),                        returnValue: any,                        isShift = method.indexOf('shift') !== -1;                    if (isShift) {                        _this.__isArrayFunction = true;                        returnValue = (<any>Array.prototype)[method].apply(this, args);                        _this.__isArrayFunction = false;                    } else {                        returnValue = (<any>Array.prototype)[method].apply(this, args);                    }                    var keys = Object.keys(callbackObjects),                        length = keys.length,                        callbacks: Array<(ev: IArrayMethodInfo<any>) => void>,                        jLength: number;                    for (var i = 0; i < length; ++i) {                        callbacks = callbackObjects[keys[i]];                        jLength = callbacks.length;                        for (var j = 0; j < jLength; ++j) {                            callbacks[j]({                                method: method,                                returnValue: returnValue,                                oldArray: oldArray,                                newArray: this,                                arguments: args                            });                        }                    }                    if (isShift) {                        _this._notifyChildProperties(absoluteIdentifier, this, oldArray);                    } else if (oldArray.length !== this.length) {                        _this._execute(absoluteIdentifier + '.length', this.length, oldArray.length);                    }                    return returnValue;                };            }            /**             * Removes a single listener callback             *              * @param identifier The identifier attached to the callbacks.             * @param listener The observable listener to remove.             */            _removeCallback(identifier: string, listener: IListener): void {                var callbacks = this.__identifiers[identifier];                if (isNull(callbacks)) {                    return;                }                // splice the observed listener                callbacks.splice(callbacks.indexOf(listener), 1);                if (isEmpty(this.__identifiers[identifier])) {                    deleteProperty(this.__identifierHash, identifier);                    deleteProperty(this.__contextObjects, identifier);                }            }            /**             * Checks if the specified identifier is already being              * observed in this context.             *              * @param identifier The identifier being observed.             */            _hasIdentifier(identifier: string): boolean {                return !isEmpty(this.__identifiers[identifier]);            }            /**             * Executes the listeners for the specified identifier on              * this context.             *              * @param identifier The identifier attached to the callbacks.             * @param value The new value on this context specified by              * the identifier.             * @param oldValue The old value on this context specified by              * the identifier.             */            _execute(identifier: string, value: any, oldValue: any): void {                var observableListeners = this.__identifiers[identifier];                if (isUndefined(value)) {                    deleteProperty(this.__contextObjects, identifier);                } else {                    this.__contextObjects[identifier] = value;                }                if (isNull(observableListeners)) {                    return;                }                for (var i = 0; i < observableListeners.length; ++i) {                    observableListeners[i].listener(value, oldValue);                }            }            private __defineObject(identifier: string, immediateContext: any, key: string): void {                var value = immediateContext[key];                Object.defineProperty(immediateContext, key, {                    configurable: true,                    enumerable: true,                    get: () => {                        this.__observedIdentifier = identifier;                        return value;                    },                    set: (newValue) => {                        if (value === newValue) {                            return;                        }                        var oldValue = value;                        value = newValue;                        if (this.__isArrayFunction) {                            return;                        }                        var hash = this.__identifierHash[identifier],                            childPropertiesLength = isArray(hash) ? hash.length : 0;                        this._execute(identifier, value, oldValue);                        if (childPropertiesLength > 0) {                            this._notifyChildProperties(identifier, value, oldValue);                        }                        if (!isObject(value)) {                            this.__definePrimitive(identifier, immediateContext, key);                        }                    }                });            }            private __definePrimitive(identifier: string, immediateContext: any, key: string): void {                var value = immediateContext[key],                    isDefined = !isNull(value);                if (isArray(immediateContext) && key === 'length') {                    return;                }                Object.defineProperty(immediateContext, key, {                    configurable: true,                    enumerable: true,                    get: () => {                        this.__observedIdentifier = identifier;                        return value;                    },                    set: (newValue) => {                        if (value === newValue) {                            return;                        }                        var oldValue = value;                        value = newValue;                        if (this.__isArrayFunction && isArray(immediateContext)) {                            return;                        }                        if (isObject(value)) {                            var childPropertiesLength = this.__identifierHash[identifier].length;                            this._execute(identifier, newValue, oldValue);                            this.__defineObject(identifier, immediateContext, key);                            if (childPropertiesLength > 0) {                                this._notifyChildProperties(identifier, newValue, oldValue);                            }                        } else if (isDefined) {                            this._execute(identifier, newValue, oldValue);                        } else {                            this._execute(identifier, newValue, oldValue);                            this.__definePrimitive(identifier, immediateContext, key);                            isDefined = true;                        }                    }                });            }            private __add(identifier: string, observableListener: IListener): void {                var callbacks = this.__identifiers[identifier];                if (isNull(callbacks)) {                    callbacks = this.__identifiers[identifier] = [];                }                callbacks.push(observableListener);                this.__addHashValues(identifier);            }            private __addHashValues(identifier: string) {                var split = identifier.split('.'),                    ident = split.shift(),                    hashValue = this.__identifierHash[ident];                if (isNull(hashValue)) {                    hashValue = this.__identifierHash[ident] = [];                    if (split.length === 0) {                        return;                    }                }                if (ident !== identifier && hashValue.indexOf(identifier) === -1) {                    hashValue.push(identifier);                }                while (split.length > 0) {                    ident += '.' + split.shift();                    hashValue = this.__identifierHash[ident];                    if (isNull(hashValue)) {                        hashValue = this.__identifierHash[ident] = [];                        if (ident !== identifier) {                            hashValue.push(identifier);                        }                    } else if (ident !== identifier && hashValue.indexOf(identifier) === -1) {                        hashValue.push(identifier);                    }                }            }        }        /**         * The Type for referencing the '$ContextManagerStatic' injectable as a dependency.         */        export function IContextManagerStatic(): IContextManagerStatic {            return ContextManager;        }        register.injectable(__ContextManagerStatic, IContextManagerStatic, null, __STATIC);        /**         * The external interface for the '$ContextManagerStatic' injectable.         */        export interface IContextManagerStatic {            /**             * A set of functions to be fired when a particular observed array is mutated.             *              * @static             */            observedArrayListeners: IObject<IObject<Array<(ev: IArrayMethodInfo<any>) => void>>>;            /**             * Gets the ContextManager associated to the given control. If no              * ContextManager exists, one is created for that control.             *              * @static             * @param control The control on which to locate the ContextManager             */            getManager(control: IControl): IContextManager;            getManager(control: any): IContextManager;            /**             * Removes all the listeners for a given control's uid.             *              * @static             * @param control The control whose manager is being disposed.             * @param persist Whether or not the control's context needs to              * be persisted post-disposal or can be set to null.             */            dispose(control: IControl, persist?: boolean): void;            /**             * Removes all listeners for an Array associated with a given uid.             *              * @static             * @param absoluteIdentifier The identifier used to locate the array.             * @param uid The uid used to search for listeners.             */            removeArrayListeners(absoluteIdentifier: string, uid: string): void;            /**             * Safely retrieves the local context given a root context and an Array of             * property strings.             *              * @static             * @param rootContext The root object in which to find a local context.             * @param split The string array containing properties used to index into             * the rootContext.             */            getContext(rootContext: any, split: Array<string>): void;            /**             * Defines an object property with the associated value. Useful for unobserving objects.             *              * @static             * @param obj The object on which to define the property.             * @param key The property key.             * @param value The value used to define the property.             * @param enumerable Whether or not the property should be enumerable (able to be iterated              * over in a loop)             * @param configurable Whether or not the property is able to be reconfigured.             */            defineProperty(obj: any, key: string, value: any, enumerable?: boolean, configurable?: boolean): void;            /**             * Defines an object property as a getter with the associated value. Useful for unobserving objects.             *              * @static             * @param obj The object on which to define the property.             * @param key The property key.             * @param value The value used to define the property.             * @param enumerable Whether or not the property should be enumerable (able to be iterated              * over in a loop)             * @param configurable Whether or not the property is able to be reconfigured.             */            defineGetter(obj: any, key: string, value: any, enumerable?: boolean, configurable?: boolean): void;            /**             * Pushes the function for removing an observed property upon adding the property.             *              * @static             * @param identifer The identifier for which the remove listener is being pushed.             * @param uid The uid of the control observing the identifier.             * @param listener The function for removing the observed property.             */            pushRemoveListener(identifier: string, uid: string, listener: IRemoveListener): void;            /**             * Removes a specified identifier from being observed for a given set of control uids.             *              * @static             * @param uids The set of uids for which to remove the specified identifier.             * @param identifier The identifier to stop observing.             */            removeIdentifier(uids: Array<string>, identifier: string): void;            /**             * Ensures that an identifier path will exist on a given control. Will create             * objects/arrays if necessary.             *              * @static             * @param control The control on which to create the context.             * @param identifier The period-delimited identifier string used to create             * the context path.             */            createContext(control: ui.ITemplateControl, identifier: string): any;        }        /**         * Describes an object that manages observing properties on any object.         */        export interface IContextManager {            /**             * The context to be managed.             */            context: any;            /**             * Safely retrieves the local context for this ContextManager given an Array of             * property strings.             *              * @param split The string array containing properties used to index into             * the context.             */            getContext(split: Array<string>): any;            /**             * Given a period-delimited identifier, observes an object and calls the given listener when the              * object changes.             *              * @param absoluteIdentifier The period-delimited identifier noting the property to be observed.             * @param observableListener An object implmenting IObservableListener. The listener will be              * notified of object changes.             */            observe(identifier: string, observableListener: IListener): IRemoveListener;            /**             * Observes an array and calls the listener when certain functions are called on              * that array. The watched functions are push, pop, shift, splice, unshift, sort,              * and reverse.             *              * @param uid The uid of the object observing the array.             * @param listener The callback for when an observed Array function has been called.             * @param absoluteIdentifier The identifier from the root context used to find the array.             * @param array The array to be observed.             * @param oldArray The old array to stop observing.             */            observeArray(uid: string, listener: (ev: IArrayMethodInfo<any>) => void,                absoluteIdentifier: string, array: Array<any>, oldArray: Array<any>): IRemoveListener;            /**             * Disposes the memory for an IContextManager.             */            dispose(): void;        }        /**         * An object specifying a listener callback function and a unique id to use to manage the         * listener.         */        export interface IListener {            /**             * A listener method called when the object it is observing is changed.             *              * @param value The new value of the object.             * @param oldValue The previous value of the object.             */            listener(value: any, oldValue: any): void;            /**             * A unique id used to manage the listener.             */            uid: string;        }        /**         * An object for Array method info. Takes a          * generic type to denote the type of array it uses.         */        export interface IArrayMethodInfo<T> {            /**             * The method name that was called. Possible values are:             * 'push', 'pop', 'reverse', 'shift', 'sort', 'splice',              * and 'unshift'             */            method: string;            /**             * The value returned from the called function.             */            returnValue: any;            /**             * The previous value of the array.             */            oldArray: Array<T>;            /**             * The new value of the array.             */            newArray: Array<T>;            /**             * The arguments passed into the array function.             */            arguments: Array<any>;        }            /**             * @name IObservableProperty             * @memberof plat.observable             * @access public             * @kind interface             *              * @description             * Defines the object added to a template control when its element              * has an attribute control that extends {@link plat.controls.ObservableAttributeControl|ObservableAttributeControl}.             *              * This will contain the value of the expression as well as a way to observe the              * attribute value for changes.             *              * @remarks             * {@link plat.controls.Option|plat-options} is a control that implements this interface, and puts an 'options'              * property on its associated template control.             *              * The generic type corresponds to the type of object created when the attribute              * expression is evaluated.             *              * @typeparam {any} T The type of the value obtained from the attribute's expression.             */            export interface IObservableProperty<T> {                /**                 * @name value                 * @memberof plat.observable.IObservableProperty                 * @access public                 * @kind property                 *                  * @type {T}                 *                  * @description                 * The value obtained from evaluating the attribute's expression.                 */                value: T;                /**                 * @name observe                 * @memberof plat.observable.IObservableProperty                 * @access public                 * @kind function                 *                  * @description                 * A method for observing the attribute for changes.                 *                  * @param {(newValue: T, oldValue: T) => void} listener The listener callback which will be pre-bound to the                  * template control.                 *                  * @returns {plat.IRemoveListener} A method for removing the listener.                 */                observe(listener: (newValue: T, oldValue: T) => void): IRemoveListener;            }    }        /**     * @name events     * @memberof plat     * @kind namespace     *      * @description     * Holds classes and interfaces related to event management.     */    export module events {        /**         * @name DispatchEvent         * @memberof plat.events         * @kind class         * @access public         *          * @implements {plat.events.IDispatchEventInstance}         *          * @description         * An event class that propagates through a control tree.          * Propagation of the event always starts at the sender, allowing a control to both          * initialize and consume an event. If a consumer of an event throws an error while          * handling the event it will be logged to the app using exception.warn. Errors will          * not stop propagation of the event.         */        export class DispatchEvent implements IDispatchEventInstance {            /**             * @name $EventManagerStatic             * @memberof plat.events.DispatchEvent             * @kind property             * @access public             *              * @type {plat.events.IEventManagerStatic}             *              * @description             * Reference to the {@link plat.events.IEventManagerStatic|IEventManagerStatic} injectable.             */            $EventManagerStatic: IEventManagerStatic = acquire(__EventManagerStatic);            /**             * @name sender             * @memberof plat.events.DispatchEvent             * @kind property             * @access public             *              * @type {any}             *              * @description             * The object that initiated the event.             */            sender: any;            /**             * @name name             * @memberof plat.events.DispatchEvent             * @kind property             * @access public             *              * @type {string}             *              * @description             * The name of the event.             */            name: string;            /**             * @name direction             * @memberof plat.events.DispatchEvent             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event direction this object is using for propagation.             */            direction: string;            /**             * @name initialize             * @memberof plat.events.DispatchEvent             * @kind function             * @access public             * @variation 0             *              * @description             * Initializes the event, populating its public properties.             *              * @param {string} name The name of the event.             * @param {any} sender The object that initiated the event.             * @param {string} direction='up' Equivalent to {@link plat.events.EventManager.UP|EventManager.UP}.             *              * @returns {void}             */            initialize(name: string, sender: any, direction?: 'up'): void;            /**             * @name initialize             * @memberof plat.events.DispatchEvent             * @kind function             * @access public             * @variation 1             *              * @description             * Initializes the event, populating its public properties.             *              * @param {string} name The name of the event.             * @param {any} sender The object that initiated the event.             * @param {string} direction='down' Equivalent to {@link plat.events.EventManager.DOWN|EventManager.DOWN}.             *              * @returns {void}             */            initialize(name: string, sender: any, direction?: 'down'): void;            /**             * @name initialize             * @memberof plat.events.DispatchEvent             * @kind function             * @access public             * @variation 2             *              * @description             * Initializes the event, populating its public properties.             *              * @param {string} name The name of the event.             * @param {any} sender The object that initiated the event.             * @param {string} direction='direct' Equivalent to {@link plat.events.EventManager.DIRECT|EventManager.DIRECT}.             *              * @returns {void}             */            initialize(name: string, sender: any, direction?: 'direct'): void;            /**             * @name initialize             * @memberof plat.events.DispatchEvent             * @kind function             * @access public             * @variation 3             *              * @description             * Initializes the event, populating its public properties.             *              * @param {string} name The name of the event.             * @param {any} sender The object that initiated the event.             * @param {string} direction The direction of propagation             *              * @returns {void}             */            initialize(name: string, sender: any, direction?: string): void;            initialize(name: string, sender: any, direction?: string) {                this.name = name;                this.direction = direction || this.$EventManagerStatic.DIRECT;                this.sender = sender;            }            /**             * @name stopPropagation             * @memberof plat.events.DispatchEvent             * @kind function             * @access public             *              * @description             * Call this method to halt the propagation of an upward-moving event.             * Downward events cannot be stopped with this method.             *              * @returns {void}             */            stopPropagation(): void {                if (this.direction === this.$EventManagerStatic.UP) {                    (<any>this.$EventManagerStatic.propagatingEvents)[this.name] = false;                }            }        }        /**         * The Type for referencing the '$DispatchEventInstance' injectable as a dependency.         */        export function IDispatchEventInstance(): IDispatchEventInstance {            return new DispatchEvent();        }        register.injectable(__DispatchEventInstance, IDispatchEventInstance, null, __INSTANCE);        /**         * @name IDispatchEventInstance         * @memberof plat.events         * @kind interface         * @access public         *          * @description         * Describes an event that propagates through a control tree.          * Propagation of the event always starts at the sender, allowing a control to both          * initialize and consume an event. If a consumer of an event throws an error while          * handling the event it will be logged to the app using exception.warn. Errors will          * not stop propagation of the event.         */        export interface IDispatchEventInstance {            /**             * @name sender             * @memberof plat.events.IDispatchEventInstance             * @kind property             * @access public             *              * @type {any}             *              * @description             * The object that initiated the event.             */            sender: any;            /**             * @name name             * @memberof plat.events.IDispatchEventInstance             * @kind property             * @access public             *              * @type {string}             *              * @description             * The name of the event.             */            name: string;            /**             * @name direction             * @memberof plat.events.IDispatchEventInstance             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event direction this object is using for propagation.             */            direction: string;            /**             * @name initialize             * @memberof plat.events.IDispatchEventInstance             * @kind function             * @access public             * @variation 0             *              * @description             * Initializes the event, populating its public properties.             *              * @param {string} name The name of the event.             * @param {any} sender The object that initiated the event.             * @param {string} direction='up' Equivalent to {@link plat.events.EventManager.UP|EventManager.UP}.             *              * @returns {void}             */            initialize(name: string, sender: any, direction?: 'up'): void;            /**             * @name initialize             * @memberof plat.events.IDispatchEventInstance             * @kind function             * @access public             * @variation 1             *              * @description             * Initializes the event, populating its public properties.             *              * @param {string} name The name of the event.             * @param {any} sender The object that initiated the event.             * @param {string} direction='down' Equivalent to {@link plat.events.EventManager.DOWN|EventManager.DOWN}.             *              * @returns {void}             */            initialize(name: string, sender: any, direction?: 'down'): void;            /**             * @name initialize             * @memberof plat.events.IDispatchEventInstance             * @kind function             * @access public             * @variation 2             *              * @description             * Initializes the event, populating its public properties.             *              * @param {string} name The name of the event.             * @param {any} sender The object that initiated the event.             * @param {string} direction='direct' Equivalent to {@link plat.events.EventManager.DIRECT|EventManager.DIRECT}.             *              * @returns {void}             */            initialize(name: string, sender: any, direction?: 'direct'): void;            /**             * @name initialize             * @memberof plat.events.IDispatchEventInstance             * @kind function             * @access public             * @variation 3             *              * @description             * Initializes the event, populating its public properties.             *              * @param {string} name The name of the event.             * @param {any} sender The object that initiated the event.             * @param {string} direction The direction of propagation             *              * @returns {void}             */            initialize(name: string, sender: any, direction?: string): void;            /**             * @name stopPropagation             * @memberof plat.events.IDispatchEventInstance             * @kind function             * @access public             *              * @description             * Call this method to halt the propagation of an upward-moving event.             * Downward events cannot be stopped with this method.             *              * @returns {void}             */            stopPropagation(): void;        }        /**         * @name LifecycleEvent         * @memberof plat.events         * @kind class         *          * @extends {plat.events.DispatchEvent}         * @implements {plat.events.ILifecycleEvent}         *          * @description         * Represents a Lifecycle Event. Lifecycle Events are always direct events.         */        export class LifecycleEvent extends DispatchEvent implements ILifecycleEvent {            /**             * @name dispatch             * @memberof plat.events.LifecycleEvent             * @kind function             * @access public             * @static             *              * @description             * Creates a new LifecycleEvent and fires it.             *              * @typeparam {Error} E The type of Error this event represents.             *              * @param {string} name The name of the event.             * @param {any} sender The sender of the event.             *              * @returns {void}             */            static dispatch(name: string, sender: any): void {                var event = new LifecycleEvent();                event.initialize(name, sender);                EventManager.sendEvent(event);            }            /**             * @name initialize             * @memberof plat.events.LifecycleEvent             * @kind function             * @access public             *              * @description             * Initializes the event, populating its public properties.             *              * @param {string} name The name of the event.             * @param {any} sender The sender of the event.             */            initialize(name: string, sender: any): void {                super.initialize(name, sender, this.$EventManagerStatic.DIRECT);            }        }        /**         * The Type for referencing the '$LifecycleEventStatic' injectable as a dependency.         */        export function ILifecycleEventStatic(): ILifecycleEventStatic {            return LifecycleEvent;        }        register.injectable(__LifecycleEventStatic, ILifecycleEventStatic, null, __STATIC);        /**         * @name ILifecycleEventStatic         * @memberof plat.events         * @kind interface         *          * @description         * Dispatches {@link plat.events.LifecycleEvent|LifecycleEvent}         */        export interface ILifecycleEventStatic {            /**             * @name dispatch             * @memberof plat.events.ILifecycleEventStatic             * @kind function             * @access public             * @static             *              * @description             * Creates a new LifecycleEvent and fires it.             *              * @typeparam {Error} E The type of Error this event represents.             *              * @param {string} name The name of the event.             * @param {any} sender The sender of the event.             *              * @returns {void}             */            dispatch(name: string, sender: any): void;        }        /**         * @name ILifecycleEvent         * @memberof plat.events         * @kind interface         *          * @extends {plat.events.IDispatchEventInstance}         *          * @description         * Represents a Lifecycle Event. Lifecycle Events are always direct events.         */        export interface ILifecycleEvent extends IDispatchEventInstance {            /**             * @name initialize             * @memberof plat.events.ILifecycleEvent             * @kind function             * @access public             *              * @description             * Initializes the event, populating its public properties.             *              * @param {string} name The name of the event.             * @param {any} sender The sender of the event.             *              * @returns {void}             */            initialize(name: string, sender: any): void;        }        /**         * @name EventManager         * @memberof plat.events         * @kind class         * @access public         *          * @description         * Event object for a control dispatch event. Contains information about the type of event.         * Propagation of the event always starts at the sender, allowing a control to both          * initialize and consume an event. If a consumer of an event throws an error while          * handling the event it will be logged to the app using exception.warn. Errors will          * not stop propagation of the event.         */        export class EventManager {            /**             * @name $Compat             * @memberof plat.events.EventManager             * @kind property             * @access public             * @static             *              * @type {plat.ICompat}             *              * @description             * Reference to the {@link plat.ICompat|ICompat} injectable.             */            static $Compat: ICompat;            /**             * @name $Document             * @memberof plat.events.EventManager             * @kind property             * @access public             * @static             *              * @type {Document}             *              * @description             * Reference to the {@link plat.Document|Document} injectable.             */            static $Document: Document;            /**             * @name $Window             * @memberof plat.events.EventManager             * @kind property             * @access public             * @static             *              * @type {Window}             *              * @description             * Reference to the {@link plat.Window|Window} injectable.             */            static $Window: Window;            /**             * @name $Dom             * @memberof plat.events.EventManager             * @kind property             * @access public             * @static             *              * @type {plat.ui.IDom}             *              * @description             * Reference to the {@link plat.ui.IDom|IDom} injectable.             */            static $Dom: ui.IDom;            /**             * @name UP             * @memberof plat.events.EventManager             * @kind property             * @access public             * @static             * @readonly             *              * @type {string}             *              * @description             * An upward-moving event will start at the sender and move              * up the parent chain.             */            static UP = 'up';            /**             * @name DOWN             * @memberof plat.events.EventManager             * @kind property             * @access public             * @static             * @readonly             *              * @type {string}             *              * @description             * A downward-moving event will start at the sender and move              * to its children and beyond.             */            static DOWN = 'down';            /**             * @name DIRECT             * @memberof plat.events.EventManager             * @kind property             * @access public             * @static             * @readonly             *              * @type {string}             *              * @description             * Goes through all listeners for an event name, ignoring order.             */            static DIRECT = 'direct';            /**             * @name propagatingEvents             * @memberof plat.events.EventManager             * @kind property             * @access public             * @static             *              * @type {plat.IObject<boolean>}             *              * @description             * Keeps track of which events are currently propagating.             */            static propagatingEvents: IObject<boolean> = {};            /**             * @name __eventsListeners             * @memberof plat.events.EventManager             * @kind property             * @access private             * @static             *              * @type {plat.IObject<plat.events.IEventsListener>}             *              * @description             * Holds all the {@link plat.events.IEventsListener|event listeners} keyed by uid.             */            private static __eventsListeners: IObject<IEventsListener> = {};            /**             * @name __lifecycleEventListeners             * @memberof plat.events.EventManager             * @kind property             * @access private             * @static             *              * @type {Array<{ name: string; value: () => void; }>}             *              * @description             * Holds all the event listeners for the application lifefycle events.             */            private static __lifecycleEventListeners: Array<{ name: string; value: () => void; }> = [];            /**             * @name __initialized             * @memberof plat.events.EventManager             * @kind property             * @access private             * @static             *              * @type {boolean}             *              * @description             * whether or not the event manager has been initialized.             */            private static __initialized = false;            /**             * @name initialize             * @memberof plat.events.EventManager             * @kind function             * @access public             * @static             *              * @description             * Initializes the {@link plat.events.EventManager|EventManager}, creating the initial ALM event listeners.             */            static initialize(): void {                if (EventManager.__initialized) {                    return;                }                EventManager.__initialized = true;                var lifecycleListeners = EventManager.__lifecycleEventListeners,                    length = lifecycleListeners.length,                    $compat = EventManager.$Compat,                    $document = EventManager.$Document,                    $dom = EventManager.$Dom,                    dispatch = LifecycleEvent.dispatch,                    listener: { name: string; value: () => void; };                while (lifecycleListeners.length > 0) {                    listener = lifecycleListeners.pop();                    $document.removeEventListener(listener.name, listener.value, false);                }                if ($compat.cordova) {                    var eventNames = ['resume', 'online', 'offline'],                        event: string;                    length = eventNames.length;                    for (var i = 0; i < eventNames.length; ++i) {                        event = eventNames[i];                        lifecycleListeners.push({                            name: event,                            value: ((ev: string) => () => {                                dispatch(ev, EventManager);                            })(event)                        });                        $dom.addEventListener($document, event, lifecycleListeners[i].value, false);                    }                    lifecycleListeners.push({                        name: 'pause',                        value: () => {                            dispatch('suspend', EventManager);                        }                    });                    $dom.addEventListener($document, 'pause', lifecycleListeners[lifecycleListeners.length - 1].value, false);                    lifecycleListeners.push({                        name: 'deviceReady',                        value: () => {                            dispatch('ready', EventManager);                        }                    });                    $dom.addEventListener($document, 'deviceReady', lifecycleListeners[lifecycleListeners.length - 1].value, false);                    lifecycleListeners.push({                        name: 'backbutton',                        value: () => {                            dispatch('goBack', EventManager);                        }                    });                    $dom.addEventListener($document, 'backbutton', lifecycleListeners[lifecycleListeners.length - 1].value, false);                } else if ($compat.amd) {                    return;                } else {                    $dom.addEventListener(EventManager.$Window, 'load', () => {                        dispatch('ready', EventManager);                    });                }            }            /**             * Removes all event listeners for a given uid. Useful for garbage collection when              * certain objects that listen to events go out of scope.             *              * @static             * @param uid The uid for which the event listeners will be removed.             */            static dispose(uid: string): void {                deleteProperty(EventManager.__eventsListeners, uid);            }            /**             * Registers a listener for a DispatchEvent. The listener will be called when a DispatchEvent is              * propagating over the given uid. Any number of listeners can exist for a single event name.             *              * @static             * @param uid A unique id to associate with the object registering the listener.             * @param eventName The name of the event to listen to.             * @param listener The method called when the DispatchEvent is fired.             * @returns {IRemoveListener} A method for removing the listener.             */            static on(uid: string, eventName: string, listener: (ev: IDispatchEventInstance, ...args: any[]) => void,                context?: any): IRemoveListener {                var eventsListener = EventManager.__eventsListeners[uid];                if (isNull(eventsListener)) {                    eventsListener = EventManager.__eventsListeners[uid] = {                        listeners: {},                        context: context                    };                }                var eventListeners = eventsListener.listeners[eventName];                if (isNull(eventListeners)) {                    eventListeners = eventsListener.listeners[eventName] = [];                }                eventListeners.push(listener);                var index = eventListeners.length - 1;                return () => {                    eventListeners.splice(index, 1);                };            }            /**             * Looks for listeners to a given event name, and fires the listeners using the specified             * event direction.             *              * @static             * @param name The name of the event.             * @param sender The object sending the event.             * @param direction The direction in which to send the event.             * @param args The arguments to send to the listeners.             *              * @see EventManager.direction             */            static dispatch(name: string, sender: any, direction: string, args?: Array<any>): void;            /**             * Looks for listeners to a given event name, and fires the listeners using the specified             * event direction.             *              * @static             * @param name The name of the event.             * @param sender The object sending the event.             * @param direction='up' Equivalent to EventManager.direction.UP.             * @param args The arguments to send to the listeners.             *              * @see EventManager.direction             */            static dispatch(name: string, sender: any, direction: 'up', args?: Array<any>): void;            /**             * Looks for listeners to a given event name, and fires the listeners using the specified             * event direction.             *              * @static             * @param name The name of the event.             * @param sender The object sending the event.             * @param direction='down' Equivalent to EventManager.direction.DOWN.             * @param args The arguments to send to the listeners.             *              * @see EventManager.direction             */            static dispatch(name: string, sender: any, direction: 'down', args?: Array<any>): void;            /**             * Looks for listeners to a given event name, and fires the listeners using the specified             * event direction.             *              * @static             * @param name The name of the event.             * @param sender The object sending the event.             * @param direction='direct' Equivalent to EventManager.direction.DIRECT.             * @param args The arguments to send to the listeners.             *              * @see EventManager.direction             */            static dispatch(name: string, sender: any, direction: 'direct', args?: Array<any>): void;            static dispatch(name: string, sender: any, direction: string, args?: Array<any>) {                var $dispatchEvent: IDispatchEventInstance = acquire(__DispatchEventInstance);                $dispatchEvent.initialize(name, sender, direction);                EventManager.sendEvent($dispatchEvent, args);            }            /**             * Returns whether or not the given string is a registered direction.             *              * @param direction The direction of the event             */            static hasDirection(direction: string): boolean {                return (direction === EventManager.UP ||                    direction === EventManager.DOWN ||                    direction === EventManager.DIRECT);            }            /**             * Determines the appropriate direction and dispatches the event accordingly.             *              * @param event The IDispatchEvent to send             * @param args The arguments associated with the event             */            static sendEvent(event: IDispatchEventInstance, args?: Array<any>): void {                var name = event.name,                    direction = event.direction;                args = args || [];                EventManager.propagatingEvents[name] = true;                args = args || [];                switch (direction) {                    case EventManager.UP:                        EventManager._dispatchUp(event, args);                        break;                    case EventManager.DOWN:                        EventManager._dispatchDown(event, args);                        break;                    case EventManager.DIRECT:                        EventManager._dispatchDirect(event, args);                        break;                }                deleteProperty(EventManager.propagatingEvents, name);            }            /**             * Dispatches the event up the control chain.             *              * @param event The event being dispatched.             * @param args The arguments associated with the event.             */            static _dispatchUp(event: IDispatchEventInstance, args: Array<any>): void {                var name = event.name,                    parent = event.sender;                while (!isNull(parent) && EventManager.propagatingEvents[name]) {                    if (isNull(parent.uid)) {                        continue;                    }                    EventManager.__executeEvent(parent.uid, event, args);                    parent = parent.parent;                }            }            /**             * Dispatches the event down the control chain.             *              * @param event The event being dispatched.             * @param args The arguments associated with the event.             */            static _dispatchDown(event: IDispatchEventInstance, args: Array<any>): void {                var controls: Array<IControl> = [],                    control: IControl,                    name = event.name;                controls.push(event.sender);                while (controls.length && EventManager.propagatingEvents[name]) {                    control = controls.pop();                    if (isNull(control.uid)) {                        continue;                    }                    EventManager.__executeEvent(control.uid, event, args);                    if (isNull((<ui.ITemplateControl>control).controls)) {                        continue;                    }                    controls = controls.concat((<ui.ITemplateControl>control).controls);                }            }            /**             * Dispatches the event directly to all control's listening.             *              * @param event The event being dispatched.             * @param args The arguments associated with the event.             */            static _dispatchDirect(event: IDispatchEventInstance, args: Array<any>): void {                var uids = Object.keys(EventManager.__eventsListeners),                    length = uids.length,                    name = event.name,                    eventsListener: IEventsListener;                for (var i = 0; i < length; ++i) {                    if (!EventManager.propagatingEvents[name]) {                        break;                    }                    eventsListener = EventManager.__eventsListeners[uids[i]];                    if (isNull(eventsListener) || isNull(eventsListener.listeners[name])) {                        continue;                    }                    EventManager.__callListeners(eventsListener.context, event, eventsListener.listeners[name], args);                }            }            private static __executeEvent(uid: string, ev: IDispatchEventInstance, args: Array<any>): void {                var eventsListener = EventManager.__eventsListeners[uid];                if (isNull(eventsListener)) {                    return;                }                var context = eventsListener.context,                    listeners = eventsListener.listeners[ev.name];                if (isNull(listeners)) {                    return;                }                EventManager.__callListeners(context, ev, listeners, args);            }            private static __callListeners(context: any, ev: IDispatchEventInstance,                listeners: Array<(ev: IDispatchEventInstance, ...args: any[]) => void>, args: Array<any>): void {                var name = ev.name,                    length = listeners.length,                    index = -1;                args = [ev].concat(args);                while (++index < length && EventManager.propagatingEvents[name]) {                    try {                        listeners[index].apply(context, args);                    } catch (e) {                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);                        $exception.warn(e, $exception.EVENT);                    }                }            }        }        /**         * The Type for referencing the '$EventManagerStatic' injectable as a dependency.         */        export function IEventManagerStatic(            $Compat?: ICompat,            $Document?: Document,            $Window?: Window,            $Dom?: ui.IDom): IEventManagerStatic {                EventManager.$Compat = $Compat;                EventManager.$Document = $Document;                EventManager.$Window = $Window;                EventManager.$Dom = $Dom;                return EventManager;        }        register.injectable(__EventManagerStatic, IEventManagerStatic, [            __Compat,            __Document,            __Window,            __Dom        ], __STATIC);        /**         * Event object for a control dispatch event. Contains information about the type of event.         * Propagation of the event always starts at the sender, allowing a control to both          * initialize and consume an event. If a consumer of an event throws an error while          * handling the event it will be logged to the app using exception.warn. Errors will          * not stop propagation of the event.         */        export interface IEventManagerStatic {            /**             * An upward-moving event will start at the sender and move              * up the parent chain.             */            UP: string;            /**             * A downward-moving event will start at the sender and move             * to its children and beyond.             */            DOWN: string;            /**             * Goes through all listeners for an event name, ignoring order.             */            DIRECT: string;            /**             * Keeps track of which events are currently propagating.             */            propagatingEvents: {};            /**             * Initializes the EventManager, creating the initial ALM event listeners.             */            initialize(): void;            /**             * Removes all event listeners for a given uid. Useful for garbage collection when             * certain objects that listen to events go out of scope.             *              * @param uid The uid for which the event listeners will be removed.             */            dispose(uid: string): void;            /**             * Registers a listener for the beforeNavigate Event. The listener will be called when the beforeNavigate              * event is propagating over the given uid. Any number of listeners can exist for a single event name. The              * listener can chose to cancel the event using ev.cancel(), preventing any navigation as well as further              * calls to event listeners.             *              * @param uid A unique id to associate with the object registering the listener.             * @param eventName='beforeNavigate' Specifies that this is a listener for the beforeNavigate event.             * @param listener The method called when the beforeNavigate event is fired.             * @param context Optional context with which the listener will be bound.             * @returns {IRemoveListener} A method for removing the listener.             */            on(uid: string, eventName: 'beforeNavigate',                listener: (ev: INavigationEvent<any>) => void, context?: any): IRemoveListener;            /**             * Registers a listener for the navigating Event. The listener will be called when the navigating              * event is propagating over the given uid. Any number of listeners can exist for a single event name.             * The listener can chose to cancel the event using ev.cancel(), preventing any navigation as well as further              * calls to event listeners.             *              * @param uid A unique id to associate with the object registering the listener.             * @param eventName='navigating' Specifies that this is a listener for the navigating event.             * @param listener The method called when the navigating event is fired.             * @param context Optional context with which the listener will be bound.             * @returns {IRemoveListener} A method for removing the listener.             */            on(uid: string, eventName: 'navigating',                listener: (ev: INavigationEvent<any>) => void, context?: any): IRemoveListener;            /**             * Registers a listener for the navigated Event. The listener will be called when the navigated              * event is propagating over the given uid. Any number of listeners can exist for a single event name.             * The listener cannot cancel the event.             *              * @param uid A unique id to associate with the object registering the listener.             * @param eventName='navigated' Specifies that this is a listener for the navigated event.             * @param listener The method called when the navigated event is fired.             * @param context Optional context with which the listener will be bound.             * @returns {IRemoveListener} A method for removing the listener.             */            on(uid: string, eventName: 'navigated',                listener: (ev: INavigationEvent<any>) => void, context?: any): IRemoveListener;            /**             * Registers a listener for a NavigationEvent. The listener will be called when a NavigationEvent is             * propagating over the given uid. Any number of listeners can exist for a single event name.             *              * @param uid A unique id to associate with the object registering the listener.             * @param eventName The name of the event to listen to.             * @param listener The method called when the NavigationEvent is fired.             * @param context Optional context with which the listener will be bound.             * @returns {IRemoveListener} A method for removing the listener.             */            on(uid: string, eventName: string, listener: (ev: INavigationEvent<any>) => void,                context?: any): IRemoveListener;            /**             * Registers a listener for the ready AlmEvent. The ready event will be called when the app              * is ready to start.             *              * @param uid A unique id to associate with the object registering the listener.             * @param eventName='ready' Specifies that the listener is for the ready event.             * @param listener The method called when the app is ready to start.             * @param context Optional context with which the listener will be bound.             * @returns {IRemoveListener} A method for removing the listener.             */            on(uid: string, eventName: 'ready', listener: (ev: ILifecycleEvent) => void,                context?: any): IRemoveListener;            /**             * Registers a listener for the suspend AlmEvent. The listener will be called when an app              * is being suspended.             *              * @param uid A unique id to associate with the object registering the listener.             * @param eventName='suspend' Specifies the listener is for the suspend event.             * @param listener The method called when the suspend event is fired.             * @param context Optional context with which the listener will be bound.             * @returns {IRemoveListener} A method for removing the listener.             */            on(uid: string, eventName: 'suspend', listener: (ev: ILifecycleEvent) => void,                context?: any): IRemoveListener;            /**             * Registers a listener for the resume AlmEvent. The listener will be called when an app              * is being resumeed.             *              * @param uid A unique id to associate with the object registering the listener.             * @param eventName='suspend' Specifies the listener is for the resume event.             * @param listener The method called when the resume event is fired.             * @param context Optional context with which the listener will be bound.             * @returns {IRemoveListener} A method for removing the listener.             */            on(uid: string, eventName: 'resume', listener: (ev: ILifecycleEvent) => void,                context?: any): IRemoveListener;            /**             * Registers a listener for the online AlmEvent. This event fires when the app's network              * connection changes to be online.             *              * @param uid A unique id to associate with the object registering the listener.             * @param eventName='online' Specifies the listener is for the online event.             * @param listener The method called when the online event is fired.             * @param context Optional context with which the listener will be bound.             * @returns {IRemoveListener} A method for removing the listener.             */            on(uid: string, eventName: 'online', listener: (ev: ILifecycleEvent) => void,                context?: any): IRemoveListener;            /**             * Registers a listener for the offline AlmEvent. This event fires when the app's network              * connection changes to be offline.             *              * @param uid A unique id to associate with the object registering the listener.             * @param eventName='offline' Specifies the listener is for the offline event.             * @param listener The method called when the offline is fired.             * @param context Optional context with which the listener will be bound.             * @returns {IRemoveListener} A method for removing the listener.             */            on(uid: string, eventName: 'offline', listener: (ev: ILifecycleEvent) => void,                context?: any): IRemoveListener;            /**             * Registers a listener for an AlmEvent. The listener will be called when an AlmEvent is             * propagating over the given uid. Any number of listeners can exist for a single event name.             *              * @param uid A unique id to associate with the object registering the listener.             * @param eventName The name of the event to listen to.             * @param listener The method called when the AlmEvent is fired.             * @param context Optional context with which the listener will be bound.             * @returns {IRemoveListener} A method for removing the listener.             */            on(uid: string, eventName: string, listener: (ev: ILifecycleEvent) => void,                context?: any): IRemoveListener;            /**             * Registers a listener for a ErrorEvent. The listener will be called when a ErrorEvent is             * propagating over the given uid. Any number of listeners can exist for a single event name.             *              * @param uid A unique id to associate with the object registering the listener.             * @param eventName The name of the event to listen to.             * @param listener The method called when the ErrorEvent is fired.             * @param context Optional context with which the listener will be bound.             * @returns {IRemoveListener} A method for removing the listener.             */            on(uid: string, eventName: 'error', listener: (ev: IErrorEvent<Error>) => void,                context?: any): IRemoveListener;            /**             * Registers a listener for a ErrorEvent. The listener will be called when a ErrorEvent is             * propagating over the given uid. Any number of listeners can exist for a single event name.             *              * @param uid A unique id to associate with the object registering the listener.             * @param eventName The name of the event to listen to.             * @param listener The method called when the ErrorEvent is fired.             * @param context Optional context with which the listener will be bound.             * @returns {IRemoveListener} A method for removing the listener.             */            on(uid: string, eventName: string, listener: (ev: IErrorEvent<any>) => void,                context?: any): IRemoveListener;            /**             * Registers a listener for a DispatchEvent. The listener will be called when a DispatchEvent is             * propagating over the given uid. Any number of listeners can exist for a single event name.             *              * @param uid A unique id to associate with the object registering the listener.             * @param eventName The name of the event to listen to.             * @param listener The method called when the DispatchEvent is fired.             * @param context Optional context with which the listener will be bound.             * @returns {IRemoveListener} A method for removing the listener.             */            on(uid: string, eventName: string, listener: (ev: IDispatchEventInstance, ...args: any[]) => void,                context?: any): IRemoveListener;            /**             * Looks for listeners to a given event name, and fires the listeners using the specified             * event direction.             *              * @static             * @param name The name of the event.             * @param sender The object sending the event.             * @param direction='up' Equivalent to EventManager.direction.UP.             * @param args The arguments to send to the listeners.             *              * @see EventManager.direction             */            dispatch(name: string, sender: any, direction: 'up', args?: Array<any>): void;            /**             * Looks for listeners to a given event name, and fires the listeners using the specified             * event direction.             *              * @static             * @param name The name of the event.             * @param sender The object sending the event.             * @param direction='down' Equivalent to EventManager.direction.DOWN.             * @param args The arguments to send to the listeners.             *              * @see EventManager.direction             */            dispatch(name: string, sender: any, direction: 'down', args?: Array<any>): void;            /**             * Looks for listeners to a given event name, and fires the listeners using the specified             * event direction.             *              * @static             * @param name The name of the event.             * @param sender The object sending the event.             * @param direction='direct' Equivalent to EventManager.direction.DIRECT.             * @param args The arguments to send to the listeners.             *              * @see EventManager.direction             */            dispatch(name: string, sender: any, direction: 'direct', args?: Array<any>): void;            /**             * Looks for listeners to a given event name, and fires the listeners using the specified             * event direction.             *              * @static             * @param name The name of the event.             * @param sender The object sending the event.             * @param direction The direction in which to send the event.             * @param args The arguments to send to the listeners.             *              * @see EventManager.direction             */            dispatch(name: string, sender: any, direction: string, args?: Array<any>): void;            /**             * Returns whether or not the given string is a registered direction.             */            hasDirection(direction: string): boolean;            /**             * Determines the appropriate direction and dispatches the event accordingly.             */            sendEvent(event: IDispatchEventInstance, args?: Array<any>): void;        }        /**         * Describes an object that contains event listeners.         */        interface IEventsListener {            /**             * An IObject of listener arrays, keyed by event name.             */            listeners: IObject<Array<(ev: IDispatchEventInstance, ...args: any[]) => void>>;            /**             * The context with which to call each event listener.             */            context: any;        }        /**         * A class used by the Navigator to dispatch Navigation events. Allows anyone to listen          * for navigation events and respond to them, even canceling them if necessary.         *          * @generic P Corresponds to the type of event parameter.         */        export class NavigationEvent<P> extends DispatchEvent implements INavigationEvent<P> {            static $EventManagerStatic: IEventManagerStatic;            /**             * Dispatches an event with the specified target type.             *              * @param name The name of the event (e.g. 'beforeNavigate')             * @param sender The object sending the event.             * @param eventOptions An object implementing INavigationEvent, specifying what all event listeners             * will be passed.             */            static dispatch<P>(name: string, sender: any, eventOptions: INavigationEventOptions<P>): INavigationEvent<P> {                var event = new NavigationEvent<P>();                event.initialize(name, sender, null, eventOptions);                NavigationEvent.$EventManagerStatic.sendEvent(event, []);                return event;            }            parameter: P;            options: navigation.IBaseNavigationOptions;            target: any;            type: string;            cancelable: boolean = true;            cancelled: boolean = false;            initialize(name: string, sender: any, direction?: string, eventOptions?: INavigationEventOptions<P>) {                super.initialize(name, sender, this.$EventManagerStatic.DIRECT);                this.parameter = eventOptions.parameter;                this.options = eventOptions.options;                this.target = eventOptions.target;                this.type = eventOptions.type;            }            cancel() {                if (this.cancelable) {                    this.cancelled = true;                    (<any>this.$EventManagerStatic.propagatingEvents)[this.name] = false;                }            }        }        /**         * The Type for referencing the '$NavigationEventStatic' injectable as a dependency.         */        export function INavigationEventStatic($EventManagerStatic?: IEventManagerStatic): INavigationEventStatic {            NavigationEvent.$EventManagerStatic = $EventManagerStatic;            return NavigationEvent;        }        register.injectable(__NavigationEventStatic, INavigationEventStatic, [__EventManagerStatic], __STATIC);        /**         * The intended external interface for the '$NavigationEventStatic' injectable.         */        export interface INavigationEventStatic {            /**             * Dispatches an event with the specified target type.             *              * @generic P Corresponds to the type of the event parameter.             *              * @param name The name of the event (e.g. 'beforeNavigate')             * @param sender The object sending the event.             * @param eventOptions An object implementing INavigationEvent, specifying what all event listeners             * will be passed.             */            dispatch<P>(name: string, sender: any, eventOptions: events.INavigationEventOptions<P>): INavigationEvent<P>;        }        /**         * Describes an object used by the Navigator to dispatch Navigation events.         */        export interface INavigationEvent<P> extends IDispatchEventInstance {            /**             * Navigation parameter, used to send objects from one view control to another.             */            parameter: P;            /**             * The INavigationOptions in use for the navigation.             */            options: navigation.IBaseNavigationOptions;            /**             * The navigation event target. Its type depends on the type of Navigation event.             */            target: any;            /**             * Specifies the type of IViewControl for the Route Event.             */            type: string;            /**             * The sender of the event.             */            sender: any;            /**             * States whether or not this event is able to be cancelled. Some navigation events can be              * cancelled, preventing further navigation.             */            cancelable?: boolean;            /**             * States whether or not this event has been cancelled.             */            cancelled?: boolean;            /**             * If the event is cancelable (ev.cancelable), calling this method will cancel the event.             */            cancel(): void;            /**             * Initializes the event members.             *              * @param name The name of the event.             * @param sender The object that initiated the event.             * @param direction='direct' Equivalent to EventManager.direction.DIRECT.             *              * @see EventManager.direction             */            initialize(name: string, sender: any, direction?: 'direct', eventOptions?: INavigationEventOptions<P>);            /**             * Initializes the event members.             *              * @param name The name of the event.             * @param sender The object that initiated the event.             * @param direction This will always be a direct event no matter what is sent in.             *              * @see EventManager.direction             */            initialize(name: string, sender: any, direction?: string, eventOptions?: INavigationEventOptions<P>);        }        /**         * Describes options for an INavigationEvent. The generic parameter specifies the          * target type for the event.         */        export interface INavigationEventOptions<P> {            /**             * Navigation parameter, used to send objects from one view control to another.             */            parameter: P;            /**             * The INavigationOptions in use for the navigation.             */            options: navigation.IBaseNavigationOptions;            /**             * The navigation event target. Its type depends on the type of Navigation event.             */            target: any;            /**             * Specifies the type of IViewControl for the Route Event.             */            type: string;            /**             * States whether or not this event is able to be cancelled. Some navigation events can be              * cancelled, preventing further navigation.             */            cancelable?: boolean;        }        /**         * @name ErrorEvent         * @memberof plat.events         * @kind class         *          * @extends {plat.events.DispatchEvent}         * @implements {plat.events.IErrorEvent}         *          * @description         * Represents an internal Error Event. This is used for any          * internal errors (both fatal and warnings). All error events are          * direct events.         *          * @typeparam {Error} E The type of Error this event represents.         */        export class ErrorEvent<E extends Error> extends DispatchEvent implements IErrorEvent<E> {            /**             * @name $EventManagerStatic             * @memberof plat.events.ErrorEvent             * @kind property             * @access public             * @static             *              * @type {plat.events.IEventManagerStatic}             *              * @description             * Reference to the {@link plat.events.IEventManagerStatic|IEventManagerStatic} injectable.             */            static $EventManagerStatic: IEventManagerStatic;            /**             * @name dispatch             * @memberof plat.events.ErrorEvent             * @kind function             * @access public             * @static             *              * @description             * Creates a new ErrorEvent and fires it.             *              * @typeparam {Error} E The type of Error this event represents.             *              * @param {string} name The name of the event.             * @param {any} sender The sender of the event.             * @param {E} error The error that occurred, resulting in the event.             *              * @returns {void}             */            static dispatch<E extends Error>(name: string, sender: any, error: E): void {                var event = new ErrorEvent<E>();                event.initialize(name, sender, null, error);                ErrorEvent.$EventManagerStatic.sendEvent(event);            }            /**             * @name error             * @memberof plat.events.ErrorEvent             * @kind property             * @access public             * @static             *              * @type {E}             *              * @description             * The error being dispatched.             */            error: E;            /**             * @name initialize             * @memberof plat.events.ErrorEvent             * @kind function             * @access public             *              * @description             * Initializes the event, populating its public properties.             *              * @param {string} name The name of the event.             * @param {any} sender The sender of the event.             * @param {string} direction='direct' Equivalent to {@link plat.events.EventManager.DIRECT|EventManager.DIRECT}.             * @param {E} error The error that occurred, resulting in the event.             *              * @returns {void}             */            initialize(name: string, sender: any, direction?: 'direct', error?: E): void;            /**             * @name initialize             * @memberof plat.events.ErrorEvent             * @kind function             * @access public             *              * @description             * Initializes the event, populating its public properties.             *              * @param {string} name The name of the event.             * @param {any} sender The sender of the event.             * @param {string} direction This is always a direct event.             * @param {E} error The error that occurred, resulting in the event.             *              * @returns {void}             */            initialize(name: string, sender: any, direction?: string, error?: E): void;            initialize(name: string, sender: any, direction?: string, error?: E) {                super.initialize(name, sender, this.$EventManagerStatic.DIRECT);                this.error = error;            }        }        /**         * The Type for referencing the '$ErrorEventStatic' injectable as a dependency.         */        export function IErrorEventStatic($EventManagerStatic?: IEventManagerStatic): IErrorEventStatic {            ErrorEvent.$EventManagerStatic = $EventManagerStatic;            return ErrorEvent;        }        register.injectable(__ErrorEventStatic, IErrorEventStatic, [__EventManagerStatic], __STATIC);        /**         * @name IErrorEventStatic         * @memberof plat.events         * @kind interface         *          * @description         * Dispatches {@link plat.events.ErrorEvent|ErrorEvents}         */        export interface IErrorEventStatic {            /**             * @name dispatch             * @memberof plat.events.IErrorEventStatic             * @kind function             * @access public             * @static             *              * @description             * Creates a new ErrorEvent and fires it.             *              * @typeparam {Error} E The type of Error this event represents.             *              * @param {string} name The name of the event.             * @param {any} sender The sender of the event.             * @param {E} error The error that occurred, resulting in the event.             *              * @returns {void}             */            dispatch<E extends Error>(name: string, sender: any, error: E): void;        }        /**         * @name IErrorEvent         * @memberof plat.events         * @kind interface         *          * @extends {plat.events.IDispatchEventInstance}         *          * @description         * Represents an internal Error Event. This is used for any          * internal errors (both fatal and warnings). All error events are          * direct events.         *          * @typeparam {Error} E The type of Error this event represents.         */        export interface IErrorEvent<E extends Error> extends IDispatchEventInstance {            /**             * @name error             * @memberof plat.events.IErrorEvent             * @kind property             * @access public             * @static             *              * @type {E}             *              * @description             * The error being dispatched.             */            error: E;            /**             * @name initialize             * @memberof plat.events.IErrorEvent             * @kind function             * @access public             *              * @description             * Initializes the event, populating its public properties.             *              * @param {string} name The name of the event.             * @param {any} sender The sender of the event.             * @param {string} direction='direct' Equivalent to {@link plat.events.EventManager.DIRECT|EventManager.DIRECT}.             * @param {E} error The error that occurred, resulting in the event.             *              * @returns {void}             */            initialize(name: string, sender: any, direction?: 'direct', error?: E): void;            /**             * @name initialize             * @memberof plat.events.IErrorEvent             * @kind function             * @access public             *              * @description             * Initializes the event, populating its public properties.             *              * @param {string} name The name of the event.             * @param {any} sender The sender of the event.             * @param {string} direction This is always a direct event.             * @param {E} error The error that occurred, resulting in the event.             *              * @returns {void}             */            initialize(name: string, sender: any, direction?: string, error?: E): void;        }    }    /**     * @name Control     * @memberof plat     * @kind class     *      * @implements {plat.IControl}     *      * @description     * Used for facilitating data and DOM manipulation. Contains lifecycle events      * as well as properties for communicating with other controls. This is the base     * class for all types of controls.     */    export class Control implements IControl {        /**         * @name $Parser         * @memberof plat.Control         * @kind property         * @access public         * @static         *          * @type {plat.expressions.IParser}         *          * @description         * Reference to the {@link plat.expressions.IParser|IParser} injectable.         */        static $Parser: expressions.IParser;        /**         * @name $ContextManagerStatic         * @memberof plat.Control         * @kind property         * @access public         * @static         *          * @type {plat.observable.IContextManagerStatic}         *          * @description         * Reference to the {@link plat.observable.IContextManagerStatic|IContextManagerStatic} injectable.         */        static $ContextManagerStatic: observable.IContextManagerStatic;        /**         * @name $EventManagerStatic         * @memberof plat.Control         * @kind property         * @access public         * @static         *          * @type {plat.events.IEventManagerStatic}         *          * @description         * Reference to the {@link plat.events.IEventManagerStatic|IEventManagerStatic} injectable.         */        static $EventManagerStatic: events.IEventManagerStatic;        /**         * @name __eventListeners         * @memberof plat.Control         * @kind property         * @access private         * @static         *          * @type {plat.IObject<Array<plat.IRemoveListener>>}         *          * @description         * An object containing all controls' registered event listeners.         */        private static __eventListeners: IObject<Array<IRemoveListener>> = {};        /**         * @name getRootControl         * @memberof plat.Control         * @kind function         * @access public         * @static         *          * @description         * Finds the ancestor control for the given control that contains the root          * context.         *          * @param {plat.IControl} control The control with which to find the root.         *          * @returns {plat.ui.ITemplateControl} The root control.         */        static getRootControl(control: IControl): ui.ITemplateControl;        static getRootControl(control: ui.ITemplateControl) {            if (isNull(control)) {                return control;            }            var root = control;            while (!(isNull(root.parent) || root.hasOwnContext)) {                if (!isNull(root.root)) {                    root = root.root;                    break;                }                root = root.parent;            }            return root;        }        /**         * @name load         * @memberof plat.Control         * @kind function         * @access public         * @static         *          * @description         * Given a control, calls the loaded method for the control if it exists.         *          * @param {plat.IControl} control The control to load.         *          * @returns {void}         */        static load(control: IControl): void {            if (isNull(control)) {                return;            }            var ctrl = <ui.ITemplateControl>control;            if (isString(ctrl.absoluteContextPath) && isFunction(ctrl.contextChanged)) {                var contextManager = Control.$ContextManagerStatic.getManager(ctrl.root);                contextManager.observe(ctrl.absoluteContextPath, {                    uid: control.uid,                    listener: (newValue, oldValue) => {                        ui.TemplateControl.contextChanged(control, newValue, oldValue);                    }                });                if (isFunction((<any>ctrl).zCC__plat)) {                    (<any>ctrl).zCC__plat();                    deleteProperty(ctrl, 'zCC__plat');                }            }            if (isFunction(control.loaded)) {                control.loaded();            }        }        /**         * @name dispose         * @memberof plat.Control         * @kind function         * @access public         * @static         *          * @description         * Disposes all the necessary memory for a control. Uses specific dispose          * methods related to a control's constructor if necessary.         *          * @param {plat.IControl} control The {@link plat.Control|Control} to dispose.         *          * @returns {void}         */        static dispose(control: IControl): void {            var ctrl = <any>control;            if (isNull(ctrl)) {                return;            } else if (!isUndefined(ctrl.templateControl)) {                controls.AttributeControl.dispose(ctrl);                return;            } else if (ctrl.hasOwnContext) {                ui.ViewControl.dispose(ctrl);                return;            } else if (ctrl.controls) {                ui.TemplateControl.dispose(ctrl);                return;            }            Control.removeEventListeners(control);            Control.$ContextManagerStatic.dispose(control);            control.dispose();            control.element = null;            Control.removeParent(control);        }        /**         * @name removeParent         * @memberof plat.Control         * @kind function         * @access public         * @static         *          * @description         * Splices a control from its parent's controls list. Sets the control's parent          * to null.         *          * @param {plat.IControl} control The control whose parent will be removed.         *          * @returns {void}         */        static removeParent(control: IControl): void {            if (isNull(control)) {                return;            }            var parent = control.parent;            if (isNull(parent)) {                return;            }            var controls = parent.controls || [],                index = controls.indexOf(control);            if (index !== -1) {                controls.splice(index, 1);            }            control.parent = null;        }        /**         * @name removeEventListeners         * @memberof plat.Control         * @kind function         * @access public         * @static         *          * @description         * Removes all event listeners for a control with the given uid.         *          * @param {plat.IControl} control The control having its event listeners removed.         *          * @returns {void}         */        static removeEventListeners(control: IControl): void {            if (isNull(control)) {                return;            }            var removeListeners = Control.__eventListeners,                uid = control.uid;            var listeners = removeListeners[uid];            if (isArray(listeners)) {                var index = listeners.length;                while (index-- > 0) {                    listeners[index]();                }                deleteProperty(removeListeners, uid);            }        }        /**         * @name getInstance         * @memberof plat.Control         * @kind function         * @access public         * @static         *          * @description         * Returns a new instance of {@link plat.Control|Control}.         *          * @returns {plat.IControl} The newly instantiated control.         */        static getInstance(): IControl {            return new Control();        }        /**         * @name __addRemoveListener         * @memberof plat.Control         * @kind function         * @access private         * @static         *          * @description         * Adds a function to remove an event listener for the control specified          * by its uid.         *          * @param {string} uid The uid of the control associated with the remove function.         * @param {plat.IRemoveListener} listener The remove function to add.         *          * @returns {void}         */        private static __addRemoveListener(uid: string, listener: IRemoveListener): void {            var removeListeners = Control.__eventListeners;            if (isArray(removeListeners[uid])) {                removeListeners[uid].push(listener);                return;            }            removeListeners[uid] = [listener];        }        /**         * @name __spliceRemoveListener         * @memberof plat.Control         * @kind function         * @access private         * @static         *          * @description         * Removes a {@link plat.IRemoveListener|IRemoveListener} from a control's listeners.         *          * @param {string} uid The uid of the control associated with the remove function.         * @param {plat.IRemoveListener} listener The remove function to add.         *          * @returns {void}         */        private static __spliceRemoveListener(uid: string, listener: IRemoveListener): void {            var removeListeners = Control.__eventListeners,                controlListeners = removeListeners[uid];            if (isArray(controlListeners)) {                var index = controlListeners.indexOf(listener);                if (index === -1) {                    return;                }                controlListeners.splice(index, 1);            }        }        /**         * @name __getControls         * @memberof plat.Control         * @kind function         * @access private         * @static         *          * @description         * Gets controls that have a specific key/value string pair.         *          *          * @param {plat.IControl} control The at which to start searching for key/value pairs.         * @param {string} key The key to search for on all the controls in the tree.         * @param {string} value The expected value used to find similar controls.         *          * @returns {Array<plat.IControl>} The controls matching the input key/value pair.         */        private static __getControls(control: IControl, key: string, value: string): Array<IControl> {            var controls: Array<IControl> = [],                root = Control.getRootControl(control),                child: IControl;            if (!isNull(root) && (<any>root)[key] === value) {                controls.push(root);            }            var children = root.controls;            if (isNull(children)) {                return controls;            }            var queue: Array<IControl> = [];            queue = queue.concat(children);            while (queue.length > 0) {                child = queue.shift();                if ((<any>child)[key] === value) {                    controls.push(child);                }                if (isNull((<ui.ITemplateControl>child).controls)) {                    continue;                }                queue = queue.concat((<ui.ITemplateControl>child).controls);            }            return controls;        }        /**         * @name uid         * @memberof plat.Control         * @kind property         * @access public         * @readonly         *          * @type {string}         *          * @description         * A unique id, created during instantiation and found on every {@link plat.Control|Control}.         */        uid: string;        /**         * @name name         * @memberof plat.Control         * @kind property         * @access public         * @readonly         *          * @type {string}         *          * @description         * The name of a {@link plat.Control|Control}.         */        name: string;        /**         * @name type         * @memberof plat.Control         * @kind property         * @access public         * @readonly         *          * @type {string}         *          * @description         * The type of a {@link plat.Control|Control}.         */        type: string;        /**         * @name priority         * @memberof plat.Control         * @kind property         * @access public         *          * @type {number}         *          * @description         * Specifies the priority of the control. The purpose of          * this is so that controls like plat-bind can have a higher          * priority than plat-tap. The plat-bind will be initialized          * and loaded before plat-tap, meaning it has the first chance          * to respond to events.         */        priority = 0;        /**         * @name parent         * @memberof plat.Control         * @kind property         * @access public         * @readonly         *          * @type {plat.ui.ITemplateControl}         *          * @description         * The parent control that created this control.         */        parent: ui.ITemplateControl;        /**         * @name element         * @memberof plat.Control         * @kind property         * @access public         *          * @type {HTMLElement}         *          * @description         * The HTMLElement that represents this {@link plat.Control|Control}. Should only be modified by controls that implement          * {plat.ui.ITemplateControl|ITemplateControl}. During initialize the control should populate this element with what it wishes         * to render to the user.          *          * @remarks         * When there is innerHTML in the element prior to instantiating the control:         *     The element will include the innerHTML         * When the control implements templateString or templateUrl:         *     The serialized DOM will be auto-generated and included in the element. Any         *     innerHTML will be stored in the innerTemplate property on the control.         * After an {@link plat.IControl|IControl} is initialized its element will be compiled.         */        element: HTMLElement;        /**         * @name attributes         * @memberof plat.Control         * @kind property         * @access public         *          * @type {plat.ui.IAttributesInstance}         *          * @description         * The attributes object representing all the attributes for a {@link plat.Control|Control's} element. All attributes are          * converted from dash notation to camelCase.         */        attributes: ui.IAttributesInstance;        /**         * @name dom         * @memberof plat.Control         * @kind property         * @access public         * @readonly         *          * @type {plat.ui.IDom}         *          * @description         * Contains DOM helper methods for manipulating this control's element.         */        dom: ui.IDom = acquire(__Dom);        /**         * @name constructor         * @memberof plat.Control         * @kind function         * @access public         *          * @description         * The constructor for a control. Any injectables specified during control registration will be         * passed into the constructor as arguments as long as the control is instantiated with its associated         * injector.         *          * @returns {plat.Control}         */        constructor() {            var ContextManager: observable.IContextManagerStatic = Control.$ContextManagerStatic ||                acquire(__ContextManagerStatic);            ContextManager.defineGetter(this, 'uid', uniqueId('plat_'));        }        /**         * @name initialize         * @memberof plat.Control         * @kind function         * @access public         * @virtual         *          * @description         * The initialize event method for a control. In this method a control should initialize all the necessary          * variables. This method is typically only necessary for view controls. If a control does not implement          * {@link plat.ui.IBaseViewControl|IBaseViewControl} then it is not safe to access, observe, or modify          * the context property in this method. A view control should call services/set context in this method in          * order to fire the loaded event. No control will be loaded until the view control has specified a context.         *          * @returns {void}         */        initialize() { }        /**         * @name loaded         * @memberof plat.Control         * @kind function         * @access public         * @virtual         *          * @description         * The loaded event method for a control. This event is fired after a control has been loaded,         * meaning all of its children have also been loaded and initial DOM has been created and populated. It is now          * safe for all controls to access, observe, and modify the context property.         *          * @returns {void}         */        loaded() { }        /**         * @name getControlsByName         * @memberof plat.Control         * @kind function         * @access public         *          * @description         * Retrieves all the controls with the specified name.         *          * @param {string} name The string name with which to populate the returned controls array.         *          * @returns {Array<plat.IControl>} The controls that match the input name.         */        getControlsByName(name: string): Array<IControl> {            return Control.__getControls(this, 'name', name);        }        /**         * @name getControlsByType         * @memberof plat.Control         * @kind function         * @access public         * @variation 0         *          * @description         * Retrieves all the controls of the specified type.         *          * @typeparam {plat.Control} T The type of control to be returned in an Array.         *          * @param {string} type The type used to find controls (e.g. 'plat-foreach')         *          * @returns {Array<T>} The controls matching the input type.         */        getControlsByType<T extends Control>(type: string): Array<T>;        /**         * @name getControlsByType         * @memberof plat.Control         * @kind function         * @access public         * @variation 1         *          * @description         * Retrieves all the controls of the specified type.         *          * @typeparam {plat.Control} T The type of control to be returned in an Array.         *          * @param {new () => T} Constructor The constructor used to find controls.         *          * @returns {Array<T>} The controls matching the input type.         */        getControlsByType<T extends Control>(Constructor: new () => T): Array<T>;        getControlsByType(type: any) {            if (isString(type)) {                return Control.__getControls(this, 'type', type);            }            return Control.__getControls(this, 'constructor', type);        }        /**         * @name addEventListener         * @memberof plat.Control         * @kind function         * @access public         * @variation 0         *          * @description         * Adds an event listener of the specified type to the specified element. Removal of the          * event is handled automatically upon disposal.         *          * @param {EventTarget} element The element to add the event listener to.         * @param {string} type The type of event to listen to.         * @param {plat.ui.IGestureListener} listener The listener to fire when the event occurs.         * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase          * of event propagation.         *          * @returns {plat.IRemoveListener} A function to call in order to stop listening to the event.         */        addEventListener(element: EventTarget, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener;        /**         * @name addEventListener         * @memberof plat.Control         * @kind function         * @access public         * @variation 1         *          * @description         * Adds an event listener of the specified type to the specified element. Removal of the          * event is handled automatically upon disposal.         *          * @param {EventTarget} element The element to add the event listener to.         * @param {string}  type The type of event to listen to.         * @param {EventListener} listener The listener to fire when the event occurs.         * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase          * of event propagation.         *          * @returns {plat.IRemoveListener} A function to call in order to stop listening to the event.         */        addEventListener(element: EventTarget, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;        addEventListener(element: any, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener {            if (!isFunction(listener)) {                var Exception: IExceptionStatic = acquire(__ExceptionStatic);                Exception.warn('"Control.addEventListener" must take a function as the third argument.', Exception.EVENT);                return noop;            }            listener = listener.bind(this);            var removeListener = this.dom.addEventListener(element, type, listener, useCapture),                uid = this.uid;            Control.__addRemoveListener(uid, removeListener);            return () => {                removeListener();                Control.__spliceRemoveListener(uid, removeListener);            };        }        /**         * @name observe         * @memberof plat.Control         * @kind function         * @access public         * @variation 0         *          * @description         * Allows a {@link plat.Control|Control} to observe any property on its context and receive updates when         * the property is changed.         *          * @typeparam {any} T The type of object to observe.         *          * @param {any} context The immediate parent object containing the property.         * @param {string} property The property identifier to watch for changes.         * @param {(value: T, oldValue: T) => void} listener The method called when the property is changed. This method will have its 'this'         * context set to the control instance.         *          * @returns {plat.IRemoveListener} A function to call in order to stop observing the property.         */        observe<T>(context: any, property: string, listener: (value: T, oldValue: T) => void): IRemoveListener;        /**         * @name observe         * @memberof plat.Control         * @kind function         * @access public         * @variation 1         *          * @description         * Allows a {@link plat.Control|Control} to observe any property on its context and receive updates when         * the property is changed.         *          * @typeparam {any} T The type of object to observe.         *          * @param {any} context The immediate parent object containing the property.         * @param {number} property The property identifier to watch for changes.         * @param {(value: T, oldValue: T) => void} listener The method called when the property is changed. This method will have its 'this'         * context set to the control instance.         *          * @returns {plat.IRemoveListener} A function to call in order to stop observing the property.         */        observe<T>(context: any, property: number, listener: (value: T, oldValue: T) => void): IRemoveListener;        observe(context: any, property: any, listener: (value: any, oldValue: any) => void): IRemoveListener {            if (isNull(context) || !context.hasOwnProperty(property)) {                return noop;            }            var control = isFunction((<ui.ITemplateControl>(<any>this)).getAbsoluteIdentifier) ? this : <IControl>this.parent;            if (isNull(control) || !isFunction((<ui.ITemplateControl>(<any>control)).getAbsoluteIdentifier)) {                return noop;            }            var absoluteIdentifier = (<ui.ITemplateControl>(<any>control)).getAbsoluteIdentifier(context);            if (isNull(absoluteIdentifier)) {                return noop;            }            var contextManager = Control.$ContextManagerStatic.getManager(Control.getRootControl(this));            return contextManager.observe(absoluteIdentifier + '.' + property, {                listener: listener.bind(this),                uid: this.uid            });        }        /**         * @name observeArray         * @memberof plat.Control         * @kind function         * @access public         * @variation 0         *          * @description         * Allows a {@link plat.Control|Control} to observe an array and receive updates when certain array-changing methods are called.         * The methods watched are push, pop, shift, sort, splice, reverse, and unshift. This method does not watch         * every item in the array.         *          * @typeparam {any} T The type of the Array to observe.         *          * @param {any} context The immediate parent object containing the array as a property.         * @param {string} property The array property identifier to watch for changes.         * @param {(ev: plat.observable.IArrayMethodInfo<T>) => void} listener The method called when an array-changing method is called. This method will have its 'this'         * context set to the control instance.         *          * @returns {plat.IRemoveListener} A function to call in order to stop observing the array.         */        observeArray<T>(context: any, property: string, listener: (ev: observable.IArrayMethodInfo<T>) => void): IRemoveListener;        /**         * @name observeArray         * @memberof plat.Control         * @kind function         * @access public         * @variation 1         *          * @description         * Allows a {@link plat.Control|Control} to observe an array and receive updates when certain array-changing methods are called.         * The methods watched are push, pop, shift, sort, splice, reverse, and unshift. This method does not watch         * every item in the array.         *          * @typeparam {any} T The type of the Array to observe.         *          * @param {any} context The immediate parent object containing the array as a property.         * @param {number} property The array property identifier to watch for changes.         * @param {(ev: plat.observable.IArrayMethodInfo<T>) => void} listener The method called when an array-changing method is called. This method will have its 'this'         * context set to the control instance.         *          * @returns {plat.IRemoveListener} A function to call in order to stop observing the array.         */        observeArray<T>(context: any, property: number, listener: (ev: observable.IArrayMethodInfo<T>) => void): IRemoveListener;        observeArray(context: any, property: any, listener: (ev: observable.IArrayMethodInfo<any>) => void): IRemoveListener {            if (isNull(context) || !context.hasOwnProperty(property)) {                return noop;            }            var array = context[property],                callback = listener.bind(this);            if (!isArray(array)) {                return noop;            }            var control = isFunction((<ui.ITemplateControl>this).getAbsoluteIdentifier) ? this : <IControl>this.parent;            if (isNull(control) || !isFunction((<ui.ITemplateControl>control).getAbsoluteIdentifier)) {                return noop;            }            var absoluteIdentifier = (<ui.ITemplateControl>control).getAbsoluteIdentifier(context),                ContextManager = Control.$ContextManagerStatic;            if (isNull(absoluteIdentifier)) {                if (property === 'context') {                    absoluteIdentifier = (<ui.ITemplateControl>control).absoluteContextPath;                } else {                    return noop;                }            } else {                absoluteIdentifier += '.' + property;            }            var contextManager = ContextManager.getManager(Control.getRootControl(this)),                uid = this.uid,                removeCallback = contextManager.observe(absoluteIdentifier, {                    listener: (newValue: Array<any>, oldValue: Array<any>) => {                        removeListener();                        removeListener = contextManager.observeArray(uid, callback, absoluteIdentifier, newValue, oldValue);                    },                    uid: uid                }),                removeListener = contextManager.observeArray(uid, callback, absoluteIdentifier, array, null);            // need to call callback if             return () => {                ContextManager.removeArrayListeners(absoluteIdentifier, uid);                removeListener();                removeCallback();            };        }        /**         * @name observeExpression         * @memberof plat.Control         * @kind function         * @access public         * @variation 0         *          * @description         * Parses an expression string and observes any associated identifiers. When an identifier         * value changes, the listener will be called.         *          * @param {string} expression The expression string to watch for changes.         * @param {(value: any, oldValue: any) => void} listener The listener to call when the expression identifer values change.         *          * @returns {plat.IRemoveListener} A function to call in order to stop observing the expression.         */        observeExpression(expression: string, listener: (value: any, oldValue: any) => void): IRemoveListener;        /**         * @name observeExpression         * @memberof plat.Control         * @kind function         * @access public         * @variation 1         *          * @description         * Using a {@link plat.expressions.IParsedExpression|IParsedExpression} observes any associated identifiers. When an identifier         * value changes, the listener will be called.         *          * @param {plat.expressions.IParsedExpression} expression The expression string to watch for changes.         * @param {(value: any, oldValue: any) => void} listener The listener to call when the expression identifer values change.         *          * @returns {plat.IRemoveListener} A function to call in order to stop observing the expression.         */        observeExpression(expression: expressions.IParsedExpression, listener: (value: any, oldValue: any) => void): IRemoveListener;        observeExpression(expression: any, listener: (value: any, oldValue: any) => void): IRemoveListener {            if (isNull(expression)) {                return noop;            } else if (!(isString(expression) || isFunction(expression.evaluate))) {                return noop;            }            var parsedExpression: expressions.IParsedExpression = isString(expression) ? Control.$Parser.parse(expression) : expression,                aliases = parsedExpression.aliases,                control: ui.TemplateControl = !isNull((<ui.TemplateControl>(<any>this)).resources) ?                    <ui.TemplateControl>(<any>this) :                    <ui.TemplateControl>this.parent,                alias: string,                length = aliases.length,                resources: IObject<observable.IContextManager> = {},                ContextManager = Control.$ContextManagerStatic,                getManager = ContextManager.getManager,                TemplateControl = ui.TemplateControl,                findResource = TemplateControl.findResource,                evaluateExpression = TemplateControl.evaluateExpression,                i: number;            if (isNull(control) || !isString(control.absoluteContextPath)) {                return noop;            }            for (i = 0; i < length; ++i) {                alias = aliases[i];                var resourceObj = findResource(control, alias);                if (!isNull(resourceObj) && resourceObj.resource.type === 'observable') {                    resources[alias] = getManager(resourceObj.control);                }            }            var identifiers = parsedExpression.identifiers,                contextManager = getManager(Control.getRootControl(control)),                identifier: string,                split: Array<string> = [],                absolutePath = control.absoluteContextPath + '.',                managers: IObject<observable.IContextManager> = {};            length = identifiers.length;            for (i = 0; i < length; ++i) {                identifier = identifiers[i];                split = identifier.split('.');                if (identifier.indexOf('this') === 0) {                    identifier = identifier.slice(5);                } else if (identifier[0] === '@') {                    alias = split[0].substr(1);                    identifier = identifier.replace('@' + alias, 'resources.' + alias + '.value');                    if (!isNull(resources[alias])) {                        managers[identifier] = resources[alias];                    }                    continue;                }                managers[absolutePath + identifier] = contextManager;            }            identifiers = Object.keys(managers);            length = identifiers.length;            var oldValue = evaluateExpression(parsedExpression, control),                listeners: Array<IRemoveListener> = [],                uid = this.uid;            for (i = 0; i < length; ++i) {                identifier = identifiers[i];                listeners.push(managers[identifier].observe(identifier, {                    uid: uid,                    listener: () => {                        var value = evaluateExpression(parsedExpression, control);                        listener.call(this, value, oldValue);                        oldValue = value;                    }                }));            }            return () => {                var length = listeners.length;                for (var i = 0; i < length; ++i) {                    listeners[i]();                }            };        }        /**         * @name evaluateExpression         * @memberof plat.Control         * @kind function         * @access public         * @variation 0         *          * @description         * Evaluates an expression string, using the control.parent.context.         *          * @param {string} expression The expression string to evaluate.         * @param {any} aliases Optional alias values to parse with the expression         *          * @returns {any} The evaluated expression         */        evaluateExpression(expression: string, aliases?: any): any;        /**         * @name evaluateExpression         * @memberof plat.Control         * @kind function         * @access public         * @variation 1         *          * @description         * Evaluates an {@link plat.expressions.IParsedExpression|IParsedExpression} using the control.parent.context.         *          * @param {string} expression The expression string to evaluate.         * @param {any} aliases Optional alias values to parse with the expression         *          * @returns {any} The evaluated expression         */        evaluateExpression(expression: expressions.IParsedExpression, aliases?: any): any;        evaluateExpression(expression: any, aliases?: any): any {            var TemplateControl = ui.TemplateControl;            return TemplateControl.evaluateExpression(expression, this.parent, aliases);        }        /**         * @name dispatchEvent         * @memberof plat.Control         * @kind function         * @access public         * @variation 0         *          * @description         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the          * provided direction mechanism. Controls in the propagation chain that registered         * the event using the control.on() method will receive the event. Propagation will         * always start with the sender, so the sender can both produce and consume the same         * event.         *          * @param {string} name The name of the event to send, cooincides with the name used in the         * control.on() method.         * @param {string} direction='up' Equivalent to {@link plat.events.EventManager.UP|EventManager.UP}         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.         *          * @returns {void}         */        dispatchEvent(name: string, direction?: 'up', ...args: any[]): void;        /**         * @name dispatchEvent         * @memberof plat.Control         * @kind function         * @access public         * @variation 1         *          * @description         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the          * provided direction mechanism. Controls in the propagation chain that registered         * the event using the control.on() method will receive the event. Propagation will         * always start with the sender, so the sender can both produce and consume the same         * event.         *          * @param {string} name The name of the event to send, cooincides with the name used in the         * control.on() method.         * @param {string} direction='down' Equivalent to {@link plat.events.EventManager.DOWN|EventManager.DOWN}         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.         *          * @returns {void}         */        dispatchEvent(name: string, direction?: 'down', ...args: any[]): void;        /**         * @name dispatchEvent         * @memberof plat.Control         * @kind function         * @access public         * @variation 2         *          * @description         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the          * provided direction mechanism. Controls in the propagation chain that registered         * the event using the control.on() method will receive the event. Propagation will         * always start with the sender, so the sender can both produce and consume the same         * event.         *          * @param {string} name The name of the event to send, cooincides with the name used in the         * control.on() method.         * @param {string} direction='direct' Equivalent to {@link plat.events.EventManager.DIRECT|EventManager.DIRECT}         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.         *          * @returns {void}         */        dispatchEvent(name: string, direction?: 'direct', ...args: any[]): void;        /**         * @name dispatchEvent         * @memberof plat.Control         * @kind function         * @access public         * @variation 3         *          * @description         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the          * provided direction mechanism. Controls in the propagation chain that registered         * the event using the control.on() method will receive the event. Propagation will         * always start with the sender, so the sender can both produce and consume the same         * event.         *          * @param {string} name The name of the event to send, cooincides with the name used in the         * control.on() method.         * @param {string} direction The direction in which to send the event.         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.         *          * @returns {void}         */        dispatchEvent(name: string, direction?: string, ...args: any[]): void;        dispatchEvent(name: string, direction?: string, ...args: any[]) {            var manager = Control.$EventManagerStatic;            if (!manager.hasDirection(direction)) {                if (!isUndefined(direction)) {                    args.unshift(direction);                }                direction = manager.UP;            }            var sender: any = this;            if (!isNull(sender.templateControl)) {                sender = sender.templateControl;            }            manager.dispatch(name, sender, direction, args);        }        /**         * @name on         * @memberof plat.Control         * @kind function         * @access public         *          * @description         * Registers a listener for a {@link plat.events.DispatchEvent|DispatchEvent}. The listener will be called when a {@link plat.events.DispatchEvent|DispatchEvent} is          * propagating over the control. Any number of listeners can exist for a single event name.         *          * @param {string} name The name of the event, cooinciding with the {@link plat.events.DispatchEvent|DispatchEvent} name.         * @param {(ev: plat.events.IDispatchEventInstance, ...args: Array<any>) => void} listener The method called when the {@link plat.events.DispatchEvent|DispatchEvent} is fired.         *          * @returns {plat.IRemoveListener} A function to call in order to stop listening for this event.         */        on(name: string, listener: (ev: events.IDispatchEventInstance, ...args: any[]) => void): IRemoveListener {            var manager = Control.$EventManagerStatic;            return manager.on(this.uid, name, listener, this);        }        /**         * @name dispose         * @memberof plat.Control         * @kind function         * @access public         * @virtual         *          * @description         * The dispose event is called when a control is being removed from memory. A control should release          * all of the memory it is using, including DOM event and property listeners.         *          * @returns {void}         */        dispose(): void { }    }    /**     * The Type for referencing the '$ControlFactory' injectable as a dependency.     */    export function IControlFactory(        $Parser?: expressions.IParser,        $ContextManagerStatic?: observable.IContextManagerStatic,        $EventManagerStatic?: events.IEventManagerStatic): IControlFactory {            Control.$Parser = $Parser;            Control.$ContextManagerStatic = $ContextManagerStatic;            Control.$EventManagerStatic = $EventManagerStatic;            return Control;    }    register.injectable(__ControlFactory, IControlFactory, [        __Parser,        __ContextManagerStatic,        __EventManagerStatic    ], __FACTORY);    /**     * @name IControlFactory     * @memberof plat     * @kind interface     *      * @description     * Creates and manages instances of {@link plat.IControl|IControl}.     */    export interface IControlFactory {        /**         * @name getRootControl         * @memberof plat.IControlFactory         * @kind function         * @access public         * @static         *          * @description         * Finds the ancestor control for the given control that contains the root          * context.         *          * @param {plat.IControl} control The control with which to find the root.         *          * @returns {plat.ui.ITemplateControl} The root control.         */        getRootControl(control: IControl): ui.ITemplateControl;        /**         * @name load         * @memberof plat.IControlFactory         * @kind function         * @access public         * @static         *          * @description         * Given a control, calls the loaded method for the control if it exists.         *          * @param {plat.IControl} control The control to load.         *          * @returns {void}         */        load(control: IControl): void;        /**         * @name dispose         * @memberof plat.IControlFactory         * @kind function         * @access public         * @static         *          * @description         * Disposes all the necessary memory for a control. Uses specific dispose          * methods related to a control's constructor if necessary.         *          * @param {plat.IControl} control The {@link plat.Control|Control} to dispose.         *          * @returns {void}         */        dispose(control: IControl): void;        /**         * @name removeParent         * @memberof plat.IControlFactory         * @kind function         * @access public         * @static         *          * @description         * Splices a control from its parent's controls list. Sets the control's parent          * to null.         *          * @param {plat.IControl} control The control whose parent will be removed.         *          * @returns {void}         */        removeParent(control: IControl): void;        /**         * @name removeEventListeners         * @memberof plat.IControlFactory         * @kind function         * @access public         * @static         *          * @description         * Removes all event listeners for a control with the given uid.         *          * @param {plat.IControl} control The control having its event listeners removed.         *          * @returns {void}         */        removeEventListeners(control: IControl): void;        /**         * @name getInstance         * @memberof plat.IControlFactory         * @kind function         * @access public         * @static         *          * @description         * Returns a new instance of {@link plat.Control|Control}.         *          * @returns {plat.IControl} The newly instantiated control.         */        getInstance(): IControl;    }    /**     * @name IControl     * @memberof plat     * @kind interface     *      * @description     * Used for facilitating data and DOM manipulation. Contains lifecycle events      * as well as properties for communicating with other controls. This is the base     * class for all types of controls.     */    export interface IControl {        /**         * @name uid         * @memberof plat.IControl         * @kind property         * @access public         * @readonly         *          * @type {string}         *          * @description         * A unique id, created during instantiation and found on every {@link plat.Control|Control}.         */        uid: string;        /**         * @name name         * @memberof plat.IControl         * @kind property         * @access public         * @readonly         *          * @type {string}         *          * @description         * The name of a {@link plat.Control|Control}.         */        name?: string;        /**         * @name type         * @memberof plat.IControl         * @kind property         * @access public         * @readonly         *          * @type {string}         *          * @description         * The type of a {@link plat.Control|Control}.         */        type?: string;        /**         * @name priority         * @memberof plat.IControl         * @kind property         * @access public         *          * @type {number}         *          * @description         * Specifies the priority of the control. The purpose of          * this is so that controls like plat-bind can have a higher          * priority than plat-tap. The plat-bind will be initialized          * and loaded before plat-tap, meaning it has the first chance          * to respond to events.         */        priority?: number;        /**         * @name parent         * @memberof plat.IControl         * @kind property         * @access public         * @readonly         *          * @type {plat.ui.ITemplateControl}         *          * @description         * The parent control that created this control.         */        parent?: ui.ITemplateControl;        /**         * @name element         * @memberof plat.IControl         * @kind property         * @access public         *          * @type {HTMLElement}         *          * @description         * The HTMLElement that represents this {@link plat.Control|Control}. Should only be modified by controls that implement          * {plat.ui.ITemplateControl|ITemplateControl}. During initialize the control should populate this element with what it wishes         * to render to the user.          *          * @remarks         * When there is innerHTML in the element prior to instantiating the control:         *     The element will include the innerHTML         * When the control implements templateString or templateUrl:         *     The serialized DOM will be auto-generated and included in the element. Any         *     innerHTML will be stored in the innerTemplate property on the control.         * After an {@link plat.IControl|IControl} is initialized its element will be compiled.         */        element?: HTMLElement;        /**         * @name attributes         * @memberof plat.IControl         * @kind property         * @access public         *          * @type {plat.ui.IAttributesInstance}         *          * @description         * The attributes object representing all the attributes for a {@link plat.Control|Control's} element. All attributes are          * converted from dash notation to camelCase.         */        attributes?: ui.IAttributesInstance;        /**         * @name dom         * @memberof plat.IControl         * @kind property         * @access public         * @readonly         *          * @type {plat.ui.IDom}         *          * @description         * Contains DOM helper methods for manipulating this control's element.         */        dom: ui.IDom;        /**         * @name initialize         * @memberof plat.IControl         * @kind function         * @access public         * @virtual         *          * @description         * The initialize event method for a control. In this method a control should initialize all the necessary          * variables. This method is typically only necessary for view controls. If a control does not implement          * {@link plat.ui.IBaseViewControl|IBaseViewControl} then it is not safe to access, observe, or modify          * the context property in this method. A view control should call services/set context in this method in          * order to fire the loaded event. No control will be loaded until the view control has specified a context.         *          * @returns {void}         */        initialize? (): void;        /**         * @name loaded         * @memberof plat.IControl         * @kind function         * @access public         * @virtual         *          * @description         * The loaded event method for a control. This event is fired after a control has been loaded,         * meaning all of its children have also been loaded and initial DOM has been created and populated. It is now          * safe for all controls to access, observe, and modify the context property.         *          * @returns {void}         */        loaded? (): void;        /**         * @name getControlsByName         * @memberof plat.Control         * @kind function         * @access public         *          * @description         * Retrieves all the controls with the specified name.         *          * @param {string} name The string name with which to populate the returned controls array.         *          * @returns {Array<plat.IControl>} The controls that match the input name.         */        getControlsByName? (name: string): Array<IControl>;        /**         * @name getControlsByType         * @memberof plat.IControl         * @kind function         * @access public         * @variation 0         *          * @description         * Retrieves all the controls of the specified type.         *          * @typeparam {plat.Control} T The type of control to be returned in an Array.         *          * @param {string} type The type used to find controls (e.g. 'plat-foreach')         *          * @returns {Array<T>} The controls matching the input type.         */        getControlsByType? <T extends IControl>(type: string): Array<T>;        /**         * @name getControlsByType         * @memberof plat.IControl         * @kind function         * @access public         * @variation 1         *          * @description         * Retrieves all the controls of the specified type.         *          * @typeparam {plat.Control} T The type of control to be returned in an Array.         *          * @param {new () => T} Constructor The constructor used to find controls.         *          * @returns {Array<T>} The controls matching the input type.         */        getControlsByType? <T extends IControl>(Constructor: new () => T): Array<T>;        /**         * @name addEventListener         * @memberof plat.IControl         * @kind function         * @access public         * @variation 0         *          * @description         * Adds an event listener of the specified type to the specified element. Removal of the          * event is handled automatically upon disposal.         *          * @param {EventTarget} element The element to add the event listener to.         * @param {string} type The type of event to listen to.         * @param {plat.ui.IGestureListener} listener The listener to fire when the event occurs.         * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase          * of event propagation.         *          * @returns {plat.IRemoveListener} A function to call in order to stop listening to the event.         */        addEventListener? (element: EventTarget, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener;        /**         * @name addEventListener         * @memberof plat.IControl         * @kind function         * @access public         * @variation 1         *          * @description         * Adds an event listener of the specified type to the specified element. Removal of the          * event is handled automatically upon disposal.         *          * @param {EventTarget} element The element to add the event listener to.         * @param {string}  type The type of event to listen to.         * @param {EventListener} listener The listener to fire when the event occurs.         * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase          * of event propagation.         *          * @returns {plat.IRemoveListener} A function to call in order to stop listening to the event.         */        addEventListener? (element: EventTarget, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;        /**         * @name observe         * @memberof plat.IControl         * @kind function         * @access public         * @variation 0         *          * @description         * Allows a {@link plat.Control|Control} to observe any property on its context and receive updates when         * the property is changed.         *          * @typeparam {any} T The type of object to observe.         *          * @param {any} context The immediate parent object containing the property.         * @param {string} property The property identifier to watch for changes.         * @param {(value: T, oldValue: T) => void} listener The method called when the property is changed. This method will have its 'this'         * context set to the control instance.         *          * @returns {plat.IRemoveListener} A function to call in order to stop observing the property.         */        observe? <T>(context: any, property: string, listener: (value: T, oldValue: T) => void): IRemoveListener;        /**         * @name observe         * @memberof plat.IControl         * @kind function         * @access public         * @variation 1         *          * @description         * Allows a {@link plat.Control|Control} to observe any property on its context and receive updates when         * the property is changed.         *          * @typeparam {any} T The type of object to observe.         *          * @param {any} context The immediate parent object containing the property.         * @param {number} property The property identifier to watch for changes.         * @param {(value: T, oldValue: T) => void} listener The method called when the property is changed. This method will have its 'this'         * context set to the control instance.         *          * @returns {plat.IRemoveListener} A function to call in order to stop observing the property.         */        observe? <T>(context: any, property: number, listener: (value: T, oldValue: T) => void): IRemoveListener;        /**         * @name observeArray         * @memberof plat.IControl         * @kind function         * @access public         * @variation 0         *          * @description         * Allows a {@link plat.Control|Control} to observe an array and receive updates when certain array-changing methods are called.         * The methods watched are push, pop, shift, sort, splice, reverse, and unshift. This method does not watch         * every item in the array.         *          * @typeparam {any} T The type of the Array to observe.         *          * @param {any} context The immediate parent object containing the array as a property.         * @param {string} property The array property identifier to watch for changes.         * @param {(ev: plat.observable.IArrayMethodInfo<T>) => void} listener The method called when an array-changing method is called. This method will have its 'this'         * context set to the control instance.         *          * @returns {plat.IRemoveListener} A function to call in order to stop observing the array.         */        observeArray? <T>(context: any, property: string, listener: (ev: observable.IArrayMethodInfo<T>) => void): IRemoveListener;        /**         * @name observeArray         * @memberof plat.IControl         * @kind function         * @access public         * @variation 1         *          * @description         * Allows a {@link plat.Control|Control} to observe an array and receive updates when certain array-changing methods are called.         * The methods watched are push, pop, shift, sort, splice, reverse, and unshift. This method does not watch         * every item in the array.         *          * @typeparam {any} T The type of the Array to observe.         *          * @param {any} context The immediate parent object containing the array as a property.         * @param {number} property The array property identifier to watch for changes.         * @param {(ev: plat.observable.IArrayMethodInfo<T>) => void} listener The method called when an array-changing method is called. This method will have its 'this'         * context set to the control instance.         *          * @returns {plat.IRemoveListener} A function to call in order to stop observing the array.         */        observeArray? <T>(context: any, property: number, listener: (ev: observable.IArrayMethodInfo<T>) => void): IRemoveListener;        /**         * @name observeExpression         * @memberof plat.IControl         * @kind function         * @access public         * @variation 0         *          * @description         * Parses an expression string and observes any associated identifiers. When an identifier         * value changes, the listener will be called.         *          * @param {string} expression The expression string to watch for changes.         * @param {(value: any, oldValue: any) => void} listener The listener to call when the expression identifer values change.         *          * @returns {plat.IRemoveListener} A function to call in order to stop observing the expression.         */        observeExpression? (expression: string, listener: (value: any, oldValue: any) => void): IRemoveListener;        /**         * @name observeExpression         * @memberof plat.IControl         * @kind function         * @access public         * @variation 1         *          * @description         * Using a {@link plat.expressions.IParsedExpression|IParsedExpression} observes any associated identifiers. When an identifier         * value changes, the listener will be called.         *          * @param {plat.expressions.IParsedExpression} expression The expression string to watch for changes.         * @param {(value: any, oldValue: any) => void} listener The listener to call when the expression identifer values change.         *          * @returns {plat.IRemoveListener} A function to call in order to stop observing the expression.         */        observeExpression? (expression: expressions.IParsedExpression, listener: (value: any, oldValue: any) => void): IRemoveListener;        /**         * @name evaluateExpression         * @memberof plat.IControl         * @kind function         * @access public         * @variation 0         *          * @description         * Evaluates an expression string, using the control.parent.context.         *          * @param {string} expression The expression string to evaluate.         * @param {any} aliases Optional alias values to parse with the expression         *          * @returns {any} The evaluated expression         */        evaluateExpression? (expression: string, aliases?: any): any;        /**         * @name evaluateExpression         * @memberof plat.IControl         * @kind function         * @access public         * @variation 1         *          * @description         * Evaluates an {@link plat.expressions.IParsedExpression|IParsedExpression} using the control.parent.context.         *          * @param {string} expression The expression string to evaluate.         * @param {any} aliases Optional alias values to parse with the expression         *          * @returns {any} The evaluated expression         */        evaluateExpression? (expression: expressions.IParsedExpression, aliases?: any): any;        /**         * @name dispatchEvent         * @memberof plat.IControl         * @kind function         * @access public         * @variation 0         *          * @description         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the          * provided direction mechanism. Controls in the propagation chain that registered         * the event using the control.on() method will receive the event. Propagation will         * always start with the sender, so the sender can both produce and consume the same         * event.         *          * @param {string} name The name of the event to send, cooincides with the name used in the         * control.on() method.         * @param {string} direction='up' Equivalent to {@link plat.events.EventManager.UP|EventManager.UP}         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.         *          * @returns {void}         */        dispatchEvent? (name: string, direction?: 'up', ...args: any[]): void;        /**         * @name dispatchEvent         * @memberof plat.IControl         * @kind function         * @access public         * @variation 1         *          * @description         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the          * provided direction mechanism. Controls in the propagation chain that registered         * the event using the control.on() method will receive the event. Propagation will         * always start with the sender, so the sender can both produce and consume the same         * event.         *          * @param {string} name The name of the event to send, cooincides with the name used in the         * control.on() method.         * @param {string} direction='down' Equivalent to {@link plat.events.EventManager.DOWN|EventManager.DOWN}         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.         *          * @returns {void}         */        dispatchEvent? (name: string, direction?: 'down', ...args: any[]): void;        /**         * @name dispatchEvent         * @memberof plat.IControl         * @kind function         * @access public         * @variation 2         *          * @description         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the          * provided direction mechanism. Controls in the propagation chain that registered         * the event using the control.on() method will receive the event. Propagation will         * always start with the sender, so the sender can both produce and consume the same         * event.         *          * @param {string} name The name of the event to send, cooincides with the name used in the         * control.on() method.         * @param {string} direction='direct' Equivalent to {@link plat.events.EventManager.DIRECT|EventManager.DIRECT}         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.         *          * @returns {void}         */        dispatchEvent? (name: string, direction?: 'direct', ...args: any[]): void;        /**         * @name dispatchEvent         * @memberof plat.IControl         * @kind function         * @access public         * @variation 3         *          * @description         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to controls based on the          * provided direction mechanism. Controls in the propagation chain that registered         * the event using the control.on() method will receive the event. Propagation will         * always start with the sender, so the sender can both produce and consume the same         * event.         *          * @param {string} name The name of the event to send, cooincides with the name used in the         * control.on() method.         * @param {string} direction The direction in which to send the event.         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.         *          * @returns {void}         */        dispatchEvent? (name: string, direction?: string, ...args: any[]): void;        /**         * @name on         * @memberof plat.IControl         * @kind function         * @access public         *          * @description         * Registers a listener for a {@link plat.events.DispatchEvent|DispatchEvent}. The listener will be called when a {@link plat.events.DispatchEvent|DispatchEvent} is          * propagating over the control. Any number of listeners can exist for a single event name.         *          * @param {string} name The name of the event, cooinciding with the {@link plat.events.DispatchEvent|DispatchEvent} name.         * @param {(ev: plat.events.IDispatchEventInstance, ...args: Array<any>) => void} listener The method called when the {@link plat.events.DispatchEvent|DispatchEvent} is fired.         *          * @returns {plat.IRemoveListener} A function to call in order to stop listening for this event.         */        on? (name: string, listener: (ev: events.IDispatchEventInstance, ...args: any[]) => void): IRemoveListener;        /**         * @name dispose         * @memberof plat.IControl         * @kind function         * @access public         * @virtual         *          * @description         * The dispose event is called when a control is being removed from memory. A control should release          * all of the memory it is using, including DOM event and property listeners.         *          * @returns {void}         */        dispose? (): void;    }    /**     * @name controls     * @memberof plat     * @kind namespace     *      * @description     * Holds all attribute controls     */    export module controls {        /**         * @name AttributeControl         * @memberof plat.controls         * @kind class         * @access public         *          * @extends {plat.Control}         * @implements {plat.controls.IAttributeControl}         *          * @description         * A type of control that can be used as an attribute but will          * not be used to add, remove, or modify DOM.         */        export class AttributeControl extends Control implements IAttributeControl {            /**             * @name dispose             * @memberof plat.controls.AttributeControl             * @kind function             * @access public             * @static             *              * @description             * Method for disposing an attribute control. Removes any              * necessary objects from the control.             *              * @param {plat.IAttributeControl} control The {@link plat.controls.AttributeControl|AttributeControl} to dispose.             *              * @returns {void}             */            static dispose(control: IAttributeControl): void {                deleteProperty(control, 'templateControl');                Control.dispose(control);            }            /**             * @name getInstance             * @memberof plat.controls.AttributeControl             * @kind function             * @access public             * @static             *              * @description             * Returns a new instance of {@link plat.controls.AttributeControl|AttributeControl}.             *              * @returns {plat.IAttributeControl}             */            static getInstance(): IAttributeControl {                return new AttributeControl();            }            /**             * @name templateControl             * @memberof plat.controls.AttributeControl             * @kind property             * @access public             *              * @type {plat.ui.ITemplateControl}             *              * @description             * Specifies the {@link plat.ui.ITemplateControl|ITemplateControl} associated with this             * control's element. Can be null if no {@link plat.ui.ITemplateControl|ITemplateControl}             * exists.             */            templateControl: ui.ITemplateControl = null;        }        /**         * The Type for referencing the '$AttributeControlFactory' injectable as a dependency.         */        export function IAttributeControlFactory(): IAttributeControlFactory {            return AttributeControl;        }        register.injectable(__AttributeControlFactory, IAttributeControlFactory, null, __FACTORY);        /**         * @name IAttributeControlFactory         * @memberof plat.controls         * @kind interface         *          * @description         * Creates and manages instances of {@link plat.controls.IAttributeControl|IAttributeControl}.         */        export interface IAttributeControlFactory {            /**             * @name dispose             * @memberof plat.controls.IAttributeControlFactory             * @kind function             * @access public             * @static             *              * @description             * Method for disposing an attribute control. Removes any              * necessary objects from the control.             *              * @param {plat.IAttributeControl} control The {@link plat.controls.AttributeControl|AttributeControl} to dispose.             *              * @returns {void}             */            dispose(control: IAttributeControl): void;            /**             * @name getInstance             * @memberof plat.controls.IAttributeControlFactory             * @kind function             * @access public             * @static             *              * @description             * Returns a new instance of {@link plat.controls.AttributeControl|AttributeControl}.             *              * @returns {plat.IAttributeControl}             */            getInstance(): IAttributeControl;        }        /**         * @name IAttributeControl         * @memberof plat.controls         * @kind interface         * @access public         *          * @extends {plat.IControl}         *          * @description         * An object describing a type of control that can be used as an attribute but will          * not be used to add, remove, or modify DOM.         */        export interface IAttributeControl extends IControl {            /**             * @name templateControl             * @memberof plat.controls.IAttributeControl             * @kind property             * @access public             *              * @type {plat.ui.ITemplateControl}             *              * @description             * Specifies the {@link plat.ui.ITemplateControl|ITemplateControl} associated with this             * control's element. Can be null if no {@link plat.ui.ITemplateControl|ITemplateControl}             * exists.             */            templateControl?: ui.ITemplateControl;        }        /**         * @name Name         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.AttributeControl}         *          * @description         * Allows for assigning a name to an Element or {@link plat.ui.TemplateControl|TemplateControl} and referencing it          * from parent controls.         *          * @remarks         * This control is useful for avoiding query selectors since it will store itself on all of its ancestor controls using          * the associated name.         */        export class Name extends AttributeControl {            /**             * @name _label             * @memberof plat.controls.Name             * @kind property             * @access protected             * @static             *              * @type {string}             *              * @description             * The property name on the ancestor controls to set as the {@link plat.controls.INamedElement|INamedElement}.             */            _label: string;            /**             * @name initialize             * @memberof plat.controls.Name             * @kind function             * @access public             *              * @description             * Defines the property specified by the attribute value as the {@link plat.controls.INamedElement|INamedElement}              * on all the ancestor controls, ignoring those that already have the property defined.             *              * @returns {void}             */            initialize(): void {                var attr = camelCase(this.type),                    name = (<any>this.attributes)[attr];                if (isEmpty(name) || this._isPrecompiled()) {                    return;                }                this._label = name;                this._define(name);            }            /**             * @name dispose             * @memberof plat.controls.Name             * @kind function             * @access public             *              * @description             * Removes the {@link plat.controls.INamedElement|INamedElement} from the ancestor controls.             *              * @returns {void}             */            dispose(): void {                var name = this._label,                    control: any = this.parent;                while (!isUndefined(name) && isObject(control)) {                    if (isObject(control[name]) &&                        isNode(control[name].element) &&                        control[name].element === this.element) {                        deleteProperty(control, name);                    }                    control = control.parent;                }            }            /**             * @name _define             * @memberof plat.controls.Name             * @kind function             * @access protected             *              * @description             * Defines the property specified by the attribute value as the {@link plat.controls.INamedElement|INamedElement}              * on all the ancestor controls, ignoring those that already have the property defined.             *              * @param {string} name The name to define on all the ancestor controls.             *              * @returns {void}             */            _define(name: string): void {                var templateControl = this.templateControl;                if (!isNull(templateControl)) {                    templateControl.name = name;                }                var control: any = this.parent,                    namedElement = {                        element: this.element,                        control: templateControl                    };                while (isObject(control)) {                    var obj = control[name];                    if (!isObject(obj)) {                        control[name] = namedElement;                    }                    control = control.parent;                }            }            /**             * @name _isPrecompiled             * @memberof plat.controls.Name             * @kind function             * @access protected             *              * @description             * Determines whether or not this control is part of a pre-compiled control tree. In the event              * that it is, it shouldn't set itself on the ancestor controls.             *              * @param {string} name The name to define on all the ancestor controls.             *              * @returns {void}             */            _isPrecompiled(): boolean {                var control = this.parent;                while (!isNull(control)) {                    if (control.type.indexOf(__COMPILED) !== -1) {                        return true;                    }                    control = control.parent;                }                return false;            }        }        register.control(__Name, Name);        /**         * @name INamedElement         * @memberof plat.controls         * @kind interface         *          * @description         * Defines the object added to a root control when an HTML element has          * a plat-name attribute. If the element corresponds to a registered          * control, the control will be included in the object.         *          * @typeparam {Element} E The type of element that is named.         * @typeparam {any} C The type of control that is named.         */        export interface INamedElement<E extends Element, C> {            /**             * @name element             * @memberof plat.controls.INamedElement             * @kind property             *              * @type {E}             *              * @description             * The element on which the plat-name is specified.             */            element: E;            /**             * @name control             * @memberof plat.controls.INamedElement             * @kind property             *              * @type {C}             *              * @description             * The template control on the associated element, if one              * exists.             */            control?: C;        }        /**         * @name SimpleEventControl         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.AttributeControl}         * @implements {plat.controls.ISimpleEventControl}         *          * @description         * An {@link plat.controls.AttributeControl|AttributeControl} that binds to a specified DOM event handler.         */        export class SimpleEventControl extends AttributeControl implements ISimpleEventControl {            /**             * @name $Parser             * @memberof plat.controls.SimpleEventControl             * @kind property             * @access public             *              * @type {plat.expressions.IParser}             *              * @description             * Reference to the {@link plat.expressions.IParser|IParser} injectable.             */            $Parser: expressions.IParser = acquire(__Parser);            /**             * @name $Regex             * @memberof plat.controls.SimpleEventControl             * @kind property             * @access public             *              * @type {plat.expressions.IRegex}             *              * @description             * Reference to the {@link plat.expressions.IRegex|IRegex} injectable.             */            $Regex: expressions.IRegex = acquire(__Regex);            /**             * @name event             * @memberof plat.controls.SimpleEventControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string;            /**             * @name attribute             * @memberof plat.controls.SimpleEventControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The camel-cased name of the control as it appears as an attribute.             */            attribute: string;            /**             * @name _expression             * @memberof plat.controls.SimpleEventControl             * @kind property             * @access protected             *              * @type {Array<string>}             *              * @description             * A parsed form of the expression found in the attribute's value.             */            _expression: Array<string> = [];            /**             * @name _aliases             * @memberof plat.controls.SimpleEventControl             * @kind property             * @access protected             *              * @type {Array<string>}             *              * @description             * An array of the aliases used in the expression.             */            _aliases: Array<string> = [];            /**             * @name loaded             * @memberof plat.controls.SimpleEventControl             * @kind function             * @access public             *              * @description             * Kicks off finding and setting the listener.             *              * @returns {void}             */            loaded(): void {                if (isNull(this.element)) {                    return;                }                this.attribute = camelCase(this.type);                this._setListener();            }            /**             * @name _setListener             * @memberof plat.controls.SimpleEventControl             * @kind function             * @access protected             *              * @description             * Sets the event listener.             *              * @returns {void}             */            _setListener(): void {                var attr = this.attribute;                if (isEmpty(this.event) || isEmpty(attr)) {                    return;                }                this._parseArgs((<any>this.attributes)[attr]);                if (isNull(this._expression)) {                    return;                }                this.addEventListener(this.element, this.event, this._onEvent, false);            }            /**             * @name _findListener             * @memberof plat.controls.SimpleEventControl             * @kind function             * @access protected             *              * @description             * Finds the first instance of the specified function              * in the parent control chain.             *              * @param {string} identifier the function identifer             *              * @returns {{ control: ui.ITemplateControl; value: any; }} The instance of the specified function.             */            _findListener(identifier: string): { control: ui.ITemplateControl; value: any; } {                var control: ui.ITemplateControl = <any>this,                    expression = this.$Parser.parse(identifier),                    value: any;                while (!isNull(control)) {                    value = expression.evaluate(control);                    if (!isNull(value)) {                        return {                            control: control,                            value: value                        };                    }                    control = control.parent;                }                return {                    control: null,                    value: null                };            }            /**             * @name _buildExpression             * @memberof plat.controls.SimpleEventControl             * @kind function             * @access protected             *              * @description             * Constructs the function to evaluate with              * the evaluated arguments taking resources              * into account.             *              * @returns {{ fn: () => void; control: ui.ITemplateControl; args: Array<expressions.IParsedExpression>; }}              * The function to call and the associated arguments, as well as the control context with which to call the function.             */            _buildExpression(): { fn: () => void; control: ui.ITemplateControl; args: Array<expressions.IParsedExpression>; } {                var expression = this._expression.slice(0),                    hasParent = !isNull(this.parent),                    aliases = hasParent ? this.parent.getResources(this._aliases) : null,                    listenerStr = expression.shift(),                    listener: { control: ui.ITemplateControl; value: any; },                    control: ui.ITemplateControl,                    fn: () => void;                if (listenerStr[0] !== '@') {                    listener = this._findListener(listenerStr);                    if (isNull(listener)) {                        return {                            fn: noop,                            control: <ui.ITemplateControl>{},                            args: []                        };                    }                    fn = listener.value;                    control = listener.control;                } else {                    fn = aliases[listenerStr];                    control = null;                }                var length = expression.length,                    args: Array<expressions.IParsedExpression> = [],                    $parser = this.$Parser;                for (var i = 0; i < length; ++i) {                    args.push($parser.parse(expression[i]).evaluate(hasParent ? this.parent.context : null, aliases));                }                return {                    fn: fn,                    control: control,                    args: args                };            }            /**             * @name _onEvent             * @memberof plat.controls.SimpleEventControl             * @kind function             * @access protected             *              * @description             * Calls the specified function when the DOM event is fired.             *              * @param {Event} ev The event object.             *              * @returns {void}             */            _onEvent(ev: Event): void {                var expression = this._buildExpression(),                    fn = expression.fn,                    control = expression.control,                    args = expression.args;                if (!isFunction(fn)) {                    var $exception: IExceptionStatic = acquire(__ExceptionStatic);                    $exception.warn('Cannot find registered event method ' +                        this._expression[0] + ' for control: ' + this.type, $exception.BIND);                    return;                }                fn.apply(control, args.concat(<any>ev));            }            /**             * @name _findAliases             * @memberof plat.controls.SimpleEventControl             * @kind function             * @access protected             *              * @description             * Finds all alias contained within the expression.             *              * @param {Array<string>} args The array of arguments as strings.             *              * @returns {Array<string>} The aliases.             */            _findAliases(args: Array<string>): Array<string> {                var length = args.length,                    arg: string,                    exec: RegExpExecArray,                    aliases: IObject<boolean> = {},                    $regex = this.$Regex;                for (var i = 0; i < length; ++i) {                    arg = args[i].trim();                    if (arg[0] === '@') {                        exec = $regex.aliasRegex.exec(arg);                        aliases[!isNull(exec) ? exec[0] : arg.substr(1)] = true;                    }                }                return Object.keys(aliases);            }            /**             * @name _parseArgs             * @memberof plat.controls.SimpleEventControl             * @kind function             * @access protected             *              * @description             * Parses the expression and separates the function              * from its arguments.             *              * @param {string} expression The expression to parse.             *              * @returns {void}             */            _parseArgs(expression: string): void {                var exec = this.$Regex.argumentRegex.exec(expression),                    haveArgs = !isNull(exec);                if (isEmpty(expression)) {                    return;                }                if (haveArgs) {                    this._expression = [expression.slice(0, exec.index)]                        .concat((exec[1] !== '') ? exec[1].split(',') : []);                } else {                    this._expression.push(expression);                }                this._aliases = this._findAliases(this._expression);            }        }        /**         * @name ISimpleEventControl         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.IAttributeControl}         *          * @description         * An {@link plat.controls.IAttributeControl|IAttributeControl} that binds to a specified DOM event handler.         */        export interface ISimpleEventControl extends IAttributeControl {            /**             * @name event             * @memberof plat.controls.ISimpleEventControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string;            /**             * @name attribute             * @memberof plat.controls.ISimpleEventControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The camel-cased name of the control as it appears as an attribute.             */            attribute: string;        }        /**         * @name Tap         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$tap' event.         */        export class Tap extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.Tap             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$tap;        }        /**         * @name Blur         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the 'blur' event.         */        export class Blur extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.Blur             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = 'blur';        }        /**         * @name Change         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the 'change' event.         */        export class Change extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.Change             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = 'change';        }        /**         * @name Copy         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the 'copy' event.         */        export class Copy extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.Copy             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = 'copy';        }        /**         * @name Cut         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the 'cut' event.         */        export class Cut extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.Cut             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = 'cut';        }        /**         * @name Paste         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the 'paste' event.         */        export class Paste extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.Paste             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = 'paste';        }        /**         * @name DblTap         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$dbltap' event.         */        export class DblTap extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.DblTap             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$dbltap;        }        /**         * @name Focus         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the 'focus' event.         */        export class Focus extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.Focus             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = 'focus';        }        /**         * @name TouchStart         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$touchstart' event.         */        export class TouchStart extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.TouchStart             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$touchstart;        }        /**         * @name TouchEnd         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$touchend' event.         */        export class TouchEnd extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.TouchEnd             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$touchend;        }        /**         * @name TouchMove         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$touchmove' event.         */        export class TouchMove extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.TouchMove             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$touchmove;        }        /**         * @name TouchCancel         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$touchcancel' event.         */        export class TouchCancel extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.TouchCancel             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$touchcancel;        }        /**         * @name Hold         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$hold' event.         */        export class Hold extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.Hold             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$hold;        }        /**         * @name Release         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$release' event.         */        export class Release extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.Release             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$release;        }        /**         * @name Swipe         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$swipe' event.         */        export class Swipe extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.Swipe             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$swipe;        }        /**         * @name SwipeLeft         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$swipeleft' event.         */        export class SwipeLeft extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.SwipeLeft             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$swipeleft;        }        /**         * @name SwipeRight         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$swiperight' event.         */        export class SwipeRight extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.SwipeRight             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$swiperight;        }        /**         * @name SwipeUp         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$swipeup' event.         */        export class SwipeUp extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.SwipeUp             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$swipeup;        }        /**         * @name SwipeDown         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$swipedown' event.         */        export class SwipeDown extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.SwipeDown             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$swipedown;        }        /**         * @name Track         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$track' event.         */        export class Track extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.Track             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$track;        }        /**         * @name TrackLeft         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$trackleft' event.         */        export class TrackLeft extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.TrackLeft             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$trackleft;        }        /**         * @name TrackRight         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$trackright' event.         */        export class TrackRight extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.TrackRight             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$trackright;        }        /**         * @name TrackUp         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$trackup' event.         */        export class TrackUp extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.TrackUp             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$trackup;        }        /**         * @name TrackDown         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$trackdown' event.         */        export class TrackDown extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.TrackDown             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$trackdown;        }        /**         * @name TrackEnd         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the '$trackend' event.         */        export class TrackEnd extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.TrackEnd             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = __$trackend;        }        /**         * @name Submit         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         *          * @description         * A {@link plat.controls.SimpleEventControl|SimpleEventControl} for the 'submit' event.         */        export class Submit extends SimpleEventControl {            /**             * @name event             * @memberof plat.controls.Submit             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = 'submit';            /**             * @name _onEvent             * @memberof plat.controls.SimpleEventControl             * @kind function             * @access protected             *              * @description             * Prevents the default submit action unless              * the "action" attribute is present.             *              * @param {Event} ev The event object.             */            _onEvent(ev: Event): void {                if (!this.element.hasAttribute('action')) {                    ev.preventDefault();                }                super._onEvent(ev);            }        }        register.control(__Tap, Tap);        register.control(__Blur, Blur);        register.control(__Change, Change);        register.control(__Copy, Copy);        register.control(__Cut, Cut);        register.control(__Paste, Paste);        register.control(__DblTap, DblTap);        register.control(__Focus, Focus);        register.control(__Submit, Submit);        register.control(__TouchStart, TouchStart);        register.control(__TouchEnd, TouchEnd);        register.control(__TouchMove, TouchMove);        register.control(__TouchCancel, TouchCancel);        register.control(__Hold, Hold);        register.control(__Release, Release);        register.control(__Swipe, Swipe);        register.control(__SwipeLeft, SwipeLeft);        register.control(__SwipeRight, SwipeRight);        register.control(__SwipeUp, SwipeUp);        register.control(__SwipeDown, SwipeDown);        register.control(__Track, Track);        register.control(__TrackLeft, TrackLeft);        register.control(__TrackRight, TrackRight);        register.control(__TrackUp, TrackUp);        register.control(__TrackDown, TrackDown);        register.control(__TrackEnd, TrackEnd);        /**         * @name KeyCodes         * @memberof plat.controls         * @kind property         * @access public         *          * @type {any}         *          * @description         * A mapping of all keys to their equivalent keyCode.         */        export var KeyCodes = {            'backspace': 8,            'tab': 9,            'enter': 13,            'shift': 16,            'ctrl': 17,            'alt': 18,            'pause': 19, 'break': 19,            'caps lock': 20,            'escape': 27,            'space': 32,            'page up': 33,            'page down': 34,            'end': 35,            'home': 36,            'left': 37, 'left arrow': 37,            'up': 38, 'up arrow': 38,            'right': 39, 'right arrow': 39,            'down': 40, 'down arrow': 40,            'insert': 45,            'delete': 46,            '0': 48, 'zero': 48,            ')': 48, 'right parenthesis': 48,            '1': 49, 'one': 49,            '!': 49, 'exclamation': 49, 'exclamation point': 49,            '2': 50, 'two': 50,            '@': 50, 'at': 50,            '3': 51, 'three': 51,            '#': 51, 'number sign': 51,            'hash': 51, 'pound': 51,            '4': 52, 'four': 52,            '$': 52, 'dollar': 52, 'dollar sign': 52,            '5': 53, 'five': 53,            '%': 53, 'percent': 53, 'percent sign': 53,            '6': 54, 'six': 54,            '^': 54, 'caret': 54,            '7': 55, 'seven': 55,            '&': 55, 'ampersand': 55,            '8': 56, 'eight': 56,            '*': 56, 'asterisk': 56,            '9': 57, 'nine': 57,            '(': 57, 'left parenthesis': 57,            'a': 65, 'b': 66, 'c': 67, 'd': 68, 'e': 69,            'f': 70, 'g': 71, 'h': 72, 'i': 73, 'j': 74,            'k': 75, 'l': 76, 'm': 77, 'n': 78, 'o': 79,            'p': 80, 'q': 81, 'r': 82, 's': 83, 't': 84,            'u': 85, 'v': 86, 'w': 87, 'x': 88, 'y': 89,            'z': 90,            'lwk': 91, 'left window key': 91,            'rwk': 92, 'right window key': 92,            'select': 93, 'select key': 93,            'numpad 0': 96,            'numpad 1': 97,            'numpad 2': 98,            'numpad 3': 99,            'numpad 4': 100,            'numpad 5': 101,            'numpad 6': 102,            'numpad 7': 103,            'numpad 8': 104,            'numpad 9': 105,            'multiply': 106,            'add': 107,            'subtract': 109,            'decimal point': 110,            'divide': 111,            'f1': 112, 'f2': 113, 'f3': 114, 'f4': 115,            'f5': 116, 'f6': 117, 'f7': 118, 'f8': 119,            'f9': 120, 'f10': 121, 'f11': 122, 'f12': 123,            'num lock': 144,            'scroll lock': 145,            ';': 186, 'semi-colon': 186,            ':': 186, 'colon': 186,            '=': 187, 'equal': 187, 'equal sign': 187,            '+': 187, 'plus': 187,            ',': 188, 'comma': 188,            '<': 188, 'lt': 188, 'less than': 188,            'left angle bracket': 188,            '-': 189, 'dash': 189,            '_': 189, 'underscore': 189,            '.': 190, 'period': 190,            '>': 190, 'gt': 190, 'greater than': 190,            'right angle bracket': 190,            '/': 191, 'forward slash': 191,            '?': 191, 'question mark': 191,            '`': 192, 'grave accent': 192,            '~': 192, 'tilde': 192,            '[': 219, 'open bracket': 219,            '{': 219, 'open brace': 219,            '\\': 220, 'back slash': 220,            '|': 220, 'pipe': 220,            ']': 221, 'close bracket': 221,            '}': 221, 'close brace': 221,            '\'': 222, 'single quote': 222,            '"': 222, 'double quote': 222        };        /**         * @name KeyCodeEventControl         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SimpleEventControl}         * @implements {plat.controls.IKeyCodeEventControl}         *          * @description         * Base class used for filtering keys on KeyboardEvents.         */        export class KeyCodeEventControl extends SimpleEventControl implements IKeyCodeEventControl {            /**             * @name $Regex             * @memberof plat.controls.KeyCodeEventControl             * @kind property             * @access public             *              * @type {plat.expressions.IRegex}             *              * @description             * Reference to the {@link plat.expressions.IRegex|IRegex} injectable.             */            $Regex: plat.expressions.IRegex = plat.acquire(__Regex);            /**             * @name keyCodes             * @memberof plat.controls.KeyCodeEventControl             * @kind property             * @access public             *              * @type {plat.IObject<{ shifted: boolean; }>}             *              * @description             * Holds the key mappings to filter for in a KeyboardEvent.             */            keyCodes: IObject<{ shifted: boolean; }>;            /**             * @name _setListener             * @memberof plat.controls.KeyCodeEventControl             * @kind function             * @access protected             *              * @description             * Checks if the {@link plat.controls.IKeyboardEventInput|IKeyboardEventInput} is an expression object              * and sets the necessary listener.             *              * @returns {void}             */            _setListener(): void {                var attr = this.attribute;                if (isEmpty(this.event) || isEmpty(attr)) {                    return;                }                var expression = (<any>this.attributes)[attr].trim();                if (expression[0] === '{') {                    var eventObject: IKeyboardEventInput = this.evaluateExpression(expression) ||                        { method: '', key: null },                        key = eventObject.key,                        keys = eventObject.keys;                    this._parseArgs(eventObject.method);                    if (isNull(key) && isNull(keys)) {                        (<any>this.attributes)[attr] = eventObject.method;                        this._setKeyCodes();                        super._setListener();                        return;                    }                    keys = isArray(keys) ? keys : [key];                    this._setKeyCodes(keys);                    this.addEventListener(this.element, this.event, this._onEvent, false);                    return;                }                this._setKeyCodes();                super._setListener();            }            /**             * @name _onEvent             * @memberof plat.controls.KeyCodeEventControl             * @kind function             * @access protected             *              * @description             * Matches the event's keyCode if necessary and then handles the event if              * a match is found or if there are no filter keyCodes.             *              * @param {KeyboardEvent} ev The keyboard event object.             *              * @returns {void}             */            _onEvent(ev: KeyboardEvent): void {                var keyCodes = this.keyCodes,                    code: { shifted?: boolean };                if (isEmpty(keyCodes)) {                    super._onEvent(ev);                } else if (!isUndefined(keyCodes[ev.keyCode])) {                    code = keyCodes[ev.keyCode];                    if (!code.shifted || ev.shiftKey) {                        super._onEvent(ev);                    }                }            }            /**             * @name _setKeyCodes             * @memberof plat.controls.KeyCodeEventControl             * @kind function             * @access protected             *              * @description             * Sets the defined key codes as they correspond to              * the {@link plat.controls.KeyCodes|KeyCodes} map.             *              * @param {Array<string>} keys? The array of defined keys to satisfy the              * key press condition.             *              * @returns {void}             */            _setKeyCodes(keys?: Array<string>): void {                if (!isArray(keys)) {                    keys = [];                }                var length = keys.length,                    key: string,                    keyCodes = this.keyCodes,                    index: string,                    shifted = this.$Regex.shiftedKeyRegex;                if (!isObject(keyCodes)) {                    keyCodes = this.keyCodes = {};                }                for (var i = 0; i < length; ++i) {                    key = keys[i];                    index = isNumber(key) ? key : (<any>KeyCodes)[key.toLowerCase()];                    keyCodes[index] = { shifted: shifted.test(key) };                }            }        }        /**         * @name IKeyCodeEventControl         * @memberof plat.controls         * @kind interface         *          * @extends {plat.controls.ISimpleEventControl}         *          * @description         * An attribute object that binds to specified key code scenarios.         */        export interface IKeyCodeEventControl extends ISimpleEventControl {            /**             * @name keyCodes             * @memberof plat.controls.IKeyCodeEventControl             * @kind property             * @access public             *              * @type {plat.IObject<{ shifted: boolean; }>}             *              * @description             * Holds the key mappings to filter for in a KeyboardEvent.             */            keyCodes: IObject<{ shifted: boolean; }>;        }        /**         * @name IKeyboardEventInput         * @memberof plat.controls         * @kind interface         *          * @description         * The available options for {@link plat.controls.KeyCodeEventControl|KeyCodeEventControl}.         */        export interface IKeyboardEventInput {            /**             * @name method             * @memberof plat.controls.IKeyboardEventInput             * @kind property             * @access public             *              * @type {string}             *              * @description             * The method to call when the condition is satisfied.             */            method: string;            /**             * @name key             * @memberof plat.controls.IKeyboardEventInput             * @kind property             * @access public             *              * @type {string}             *              * @description             * The key to satisfy the press condition. Can be specified either as a numeric key code              * or a string representation as seen by the KeyCodes mapping.             */            key?: string;            /**             * @name keys             * @memberof plat.controls.IKeyboardEventInput             * @kind property             * @access public             *              * @type {Array<string>}             *              * @description             * An optional array of keys if more than one key can satisfy the condition.             */            keys?: Array<string>;        }        /**         * @name KeyDown         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.KeyCodeEventControl}         *          * @description         * Used for filtering keys on keydown event.         */        export class KeyDown extends KeyCodeEventControl {            /**             * @name event             * @memberof plat.controls.KeyDown             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = 'keydown';        }        /**         * @name KeyPress         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.KeyCodeEventControl}         *          * @description         * Used for filtering only printing keys (a-z, A-Z, 0-9, and special characters) on keydown events.         */        export class KeyPress extends KeyCodeEventControl {            /**             * @name event             * @memberof plat.controls.KeyPress             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = 'keydown';            /**             * @name _onEvent             * @memberof plat.controls.KeyPress             * @kind function             * @access protected             *              * @description             * Filters only 'printing keys' (a-z, A-Z, 0-9, and special characters)             *              * @param {KeyboardEvent} ev The KeyboardEvent object.             *              * @returns {void}             */            _onEvent(ev: KeyboardEvent): void {                var keyCode = ev.keyCode;                if ((keyCode >= 48 && keyCode <= 90) ||                    (keyCode >= 186) ||                    (keyCode >= 96 && keyCode <= 111)) {                    super._onEvent(ev);                }            }        }        /**         * @name KeyUp         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.KeyCodeEventControl}         *          * @description         * Used for filtering keys on keyup events.         */        export class KeyUp extends KeyCodeEventControl {            /**             * @name event             * @memberof plat.controls.KeyDown             * @kind property             * @access public             *              * @type {string}             *              * @description             * The event name.             */            event: string = 'keyup';        }        register.control(__KeyDown, KeyDown);        register.control(__KeyPress, KeyPress);        register.control(__KeyUp, KeyUp);        /**         * @name SetAttributeControl         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.AttributeControl}         * @implements {plat.controls.ISetAttributeControl}         *          * @description         * An {@link plat.controls.AttributeControl|AttributeControl} that deals with binding to a specified property on its element.         */        export class SetAttributeControl extends AttributeControl implements ISetAttributeControl {            /**             * @name property             * @memberof plat.controls.SetAttributeControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The property to set on the associated template control.             */            property: string = '';            /**             * @name attribute             * @memberof plat.controls.SetAttributeControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The camel-cased name of the control as it appears as an attribute.             */            attribute: string;            /**             * @name __removeListener             * @memberof plat.controls.SetAttributeControl             * @kind property             * @access private             *              * @type {IRemoveListener}             *              * @description             * The function to stop listening for attribute changes.             */            private __removeListener: IRemoveListener;            /**             * @name loaded             * @memberof plat.controls.SetAttributeControl             * @kind function             * @access public             *              * @description             * Sets the corresponding attribute {property} value and              * observes the attribute for changes.             *              * @returns {void}             */            loaded(): void {                if (isNull(this.element)) {                    return;                }                this.attribute = camelCase(this.type);                this.setter();                this.__removeListener = this.attributes.observe(this.attribute, this.setter);            }            /**             * @name contextChanged             * @memberof plat.controls.SetAttributeControl             * @kind function             * @access public             *              * @description             * Resets the corresponding attribute property value upon              * a change of context.             *              * @returns {void}             */            contextChanged(): void {                if (isNull(this.element)) {                    return;                }                this.setter();            }            /**             * @name dispose             * @memberof plat.controls.SetAttributeControl             * @kind function             * @access public             *              * @description             * Stops listening to attribute changes.             *              * @returns {void}             */            dispose(): void {                if (isFunction(this.__removeListener)) {                    this.__removeListener();                    this.__removeListener = null;                }            }            /**             * @name setter             * @memberof plat.controls.SetAttributeControl             * @kind function             * @access public             * @virtual             *              * @description             * The function for setting the corresponding              * attribute property value.             *              * @returns {void}             */            setter(): void {                var expression = (<any>this.attributes)[this.attribute];                postpone(() => {                    if (!isNode(this.element)) {                        return;                    }                    switch (expression) {                        case 'false':                        case '0':                        case 'null':                        case '':                            this.element.setAttribute(this.property, '');                            (<any>this.element)[this.property] = false;                            this.element.removeAttribute(this.property);                            break;                        default:                            this.element.setAttribute(this.property, this.property);                            (<any>this.element)[this.property] = true;                    }                });            }        }        /**         * @name ISetAttributeControl         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.IAttributeControl}         *          * @description         * An {@link plat.controls.IAttributeControl|IAttributeControl} that deals with binding to a specified property on its element.         */        export interface ISetAttributeControl extends IAttributeControl {            /**             * @name property             * @memberof plat.controls.ISetAttributeControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The property to set on the associated template control.             */            property: string;            /**             * @name attribute             * @memberof plat.controls.ISetAttributeControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The camel-cased name of the control as it appears as an attribute.             */            attribute: string;            /**             * @name setter             * @memberof plat.controls.ISetAttributeControl             * @kind function             * @access public             *              * @description             * The function for setting the corresponding              * attribute property value.             *              * @returns {void}             */            setter(): void;        }        /**         * @name Checked         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SetAttributeControl}         *          * @description         * A {@link plat.controls.SetAttributeControl|SetAttributeControl} for the 'checked' attribute.         */        export class Checked extends SetAttributeControl {            /**             * @name property             * @memberof plat.controls.Checked             * @kind property             * @access public             *              * @type {string}             *              * @description             * The property to set on the associated template control.             */            property: string = 'checked';        }        /**         * @name Disabled         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SetAttributeControl}         *          * @description         * A {@link plat.controls.SetAttributeControl|SetAttributeControl} for the 'disabled' attribute.         */        export class Disabled extends SetAttributeControl {            /**             * @name property             * @memberof plat.controls.Disabled             * @kind property             * @access public             *              * @type {string}             *              * @description             * The property to set on the associated template control.             */            property: string = 'disabled';        }        /**         * @name Selected         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SetAttributeControl}         *          * @description         * A {@link plat.controls.SetAttributeControl|SetAttributeControl} for the 'selected' attribute.         */        export class Selected extends SetAttributeControl {            /**             * @name property             * @memberof plat.controls.Selected             * @kind property             * @access public             *              * @type {string}             *              * @description             * The property to set on the associated template control.             */            property: string = 'selected';        }        /**         * @name ReadOnly         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SetAttributeControl}         *          * @description         * A {@link plat.controls.SetAttributeControl|SetAttributeControl} for the 'readonly' attribute.         */        export class ReadOnly extends SetAttributeControl {            /**             * @name property             * @memberof plat.controls.ReadOnly             * @kind property             * @access public             *              * @type {string}             *              * @description             * The property to set on the associated template control.             */            property: string = 'readonly';        }        /**         * @name Visible         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SetAttributeControl}         *          * @description         * A {@link plat.controls.SetAttributeControl|SetAttributeControl} for the 'plat-hide' attribute.         */        export class Visible extends SetAttributeControl {            /**             * @name property             * @memberof plat.controls.Visible             * @kind property             * @access public             *              * @type {string}             *              * @description             * The property to set on the associated template control.             */            property: string = __Hide;            /**             * @name initialize             * @memberof plat.controls.Visible             * @kind function             * @access public             *              * @description             * Hides the element.             *              * @returns {void}             */            initialize(): void {                this.__hide();            }            /**             * @name setter             * @memberof plat.controls.Visible             * @kind function             * @access public             *              * @description             * Hides or shows the element depending upon the attribute value             *              * @returns {void}             */            setter(): void {                var expression = (<any>this.attributes)[this.attribute];                postpone(() => {                    if (!isNode(this.element)) {                        return;                    }                    switch (expression) {                        case 'false':                        case '0':                        case 'null':                        case '':                            this.__hide();                            break;                        default:                            this.__show();                    }                });            }            /**             * @name __hide             * @memberof plat.controls.Visible             * @kind function             * @access private             *              * @description             * Hides the element.             *              * @returns {void}             */            private __hide(): void {                if (!this.element.hasAttribute(this.property)) {                    this.element.setAttribute(this.property, '');                }            }            /**             * @name __show             * @memberof plat.controls.Visible             * @kind function             * @access private             *              * @description             * Shows the element.             *              * @returns {void}             */            private __show(): void {                if (this.element.hasAttribute(this.property)) {                    this.element.removeAttribute(this.property);                }            }        }        /**         * @name Style         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SetAttributeControl}         *          * @description         * A {@link plat.controls.SetAttributeControl|SetAttributeControl} for the 'style' attribute.         */        export class Style extends SetAttributeControl {            /**             * @name setter             * @memberof plat.controls.Style             * @kind function             * @access public             *              * @description             * Sets the evaluated styles on the element.             *              * @returns {void}             */            setter(): void {                var expression: string = (<any>this.attributes)[this.attribute];                if (isEmpty(expression)) {                    return;                }                var attributes = expression.split(';'),                    elementStyle = this.element.style,                    length = attributes.length,                    splitStyles: Array<string>,                    styleType: string,                    styleValue: string;                for (var i = 0; i < length; ++i) {                    splitStyles = attributes[i].split(':');                    if (splitStyles.length === 2) {                        styleType = camelCase(splitStyles[0].trim());                        styleValue = splitStyles[1].trim();                        if (!isUndefined((<any>elementStyle)[styleType])) {                            (<any>elementStyle)[styleType] = styleValue;                        }                    }                }            }        }        register.control(__Checked, Checked);        register.control(__Disabled, Disabled);        register.control(__Selected, Selected);        register.control(__ReadOnly, ReadOnly);        register.control(__Visible, Visible);        register.control(__Style, Style);        /**         * @name ElementPropertyControl         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.SetAttributeControl}         *          * @description         * Base class used for setting the property of an element (e.g. href for anchor elements).         */        export class ElementPropertyControl extends SetAttributeControl {            /**             * @name setter             * @memberof plat.controls.ElementPropertyControl             * @kind function             * @access public             *              * @description             * The function for setting the corresponding              * attribute property value to the evaluated expression.             *              * @returns {void}             */            setter(): void {                var element = this.element,                    elementProperty = this.property,                    expression = (<any>this.attributes)[this.attribute];                if (isEmpty(expression) || isNull(element)) {                    return;                }                if (!isUndefined((<any>element)[elementProperty])) {                    (<any>element)[elementProperty] = expression;                }            }        }        /**         * @name Href         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.ElementPropertyControl}         *          * @description         * A type of {@link plat.controls.ElementPropertyControl|ElementPropertyControl} used to set 'href' on an anchor tag.         */        export class Href extends ElementPropertyControl {            /**             * @name property             * @memberof plat.controls.Href             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * Used to set the element's href property.             */            property: string = 'href';        }        /**         * @name Src         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.ElementPropertyControl}         *          * @description         * A type of {@link plat.controls.ElementPropertyControl|ElementPropertyControl} used to set 'src' on an anchor tag.         */        export class Src extends ElementPropertyControl {            /**             * @name property             * @memberof plat.controls.Src             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * Used to set the element's src property.             */            property: string = 'src';        }        register.control(__Href, Href);        register.control(__Src, Src);        /**         * @name Bind         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.AttributeControl}         *          * @description         * Facilitates two-way databinding for HTMLInputElements, HTMLSelectElements, and HTMLTextAreaElements.         */        export class Bind extends AttributeControl {            /**             * @name $Parser             * @memberof plat.controls.Bind             * @kind property             * @access public             * @static             *              * @type {plat.expressions.IParser}             *              * @description             * Reference to the {@link plat.expressions.IParser|IParser} injectable.             */            $Parser: expressions.IParser = acquire(__Parser);            /**             * @name $ContextManagerStatic             * @memberof plat.controls.Bind             * @kind property             * @access public             * @static             *              * @type {plat.observable.IContextManagerStatic}             *              * @description             * Reference to the {@link plat.observable.IContextManagerStatic|IContextManagerStatic} injectable.             */            $ContextManagerStatic: observable.IContextManagerStatic = acquire(__ContextManagerStatic);            /**             * @name $document             * @memberof plat.controls.Bind             * @kind property             * @access public             * @static             *              * @type {Document}             *              * @description             * Reference to the Document injectable.             */            $document: Document = acquire(__Document);            /**             * @name priority             * @memberof plat.controls.Bind             * @kind property             * @access public             *              * @type {number}             *              * @description             * The priority of Bind is set high to take precede              * other controls that may be listening to the same              * event.             */            priority: number = 100;            /**             * @name _addEventType             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * The function used to add the proper event based on the input type.             *              * @returns {void}             */            _addEventType: () => void;            /**             * @name _getter             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * The function used to get the bound value.             *              * @returns {any} The bound value.             */            _getter: () => any;            /**             * @name _setter             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * The function used to set the bound value.             *              * @returns {void}             */            _setter: (newValue: any, oldValue?: any, firstTime?: boolean) => void;            /**             * @name _expression             * @memberof plat.controls.Bind             * @kind property             * @access protected             *              * @type {plat.expressions.IParsedExpression}             *              * @description             * The expression to evaluate as the bound value.             */            _expression: expressions.IParsedExpression;            /**             * @name _contextExpression             * @memberof plat.controls.Bind             * @kind property             * @access protected             *              * @type {plat.expressions.IParsedExpression}             *              * @description             * The IParsedExpression used to evaluate the context              * of the bound property.             */            _contextExpression: expressions.IParsedExpression;            /**             * @name _property             * @memberof plat.controls.Bind             * @kind property             * @access protected             *              * @type {string}             *              * @description             * The bound property name.             */            _property: string;            /**             * @name __fileSupported             * @memberof plat.controls.Bind             * @kind property             * @access private             *              * @type {boolean}             *              * @description             * Whether or not the File API is supported.             */            private __fileSupported = (<ICompat>acquire(__Compat)).fileSupported;            /**             * @name __fileNameRegex             * @memberof plat.controls.Bind             * @kind property             * @access private             *              * @type {RegExp}             *              * @description             * Used to grab a filename from input[type="file"].             */            private __fileNameRegex = (<expressions.IRegex>acquire(__Regex)).fileNameRegex;            /**             * @name __isSelf             * @memberof plat.controls.Bind             * @kind property             * @access private             *              * @type {boolean}             *              * @description             * Used to denote that a property change happened from within this control.             */            private __isSelf = false;            /**             * @name initialize             * @memberof plat.controls.Bind             * @kind function             * @access public             *              * @description             * Determines the type of Element being bound to              * and sets the necessary handlers.             *              * @returns {void}             */            initialize(): void {                this._determineType();            }            /**             * @name loaded             * @memberof plat.controls.Bind             * @kind function             * @access public             *              * @description             * Parses and watches the expression being bound to.             *              * @returns {void}             */            loaded(): void {                if (isNull(this.parent) || isNull(this.element)) {                    return;                }                var attr = camelCase(this.type),                    expression = this._expression = this.$Parser.parse((<any>this.attributes)[attr]);                var identifiers = expression.identifiers;                if (identifiers.length !== 1) {                    var $exception: IExceptionStatic = acquire(__ExceptionStatic);                    $exception.warn('Only 1 identifier allowed in a plat-bind expression', $exception.BIND);                    this._contextExpression = null;                    return;                }                var split = identifiers[0].split('.');                this._property = split.pop();                if (split.length > 0) {                    this._contextExpression = this.$Parser.parse(split.join('.'));                } else if (expression.aliases.length > 0) {                    var alias = expression.aliases[0],                        resourceObj = this.parent.findResource(alias);                    if (isNull(resourceObj) || resourceObj.resource.type !== 'observable') {                        return;                    }                    this._property = 'value';                    this._contextExpression = {                        evaluate: () => {                            return resourceObj.resource;                        },                        aliases: [],                        identifiers: [],                        expression: ''                    };                } else {                    this._contextExpression = {                        evaluate: () => {                            return this.parent.context;                        },                        aliases: [],                        identifiers: [],                        expression: ''                    };                }                this._watchExpression();                if (isNull(this._addEventType)) {                    return;                }                this._addEventType();            }            /**             * @name contextChanged             * @memberof plat.controls.Bind             * @kind function             * @access public             *              * @description             * Re-observes the expression with the new context.             *              * @returns {void}             */            contextChanged(): void {                this._watchExpression();            }            /**             * @name dispose             * @memberof plat.controls.Bind             * @kind function             * @access public             *              * @description             * Removes all of the element's event listeners.             *              * @returns {void}             */            dispose(): void {                this._addEventType = null;            }            /**             * @name _addTextEventListener             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Adds a text event as the event listener.              * Used for textarea and input[type=text].             *              * @returns {void}             */            _addTextEventListener(): void {                var element = this.element,                    composing = false,                    timeout: IRemoveListener,                    eventListener = () => {                        if (composing) {                            return;                        }                        this._propertyChanged();                    },                    postponedEventListener = () => {                        if (isFunction(timeout)) {                            return;                        }                        timeout = postpone(() => {                            eventListener();                            timeout = null;                        });                    };                this.addEventListener(element, 'compositionstart', () => composing = true, false);                this.addEventListener(element, 'compositionend', () => composing = false, false);                this.addEventListener(element, 'keydown', (ev: Event) => {                    var key = (<KeyboardEvent>ev).keyCode,                        codes = KeyCodes;                    if (key === codes.lwk ||                        key === codes.rwk ||                        (key > 15 && key < 28) ||                        (key > 32 && key < 41)) {                        return;                    }                    postponedEventListener();                }, false);                this.addEventListener(element, 'cut', postponedEventListener, false);                this.addEventListener(element, 'paste', postponedEventListener, false);                this.addEventListener(element, 'change', eventListener, false);            }            /**             * @name _addChangeEventListener             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Adds a change event as the event listener.              * Used for select, input[type=radio], and input[type=range].             *              * @returns {void}             */            _addChangeEventListener(): void {                this.addEventListener(this.element, 'change', this._propertyChanged, false);            }            /**             * @name _addButtonEventListener             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Adds a $tap event as the event listener.              * Used for input[type=button] and button.             *              * @returns {void}             */            _addButtonEventListener(): void {                this.addEventListener(this.element, __$tap, this._propertyChanged, false);            }            /**             * @name _getChecked             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Getter for input[type=checkbox] and input[type=radio]             *              * @returns {boolean} Whether or not the input element is checked             */            _getChecked(): boolean {                return (<HTMLInputElement>this.element).checked;            }            /**             * @name _getValue             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Getter for input[type=text], input[type=range],              * textarea, and select.             *              * @returns {string} The input value             */            _getValue(): string {                return (<HTMLInputElement>this.element).value;            }            /**             * @name _getTextContent             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Getter for button.             *              * @returns {string} The button textContent             */            _getTextContent(): string {                return (<HTMLInputElement>this.element).textContent;            }            /**             * @name _getFile             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Getter for input[type="file"]. Creates a partial IFile              * element if file is not supported.             *              * @returns {plat.controls.IFile} The input file             */            _getFile(): IFile {                var element = <HTMLInputElement>this.element,                    value = element.value;                if (this.__fileSupported && element.files.length > 0) {                    return <IFile>element.files[0];                }                return {                    name: value.replace(this.__fileNameRegex, ''),                    path: value,                    lastModifiedDate: undefined,                    type: undefined,                    size: undefined,                    msDetachStream: noop,                    msClose: noop,                    slice: () => <Blob>{ }                };            }            /**             * @name _getFiles             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Getter for input[type="file"]-multiple             *              * @returns {Array<plat.controls.IFile>} The input files             */            _getFiles(): Array<IFile> {                var element = <HTMLInputElement>this.element;                if (this.__fileSupported) {                    return Array.prototype.slice.call(element.files);                }                // this case should never be hit since ie9 does not support multi-file uploads,                 // but kept in here for now for consistency's sake                var filelist = element.value.split(/,|;/g),                    length = filelist.length,                    files: Array<IFile> = [],                    fileValue: string;                for (var i = 0; i < length; ++i) {                    fileValue = filelist[i];                    files.push({                        name: fileValue.replace(this.__fileNameRegex, ''),                        path: fileValue,                        lastModifiedDate: undefined,                        type: undefined,                        size: undefined,                        msDetachStream: noop,                        msClose: noop,                        slice: () => <Blob>{}                    });                }                return files;            }            /**             * @name _getSelectedValues             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Getter for select-multiple             *              * @returns {Array<string>} The selected values             */            _getSelectedValues(): Array<string> {                var options = (<HTMLSelectElement>this.element).options,                    length = options.length,                    option: HTMLOptionElement,                    selectedValues: Array<string> = [];                for (var i = 0; i < length; ++i) {                    option = options[i];                    if (option.selected) {                        selectedValues.push(option.value);                    }                }                return selectedValues;            }            /**             * @name _setText             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Setter for textarea, input[type=text],              * and input[type=button], and select             *              * @param {any} newValue The new value to set             * @param {any} oldValue? The previously bound value             * @param {boolean} firstTime? The context is being evaluated for the first time and              * should thus change the property if null             *              * @returns {void}             */            _setText(newValue: any, oldValue?: any, firstTime?: boolean): void {                if (this.__isSelf) {                    return;                }                if (isNull(newValue)) {                    newValue = '';                    if (firstTime === true) {                        if (isNull((<HTMLInputElement>this.element).value)) {                            this.__setValue(newValue);                        }                        this._propertyChanged();                        return;                    }                }                this.__setValue(newValue);            }            /**             * @name _setRange             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Setter for input[type=range]             *              * @param {any} newValue The new value to set             * @param {any} oldValue? The previously bound value             * @param {boolean} firstTime? The context is being evaluated for the first time and              * should thus change the property if null             *              * @returns {void}             */            _setRange(newValue: any, oldValue?: any, firstTime?: boolean): void {                if (this.__isSelf) {                    return;                }                if (isEmpty(newValue)) {                    newValue = 0;                    if (firstTime === true) {                        if (isEmpty((<HTMLInputElement>this.element).value)) {                            this.__setValue(newValue);                        }                        this._propertyChanged();                        return;                    }                }                this.__setValue(newValue);            }            /**             * @name _setChecked             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Setter for input[type=checkbox]             *              * @param {any} newValue The new value to set             * @param {any} oldValue? The previously bound value             * @param {boolean} firstTime? The context is being evaluated for the first time and              * should thus change the property if null             *              * @returns {void}             */            _setChecked(newValue: any, oldValue?: any, firstTime?: boolean): void {                if (this.__isSelf) {                    return;                } else if (!isBoolean(newValue)) {                    if (firstTime === true) {                        this._propertyChanged();                        return;                    }                    newValue = !!newValue;                }                (<HTMLInputElement>this.element).checked = newValue;            }            /**             * @name _setRadio             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Setter for input[type=radio]             *              * @param {any} newValue The new value to set             *              * @returns {void}             */            _setRadio(newValue: any): void {                var element = (<HTMLInputElement>this.element);                if (this.__isSelf) {                    return;                } else if (isNull(newValue) && element.checked) {                    this._propertyChanged();                    return;                }                element.checked = (element.value === newValue);            }            /**             * @name _setSelectedIndex             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Setter for select             *              * @param {any} newValue The new value to set             * @param {any} oldValue? The previously bound value             * @param {boolean} firstTime? The context is being evaluated for the first time and              * should thus change the property if null             *              * @returns {void}             */            _setSelectedIndex(newValue: any, oldValue?: any, firstTime?: boolean): void {                if (this.__isSelf) {                    return;                } else if (firstTime === true && this.__checkAsynchronousSelect()) {                    if (isNull(newValue)) {                        this._propertyChanged();                    }                    return;                }                var element = <HTMLSelectElement>this.element,                    value = element.value;                if (isNull(newValue)) {                    if (firstTime === true || !this.$document.body.contains(element)) {                        this._propertyChanged();                        return;                    }                    element.selectedIndex = -1;                    return;                } else if (!isString(newValue)) {                    var Exception: IExceptionStatic = acquire(__ExceptionStatic),                        message: string;                    if (isNumber(newValue)) {                        newValue = newValue.toString();                        message = 'Trying to bind a value of type number to a select element. ' +                            'The value will implicitly be converted to type string.';                    } else {                        message = 'Trying to bind a value that is not a string to a select element. ' +                            'The element\'s selected index will be set to -1.';                    }                    Exception.warn(message, Exception.BIND);                } else if (value === newValue) {                    return;                } else if (!this.$document.body.contains(element)) {                    element.value = newValue;                    if (element.value !== newValue) {                        element.value = value;                        this._propertyChanged();                    }                    return;                }                element.value = newValue;                // check to make sure the user changed to a valid value                // second boolean argument is an ie fix for inconsistency                if (element.value !== newValue || element.selectedIndex === -1) {                    element.selectedIndex = -1;                }            }            /**             * @name _setSelectedIndices             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Setter for select-multiple             *              * @param {any} newValue The new value to set             * @param {any} oldValue? The previously bound value             * @param {boolean} firstTime? The context is being evaluated for the first time and              * should thus change the property if null             *              * @returns {void}             */            _setSelectedIndices(newValue: any, oldValue?: any, firstTime?: boolean): void {                if (this.__isSelf) {                    return;                } else if (firstTime === true && this.__checkAsynchronousSelect()) {                    return;                }                var options = (<HTMLSelectElement>this.element).options,                    length = isNull(options) ? 0 : options.length,                    option: HTMLOptionElement,                    nullValue = isNull(newValue);                if (nullValue || !isArray(newValue)) {                    if (firstTime === true) {                        this._propertyChanged();                    }                    // unselects the options unless a match is found                    while (length-- > 0) {                        option = options[length];                        if (!nullValue && option.value === '' + newValue) {                            option.selected = true;                            return;                        }                        option.selected = false;                    }                    return;                }                var value: any,                    numberValue: number;                while (length-- > 0) {                    option = options[length];                    value = option.value;                    numberValue = Number(value);                    if (newValue.indexOf(value) !== -1 || (isNumber(numberValue) && newValue.indexOf(numberValue) !== -1)) {                        option.selected = true;                        continue;                    }                    option.selected = false;                }            }            /**             * @name _determineType             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Determines the type of Element being bound to              * and sets the necessary handlers.             *              * @returns {void}             */            _determineType(): void {                if (!isNull(this.templateControl) && this._observedBindableProperty()) {                    return;                }                var element = this.element;                if (isNull(element)) {                    return;                }                switch (element.nodeName.toLowerCase()) {                    case 'textarea':                        this._addEventType = this._addTextEventListener;                        this._getter = this._getValue;                        this._setter = this._setText;                        break;                    case 'input':                        switch ((<HTMLInputElement>element).type) {                            case 'button':                            case 'submit':                            case 'reset':                                this._addEventType = this._addButtonEventListener;                                this._getter = this._getValue;                                break;                            case 'checkbox':                                this._addEventType = this._addChangeEventListener;                                this._getter = this._getChecked;                                this._setter = this._setChecked;                                break;                            case 'radio':                                this.__initializeRadio();                                break;                            case 'range':                                this._addEventType = this._addChangeEventListener;                                this._getter = this._getValue;                                this._setter = this._setRange;                                break;                            case 'file':                                var multi = (<HTMLInputElement>element).multiple;                                this._addEventType = this._addChangeEventListener;                                this._getter = multi ? this._getFiles : this._getFile;                                break;                            default:                                this._addEventType = this._addTextEventListener;                                this._getter = this._getValue;                                this._setter = this._setText;                                break;                        }                        break;                    case 'select':                        this.__initializeSelect();                        break;                    case 'button':                        this._addEventType = this._addButtonEventListener;                        this._getter = this._getTextContent;                        break;                }            }            /**             * @name _watchExpression             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Observes the expression to bind to.             *              * @returns {void}             */            _watchExpression(): void {                var contextExpression = this._contextExpression,                    context = this.evaluateExpression(contextExpression);                if (!isObject(context)) {                    if (isNull(context) && contextExpression.identifiers.length > 0) {                        context = this.$ContextManagerStatic.createContext(this.parent,                            contextExpression.identifiers[0]);                    } else {                        var Exception: IExceptionStatic = acquire(__ExceptionStatic);                        Exception.warn('plat-bind is trying to index into a primitive type. ' +                            this._contextExpression.expression + ' is already defined and not ' +                            'an object when trying to evaluate plat-bind="' +                            this._expression.expression + '"', Exception.BIND);                    }                }                var property: string;                if (!isFunction(this._setter)) {                    return;                } else if (this._setter === this._setSelectedIndices) {                    property = this._property;                    if (isNull(context[property])) {                        context[property] = [];                    }                    this.observeArray(context, property, (arrayInfo: observable.IArrayMethodInfo<string>) => {                        this._setter(arrayInfo.newArray, arrayInfo.oldArray, true);                    });                }                var expression = this._expression;                this.observeExpression(expression, this._setter);                this._setter(this.evaluateExpression(expression), undefined, true);            }            /**             * @name _propertyChanged             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Sets the context property being bound to when the              * element's property is changed.             *              * @returns {void}             */            _propertyChanged(): void {                if (isNull(this._contextExpression)) {                    return;                }                var context = this.evaluateExpression(this._contextExpression),                    property = this._property;                var newValue = this._getter();                if (isNull(context) || context[property] === newValue) {                    return;                }                // set flag to let setter functions know we changed the property                this.__isSelf = true;                context[property] = newValue;                this.__isSelf = false;            }            /**             * @name _observedBindableProperty             * @memberof plat.controls.Bind             * @kind function             * @access protected             *              * @description             * Checks if the associated {@link plat.ui.TemplateControl|TemplateControl} is a              * {@link plat.ui.BindablePropertyControl|BindablePropertyControl} and              * initializes all listeners accordingly.             *              * @returns {boolean} Whether or not the associated {@link plat.ui.TemplateControl|TemplateControl}              * is a {@link plat.ui.BindablePropertyControl|BindablePropertyControl}             */            _observedBindableProperty(): boolean {                var templateControl = <ui.IBindablePropertyControl>this.templateControl;                if (isFunction(templateControl.observeProperty) &&                    isFunction(templateControl.setProperty)) {                    templateControl.observeProperty((newValue: any) => {                        this._getter = () => newValue;                        this._propertyChanged();                    });                    this._setter = this.__setBindableProperty;                    return true;                }                return false;            }            /**             * @name __setBindableProperty             * @memberof plat.controls.Bind             * @kind function             * @access private             *              * @description             * Sets the value on a {@link plat.ui.BindablePropertyControl|BindablePropertyControl}.             *              * @param {any} newValue The new value to set             * @param {any} oldValue? The previously bound value             * @param {boolean} firstTime? The context is being evaluated for the first time and              * should thus change the property if null             *              * @returns {void}             */            private __setBindableProperty(newValue: any, oldValue?: any, firstTime?: boolean): void {                if (this.__isSelf) {                    return;                }                (<ui.IBindablePropertyControl>this.templateControl).setProperty(newValue, oldValue, firstTime);            }            /**             * @name __setValue             * @memberof plat.controls.Bind             * @kind function             * @access private             *              * @description             * Sets the value on an element.             *              * @param {any} newValue The new value to set             *              * @returns {void}             */            private __setValue(newValue: any): void {                var element = <HTMLInputElement>this.element;                if (element.value === newValue) {                    return;                }                element.value = newValue;            }            /**             * @name __setValue             * @memberof plat.controls.Bind             * @kind function             * @access private             *              * @description             * Normalizes input[type="radio"] for cross-browser compatibility.             *              * @returns {void}             */            private __initializeRadio(): void {                var element = this.element;                this._addEventType = this._addChangeEventListener;                this._getter = this._getValue;                this._setter = this._setRadio;                if (!element.hasAttribute('name')) {                    var attr = camelCase(this.type),                        expression = (<any>this.attributes)[attr];                    element.setAttribute('name', expression);                }                if (element.hasAttribute('value')) {                    return;                }                element.setAttribute('value', '');            }            /**             * @name __initializeSelect             * @memberof plat.controls.Bind             * @kind function             * @access private             *              * @description             * Normalizes HTMLSelectElements for cross-browser compatibility.             *              * @returns {void}             */            private __initializeSelect(): void {                var element = <HTMLSelectElement>this.element,                    multiple = element.multiple,                    options = element.options,                    length = options.length,                    option: HTMLSelectElement;                this._addEventType = this._addChangeEventListener;                if (multiple) {                    this._getter = this._getSelectedValues;                    this._setter = this._setSelectedIndices;                } else {                    this._getter = this._getValue;                    this._setter = this._setSelectedIndex;                }                for (var i = 0; i < length; ++i) {                    option = options[i];                    if (!option.hasAttribute('value')) {                        option.setAttribute('value', option.textContent);                    }                }            }            /**             * @name __checkAsynchronousSelect             * @memberof plat.controls.Bind             * @kind function             * @access private             *              * @description             * Checks to see if a {@link plat.ui.control.Select|Select} is loading items.             *              * @returns {boolean} Whether or not the select is loading items.             */            private __checkAsynchronousSelect(): boolean {                var select = <ui.controls.Select>this.templateControl;                if (!isNull(select) && (select.type === __Select || select.type === __ForEach) && isPromise(select.itemsLoaded)) {                    var split = select.absoluteContextPath.split('.'),                        key = split.pop();                    this.observeArray(this.$ContextManagerStatic.getContext(this.parent, split), key,                        (ev: observable.IArrayMethodInfo<any>) => {                            select.itemsLoaded.then(() => {                                this._setter(this.evaluateExpression(this._expression));                            });                        });                    select.itemsLoaded.then(() => {                        this._setter(this.evaluateExpression(this._expression));                    });                    return true;                }                return false;            }        }        register.control(__Bind, Bind);        /**         * @name IFile         * @memberof plat.controls         * @kind interface         *          * @extends {File}         *          * @description         * A file interface for browsers that do not support the          * File API.         */        export interface IFile extends File {            /**             * @name string             * @memberof plat.controls.IFile             * @kind property             * @access public             * @readonly             *              * @type {string}             *              * @description             * An absolute path to the file. The property is not added to              * File types.             */            path?: string;        }        /**         * @name ObservableAttributeControl         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.AttributeControl}         * @implements {plat.controls.IObservableAttributeControl}         *          * @description         * An {@link plat.controls.AttributeControl|AttributeControl} that deals with observing changes for a specified property.         */        export class ObservableAttributeControl extends AttributeControl implements IObservableAttributeControl {            /**             * @name $ContextManagerStatic             * @memberof plat.controls.ObservableAttributeControl             * @kind property             * @access public             *              * @type {plat.observable.IContextManagerStatic}             *              * @description             * Reference to the {@link plat.observable.IContextManagerStatic|IContextManagerStatic} injectable.             */            $ContextManagerStatic: observable.IContextManagerStatic = acquire(__ContextManagerStatic);            /**             * @name property             * @memberof plat.controls.ObservableAttributeControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The property to set on the associated template control.             */            property: string = '';            /**             * @name attribute             * @memberof plat.controls.ObservableAttributeControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The camel-cased name of the control as it appears as an attribute.             */            attribute: string;            /**             * @name priority             * @memberof plat.controls.ObservableAttributeControl             * @kind property             * @access public             *              * @type {number}             *              * @description             * This control needs to load before its templateControl             */            priority = 200;            /**             * @name _listeners             * @memberof plat.controls.ObservableAttributeControl             * @kind property             * @access protected             *              * @type {Array<plat.IPropertyChangedListener>}             *              * @description             * The set of functions added by the Template Control that listens              * for property changes.             */            _listeners: Array<(newValue: any, oldValue?: any) => void> = [];            /**             * @name _removeListener             * @memberof plat.controls.ObservableAttributeControl             * @kind property             * @access protected             *              * @type {IRemoveListener}             *              * @description             * The function to stop listening for property changes.             */            _removeListener: IRemoveListener;            /**             * @name initialize             * @memberof plat.controls.ObservableAttributeControl             * @kind function             * @access public             *              * @description             * Sets the initial value of the property on              * the Template Control.             *              * @returns {void}             */            initialize(): void {                this.attribute = camelCase(this.type);                this._setProperty(this._getValue());            }            /**             * @name loaded             * @memberof plat.controls.ObservableAttributeControl             * @kind function             * @access public             *              * @description             * Observes the property and resets the value.             *              * @returns {void}             */            loaded(): void {                this._observeProperty();                this._setProperty(this._getValue());            }            /**             * @name dispose             * @memberof plat.controls.ObservableAttributeControl             * @kind function             * @access public             *              * @description             * Stops listening for changes to the evaluated              * expression and removes references to the listeners              * defined by the Template Control.             *              * @returns {void}             */            dispose(): void {                if (isFunction(this._removeListener)) {                    this._removeListener();                }                this._listeners = [];            }            /**             * @name _setProperty             * @memberof plat.controls.ObservableAttributeControl             * @kind function             * @access protected             *              * @description             * Sets the property on the Template Control.             *              * @param {any} value The new value of the evaluated expression.             * @param {any} oldValue? The old value of the evaluated expression.             *              * @returns {void}             */            _setProperty(value: any, oldValue?: any): void {                var templateControl = this.templateControl;                if (isNull(templateControl)) {                    return;                }                this.$ContextManagerStatic.defineGetter(templateControl, this.property, <observable.IObservableProperty<any>>{                    value: value,                    observe: this._addListener.bind(this)                }, true, true);                this._callListeners(value, oldValue);            }            /**             * @name _callListeners             * @memberof plat.controls.ObservableAttributeControl             * @kind function             * @access protected             *              * @description             * Calls the listeners defined by the Template Control.             *              * @param {any} value The new value of the evaluated expression.             * @param {any} oldValue The old value of the evaluated expression.             *              * @returns {void}             */            _callListeners(newValue: any, oldValue: any): void {                var listeners = this._listeners,                    length = listeners.length,                    templateControl = this.templateControl;                for (var i = 0; i < length; ++i) {                    listeners[i].call(templateControl, newValue, oldValue);                }            }            /**             * @name _addListener             * @memberof plat.controls.ObservableAttributeControl             * @kind function             * @access protected             *              * @description             * Adds a listener as defined by the Template Control.             *              * @param {plat.IPropertyChangedListener} listener The listener added by the Template Control.             */            _addListener(listener: (newValue: any, oldValue: any) => void): IRemoveListener {                var listeners = this._listeners,                    index = listeners.length;                listeners.push(listener);                return () => {                    listeners.splice(index, 1);                };            }            /**             * @name _getValue             * @memberof plat.controls.ObservableAttributeControl             * @kind function             * @access protected             *              * @description             * Evaluates the attribute's value.             *              * @returns {any}             */            _getValue(): any {                var expression = (<any>this.attributes)[this.attribute],                    templateControl = this.templateControl;                if (isNull(templateControl)) {                    return;                }                return this.evaluateExpression(expression);            }            /**             * @name _observeProperty             * @memberof plat.controls.ObservableAttributeControl             * @kind function             * @access protected             *              * @description             * Observes the attribute's value.             *              * @returns {void}             */            _observeProperty(): void {                var expression = (<any>this.attributes)[this.attribute],                    templateControl = this.templateControl;                if (isNull(templateControl)) {                    return;                }                this._removeListener = this.observeExpression(expression, this._setProperty);            }        }        /**         * @name IObservableAttributeControl         * @memberof plat.controls         * @kind interface         *          * @extends {plat.controls.IAttributeControl}         *          * @description         * An {@link plat.controls.IAttributeControl|IAttributeControl} that deals with observing changes for a specified property.         */        export interface IObservableAttributeControl extends IAttributeControl {            /**             * @name property             * @memberof plat.controls.IObservableAttributeControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The property to set on the associated template control.             */            property: string;            /**             * @name attribute             * @memberof plat.controls.IObservableAttributeControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The camel-cased name of the control as it appears as an attribute.             */            attribute: string;        }        /**         * @name Options         * @memberof plat.controls         * @kind class         *          * @extends {plat.controls.ObservableAttributeControl}         *          * @description         * An {@link plat.controls.ObservableAttributeControl|ObservableAttributeControl} that sets 'options' as the          * associated property.         */        export class Options extends ObservableAttributeControl {            /**             * @name property             * @memberof plat.controls.Options             * @kind property             * @access public             *              * @type {string}             *              * @description             * The property to set on the associated template control.             */            property: string = 'options';        }        register.control(__Options, Options);    }        /**     * @name ui     * @memberof plat     * @kind namespace     *      * @description     * Holds classes and interfaces related to event management.     */    export module ui {        /**         * @name TemplateControl         * @memberof plat.ui         * @kind class         *          * @extends {plat.Control}         * @implements {plat.ui.ITemplateControl}         *          * @description         * The base control for any control that affects the UI. They provide properties for the control to use         * to manage its body HTML.         */        export class TemplateControl extends Control implements ITemplateControl {            /**             * @name $ResourcesFactory             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             * @static             *              * @type {plat.ui.IResourcesFactory}             *              * @description             * Reference to the {@link plat.ui.IResourcesFactory|IResourcesFactory} injectable.             */            static $ResourcesFactory: IResourcesFactory;            /**             * @name $BindableTemplatesFactory             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             * @static             *              * @type {plat.ui.IBindableTemplatesFactory}             *              * @description             * Reference to the {@link plat.ui.IBindableTemplatesFactory|IBindableTemplatesFactory} injectable.             */            static $BindableTemplatesFactory: IBindableTemplatesFactory;            /**             * @name $ManagerCache             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             * @static             *              * @type {plat.storage.ICache<processing.IElementManager>}             *              * @description             * Reference to a cache injectable that stores {@link plat.processing.IElementManager|IElementManagers}.             */            static $ManagerCache: storage.ICache<processing.IElementManager>;            /**             * @name $TemplateCache             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             * @static             *              * @type {plat.storage.ITemplateCache}             *              * @description             * Reference to a cache injectable that stores and retrieves HTML templates.             */            static $TemplateCache: storage.ITemplateCache;            /**             * @name $Parser             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             * @static             *              * @type {plat.expressions.IParser}             *              * @description             * Reference to the {@link plat.expressions.IParser|IParser} injectable.             */            static $Parser: expressions.IParser;            /**             * @name $Http             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             * @static             *              * @type {plat.async.IHttp}             *              * @description             * Reference to the {@link plat.async.IHttp|IHttp} injectable.             */            static $Http: async.IHttp;            /**             * @name $Promise             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             * @static             *              * @type {plat.async.IPromise}             *              * @description             * Reference to the {@link plat.async.IPromise|IPromise} injectable.             */            static $Promise: async.IPromise;            /**             * @name evaluateExpression             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @static             * @variation 0             *              * @description             * Evaluates an expression string with a given control and optional control's context and aliases.             *              * @param {string} expression The expression string (e.g. 'foo + foo').             * @param {plat.ui.ITemplateControl} control? The control used for evaluation context.             * @param {any} aliases? An optional alias object containing resource alias values             *              * @returns {any} The evaluated object.             */            static evaluateExpression(expression: string, control?: ITemplateControl, aliases?: any): any;            /**             * @name evaluateExpression             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @static             * @variation 1             *              * @description             * Evaluates an expression string with a given control and optional control's context and aliases.             *              * @param {plat.expressions.IParsedExpression} expression A parsed expression object created using the              * plat.expressions.IParser injectable.             * @param {plat.ui.ITemplateControl} control? The control used for evaluation context.             * @param {any} aliases? An optional alias object containing resource alias values             *              * @returns {any} The evaluated object.             */            static evaluateExpression(expression: expressions.IParsedExpression, control?: ITemplateControl, aliases?: any): any;            static evaluateExpression(expression: any, control?: ITemplateControl, aliases?: any): any {                if (isNull(expression)) {                    return;                } else if (!(isString(expression) || isFunction(expression.evaluate))) {                    return;                }                expression = isString(expression) ? TemplateControl.$Parser.parse(expression) : expression;                if (isNull(control)) {                    return expression.evaluate(null, aliases);                }                if (expression.aliases.length > 0) {                    aliases = TemplateControl.getResources(control, expression.aliases, aliases);                }                return expression.evaluate(control.context, aliases);            }            /**             * @name getResources             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @static             *              * @description             * Given a control and Array of aliases, finds the associated resources and builds a context object containing             * the values. Returns the object.             *              * @param {plat.ui.ITemplateControl} control The control used as the starting point for finding resources.             * @param {Array<string>} aliases An array of aliases to search for.             * @param {any} resources? An optional resources object to extend, if no resources object is passed in a new one will be created.             *              * @returns {IObject<any>} An object representing a set of resources.             */            static getResources(control: ITemplateControl, aliases: Array<string>, resources?: any): IObject<any> {                if (isNull(control)) {                    return {};                }                var length = aliases.length,                    alias: string,                    resourceObj: {                        control: ITemplateControl;                        resource: IResource;                    },                    cache = TemplateControl.__resourceCache[control.uid];                if (isNull(cache)) {                    cache = TemplateControl.__resourceCache[control.uid] = {};                }                resources = resources || {};                for (var i = 0; i < length; ++i) {                    alias = aliases[i];                    if (alias[0] === '@') {                        alias = alias.substr(1);                    }                    if (!isNull(resources[alias])) {                        continue;                    } else if (!isNull(cache[alias])) {                        var resourceControl = cache[alias].control,                            controlResources = resourceControl.resources;                        if (isNull(controlResources)) {                            resourceObj = TemplateControl.findResource(control, alias);                        } else {                            resourceObj = {                                control: resourceControl,                                resource: controlResources[alias]                            };                        }                    } else {                        resourceObj = TemplateControl.findResource(control, alias);                    }                    if (isNull(resourceObj)) {                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);                        $exception.warn('Attempting to use a resource that is not defined.', $exception.CONTEXT);                        continue;                    }                    cache[alias] = resourceObj;                    resources['@' + alias] = isNull(resourceObj.resource) ? resourceObj.resource : resourceObj.resource.value;                }                return resources;            }            /**             * @name findResource             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @static             *              * @description             * Starts at a control and searches up its parent chain for a particular resource alias.              * If the resource is found, it will be returned along with the control instance on which             * the resource was found.             *              * @param {plat.ui.ITemplateControl} control The control on which to start searching for the resource alias.             * @param {string} alias The alias to search for.             *              * @returns {{ resource: plat.ui.IResource; control: plat.ui.ITemplateControl; }} An object consisting of the              * found resource along with its corresponding control.             */            static findResource(control: ITemplateControl, alias: string): { resource: IResource; control: ITemplateControl; } {                var resource: IResource;                if (isNull(control) || isNull(control.resources) || !isString(alias) || isEmpty(alias)) {                    return null;                }                if (alias[0] === '@') {                    alias = alias.substr(1);                }                if (alias === 'rootContext') {                    control = Control.getRootControl(control);                    return {                        resource: (<any>control.resources)[alias],                        control: control                    };                } else if (alias === 'context' || alias === 'control') {                    return {                        resource: (<any>control.resources)[alias],                        control: control                    };                }                while (!isNull(control)) {                    resource = (<any>control.resources)[alias];                    if (!isNull(resource)) {                        return {                            resource: resource,                            control: control                        };                    }                    control = control.parent;                }            }            /**             * @name dispose             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @static             *              * @description             * Recursively disposes a control and its children.             *              * @param {plat.ui.ITemplateControl} control A control to dispose.             *              * @returns {void}             */            static dispose(control: ITemplateControl): void {                if (isNull(control)) {                    return;                }                var uid = control.uid,                    childControls = control.controls,                    controls = (childControls && childControls.slice(0)),                    ContextManager = Control.$ContextManagerStatic,                    define = ContextManager.defineProperty;                if (!isNull(controls)) {                    var length = controls.length - 1;                    for (var i = length; i >= 0; --i) {                        Control.dispose(controls[i]);                    }                }                if (isFunction(control.dispose)) {                    control.dispose();                }                Control.removeEventListeners(control);                TemplateControl.removeElement(control);                TemplateControl.$ResourcesFactory.dispose(control);                TemplateControl.$BindableTemplatesFactory.dispose(control);                deleteProperty(TemplateControl.__resourceCache, control.uid);                ContextManager.dispose(control);                events.EventManager.dispose(control.uid);                TemplateControl.$ManagerCache.remove(uid);                Control.removeParent(control);                define(control, 'context', null, true, true);                define(control, 'resources', null, true, true);                control.attributes = null;                control.bindableTemplates = null;                control.controls = [];                control.root = null;                control.innerTemplate = null;            }            /**             * @name loadControl             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @static             *              * @description             * Loads the control tree depth first (visit children, then visit self).             *              * @param {plat.ui.ITemplateControl} control The control serving as the root control to load.             *              * @returns {void}             */            static loadControl(control: ITemplateControl): void {                var children = control.controls,                    length = children.length,                    child: ITemplateControl;                for (var i = 0; i < length; ++i) {                    child = <ITemplateControl>children[i];                    if (!isNull(child.controls)) {                        TemplateControl.loadControl(child);                    } else {                        child.loaded();                    }                }                control.loaded();            }            /**             * @name contextChanged             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @static             * @variation 0             *              * @description             * Notifies a control that its context has been changed by              * calling the "control.contextChanged" method if it exists.             *              * @param {plat.IControl} control The control whose context changed.             * @param {any} newValue The new value of the control's context.             * @param {any} oldValue The old value of the control's context.             *              * @returns {void}             */            static contextChanged(control: IControl, newValue: any, oldValue: any): void;            /**             * @name contextChanged             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @static             * @variation 1             *              * @description             * Notifies a control that its context has been changed by              * calling the "control.contextChanged" method if it exists.             *              * @param {plat.ui.ITemplateControl} control The control whose context changed.             * @param {any} newValue The new value of the control's context.             * @param {any} oldValue The old value of the control's context.             *              * @returns {void}             */            static contextChanged(control: ITemplateControl, newValue: any, oldValue: any): void {                control.context = newValue;                TemplateControl.setContextResources(control);                if (isFunction(control.contextChanged)) {                    control.contextChanged(newValue, oldValue);                }            }            /**             * @name setContextResources             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @static             *              * @description             * Sets the 'context' resource value on a {@link plat.ui.ITemplateControl|ITemplateControl}. If the control specifies              * hasOwnContext as true, the 'rootContext' resource value will be set.             *              * @param {plat.ui.ITemplateControl} control The control whose context resources will be set.             *              * @returns {void}             */            static setContextResources(control: ITemplateControl): void {                var value = control.context;                if (isNull(control.resources)) {                    control.resources = TemplateControl.$ResourcesFactory.getInstance();                    control.resources.initialize(control);                }                if (control.hasOwnContext) {                    if (isNull((<any>control.resources).rootContext)) {                        control.resources.add({                            root: {                                type: 'observable',                                value: value                            }                        });                    } else {                        (<any>control.resources).rootContext.value = value;                    }                }                if (isNull((<any>control.resources).context)) {                    control.resources.add({                        context: {                            type: 'observable',                            value: value                        }                    });                    return;                }                (<any>control.resources).context.value = value;            }            /**             * @name removeElement             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @static             *              * @description             * Completely removes a control's element from its parentNode. If the              * control implements replaceWith=null, All of its nodes between its              * startNode and endNode (inclusive) will be removed.             *              * @param {plat.ui.ITemplateControl} control The control whose element should be removed.             *              * @returns {void}             */            static removeElement(control: ITemplateControl): void {                if (isNull(control)) {                    return;                }                var dom = control.dom,                    element = control.element,                    parentNode: Node;                if (control.replaceWith === null ||                control.replaceWith === '' ||                isDocumentFragment(element)) {                    dom.removeAll(control.startNode, control.endNode);                    control.elementNodes = control.startNode = control.endNode = null;                    return;                } else if (isNull(element)) {                    return;                }                parentNode = element.parentNode;                if (!isNull(parentNode)) {                    parentNode.removeChild(element);                }                control.element = null;            }            /**             * @name setAbsoluteContextPath             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @static             *              * @description             * Sets the absoluteContextPath read-only property on a control.             *              * @param {plat.ui.ITemplateControl} control The control on which to set the absoluteContextPath.             * @param {string} path The path to set on the control.             *              * @returns {void}             */            static setAbsoluteContextPath(control: ITemplateControl, path: string): void {                Control.$ContextManagerStatic.defineGetter(control, 'absoluteContextPath', path, false, true);            }            /**             * @name determineTemplate             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @static             *              * @description             * Determines the template for a control by searching for a templateUrl,              * using the provided templateUrl, or serializing the control's templateString.             *              * @param {plat.ui.ITemplateControl} control The control whose template is being determined.             * @param {string} templateUrl? The potential template URL to use to grab the template.             *              * @returns {plat.async.IThenable<DocumentFragment>} A promise that resolves to the proper template.             */            static determineTemplate(control: ITemplateControl, templateUrl?: string): async.IThenable<DocumentFragment> {                var template: any,                    templateCache = TemplateControl.$TemplateCache,                    dom = control.dom,                    Promise = TemplateControl.$Promise;                if (!isNull(templateUrl)) {                    // do nothing                } else if (!isNull(control.templateUrl)) {                    templateUrl = control.templateUrl;                } else if (!isNull(control.templateString)) {                    var type = control.type;                    return templateCache.read(type).catch((template: any) => {                        if (isNull(template)) {                            template = dom.serializeHtml(control.templateString);                    }                    return templateCache.put(type, template);                    });                } else {                    return <any>Promise.reject(null);                }                template = templateCache.read(templateUrl);                var $exception: IExceptionStatic;                return Promise.cast<DocumentFragment>(template).catch((error) => {                    if (isNull(error)) {                        return TemplateControl.$Http.ajax<string>({ url: templateUrl });                    }                }).then<DocumentFragment>((success) => {                    if (isDocumentFragment(success)) {                        return Promise.resolve(<DocumentFragment>(<any>success));                    } else if (!isObject(success) || !isString(success.response)) {                        $exception = acquire(__ExceptionStatic);                        $exception.warn('No template found at ' + templateUrl, $exception.AJAX);                        return Promise.resolve(dom.serializeHtml());                    }                    var templateString = success.response;                    if (isEmpty(templateString.trim())) {                        return Promise.resolve(dom.serializeHtml());                    }                    template = dom.serializeHtml(templateString);                    return templateCache.put(templateUrl, template);                }).catch((error) => {                    postpone(() => {                        $exception = acquire(__ExceptionStatic);                        $exception.fatal('Failure to get template from ' + templateUrl + '.',                            $exception.TEMPLATE);                    });                    return error;                });            }            /**             * @name detach             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @static             *              * @description             * Detaches a {@link plat.ui.TemplateControl|TemplateControl}. Disposes its children,              * but does not dispose the {@link plat.ui.TemplateControl|TemplateControl}.             *              * @param {plat.ui.ITemplateControl} control The control to be detached.             *              * @returns {void}             */            static detach(control: ITemplateControl): void {                if (isNull(control) || isNull(control.controls)) {                    return;                }                var controls = control.controls.slice(0),                    length = controls.length;                for (var i = 0; i < length; ++i) {                    Control.dispose(controls[i]);                }                TemplateControl.removeElement(control);                TemplateControl.$ResourcesFactory.dispose(control, true);                deleteProperty(TemplateControl.__resourceCache, control.uid);                Control.$ContextManagerStatic.dispose(control, true);                events.EventManager.dispose(control.uid);                TemplateControl.$ManagerCache.remove(control.uid);                Control.removeParent(control);                control.controls = [];                control.attributes = null;            }            /**             * @name getInstance             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @static             *              * @description             * Returns a new instance of {@link plat.ui.TemplateControl|TemplateControl}.             *              * @returns {plat.ui.ITemplateControl} The new {@link plat.ui.TemplateControl|TemplateControl} instance.             */            static getInstance(): ITemplateControl {                return new TemplateControl();            }            /**             * @name __resourceCache             * @memberof plat.ui.TemplateControl             * @kind property             * @access private             * @static             *              * @type {any}             *              * @description             * An object for quickly retrieving previously accessed resources.             */            private static __resourceCache: any = {};            /**             * @name priority             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {number}             *              * @description             * By default {@link plat.ui.TemplateControl|TemplateControls} have a priority of 100.             */            priority = 100;            /**             * @name context             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {any}             *              * @description             * The context of an {@link plat.ui.ITemplateControl|ITemplateControl}, used for inheritance and data-binding.             */            context: any = null;            /**             * @name absoluteContextPath             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * Specifies the absolute path from where the context was created to this IControl's context.             * Used by the {@link plat.observable.ContextManager|ContextManager} for maintaining context parity              * (i.e. 'context.childContextProperty.grandChildContextProperty').             */            absoluteContextPath: string = null;            /**             * @name resources             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {plat.ui.IResources}             *              * @description             * Resources are used for providing aliases to use in markup expressions. They              * are particularly useful when trying to access properties outside of the              * current context, as well as reassigning context at any point in an app.             *              * @remarks             * By default, every control has a resource for '@control' and '@context'.             * {@link plat.ui.IViewControl|IViewControl} objects also have a resource for '@root' and '@rootContext',              * which is a reference to their root control and root context.             *              * Resources can be created in HTML, or through the exposed control.resources              * object. If specified in HTML, they must be the first element child of the              * control upon which the resources will be placed. IViewControls that use a              * templateUrl can have resources as their first element in the templateUrl.             *              * In the provided example, the resources can be accessed by using '@Cache' and '@testObj'.             * The type of resource is denoted by the element name.             *              * Only resources of type 'observable' will have data binding. The types of resources are:             * function, injectable, observable, and object. Resources of type 'function' will have their             * associated function context bound to the control that contains the resource.             *              * When an alias is found in a markup expression, the framework will search up the control chain              * to find the alias on a control's resources. This first matching alias will be used.             *              * @example             * <custom-control>             *     <plat-resources>             *         <injectable alias="Cache">$CacheFactory</injectable>             *         <observable alias="testObj">             *              {              *                  foo: 'foo',              *                  bar: 'bar',              *                  baz: 2              *              }             *         </observable>             *     </plat-resources>             * </custom-control>             */            resources: IResources;            /**             * @name hasOwnContext             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {boolean}             *              * @description             * Flag indicating whether or not the {@link plat.ui.ITemplateControl|ITemplateControl} defines the context property.             */            hasOwnContext: boolean = false;            /**             * @name templateString             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * A string representing the DOM template for this control. If this property is             * defined on a {@link plat.ui.ITemplateControl|ITemplateControl} then DOM will be created and put in the              * control's element prior to calling the 'setTemplate' method.             */            templateString: string;            /**             * @name templateUrl             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * A url containing a string representing the DOM template for this control. If this property is             * defined on a {@link plat.ui.ITemplateControl|ITemplateControl} then DOM will be created and put in the              * control's element prior to calling the 'setTemplate' method. This property takes              * precedence over templateString. In the event that both are defined, templateString             * will be ignored.             */            templateUrl: string;            /**             * @name innerTemplate             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {DocumentFragment}             *              * @description             * A DocumentFragment representing the innerHTML that existed when this control was instantiated.             * This property will only contain the innerHTML when either a templateString or templateUrl is             * defined. Its important to clone this property when injecting it somewhere, else its childNodes             * will disappear.             *              * @example this.innerTemplate.cloneNode(true); //Useful if this is not a one-time injection.             */            innerTemplate: DocumentFragment;            /**             * @name bindableTemplates             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {plat.ui.IBindableTemplates}             *              * @description             * An {@link plat.ui.IBindableTemplates|IBindableTemplates} object used for binding a data context to a template.              * This is an advanced function of a {@link plat.ui.ITemplateControl|ITemplateControl}.             */            bindableTemplates: IBindableTemplates;            /**             * @name controls             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {Array<plat.IControl>}             *              * @description             * An array of child controls. Any controls created by this control can be found in this array. The controls in             * this array will have reference to this control in their parent property.             */            controls: Array<IControl>;            /**             * @name elementNodes             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {Array<Node>}             *              * @description             * A Node array for managing the {@link plat.ui.ITemplateControl|ITemplateControl's} childNodes in the event that this control              * replaces its element. This property will only exist/be of use for a {@link plat.ui.ITemplateControl|ITemplateControl} that              * implements the replaceWith property.             */            elementNodes: Array<Node>;            /**             * @name startNode             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {Node}             *              * @description             * The first node in the {@link plat.ui.ITemplateControl|ITemplateControl's} body. This property will be a Comment node when the              * control implements replaceWith = null, otherwise it will be null. This property allows an              * {@link plat.ui.ITemplateControl|ITemplateControl} to add nodes to its body in the event that it replaces its element.             *              * @example this.startNode.parentNode.insertBefore(node, this.startNode.nextSibling);             */            startNode: Node;            /**             * @name endNode             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {Node}             *              * @description             * The last node in the {@link plat.ui.ITemplateControl|ITemplateControl's} body. This property will be a Comment node when the              * control implements the replaceWith property, otherwise it will be null. This property allows a              * {@link plat.ui.ITemplateControl|ITemplateControl} to add nodes to its body in the event that it replaces its element.             *              * @example this.endNode.parentNode.insertBefore(node, this.endNode);             */            endNode: Node;            /**             * @name replaceWith             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * Allows a {@link plat.ui.ITemplateControl|ITemplateControl} to either swap its element with another element (e.g. plat-select),              * or replace its element altogether. If null or empty string, the element will be removed from the DOM, and the              * childNodes of the element will be in its place. In addition, when the element is placed startNode and endNode Comments              * are created, and the childNodes are added to the elementNodes property on the control. The replaceWith              * property can be any property that works with document.createElement(). If the control's element had              * attributes (as well as attribute IControls), those attributes will be carried to the swapped element. The default              * replaceWith is 'any,' meaning it will default to a 'div' in the case that the control type is used as the              * element's nodename (i.e. <plat-foreach plat-context="..."></plat-foreach>), but will maintain whatever element type              * is used otherwise (i.e. <tr plat-control="plat-foreach" plat-context="..."></tr>).             */            replaceWith = 'any';            /**             * @name root             * @memberof plat.ui.TemplateControl             * @kind property             * @access public             *              * @type {plat.ui.ITemplateControl}             *              * @description             * Set to the root ancestor control from which this control inherits its context. This value             * can be equal to this control.             */            root: ITemplateControl;            /**             * @name contextChanged             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             *              * @description             * This event is fired when an {@link plat.ui.ITemplateControl|ITemplateControl's} context property              * is changed by an ancestor control.             *              * @param {any} newValue? The new value of the context.             * @param {any} oldValue? The old value of the context.             *              * @returns {void}             */            contextChanged(newValue?: any, oldValue?: any): void { }            /**             * @name setTemplate             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             *              * @description             * A method called for {@link plat.ui.ITemplateControl|ITemplateControls} to set their template.              * During this method a control should ready its template for compilation. Whatever is in the control's              * element (or elementNodes if replaceWith is implemented) after this method's execution will be compiled              * and appear on the DOM.             *              * @returns {void}             */            setTemplate(): void { }            /**             * @name getIdentifier             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             *              * @description             * Finds the identifier string associated with the given context object. The string returned             * is the path from a control's context.             *              * @param {any} context The object/primitive to locate on the control's context.             *              * @returns {string} The input context's identifier string.             *              * @example              *     // returns 'title.font'             *     this.getIdentifier(this.context.title.font);             */            getIdentifier(context: any): string {                var queue: Array<{ context: any; identifier: string; }> = [],                    dataContext = this.context,                    found = false,                    obj = {                        context: dataContext,                        identifier: ''                    },                    length: number,                    keys: Array<string>,                    key: string,                    newObj: any;                if (dataContext === context) {                    found = true;                } else {                    queue.push(obj);                }                while (queue.length > 0) {                    obj = queue.pop();                    if (!isObject(obj.context)) {                        continue;                    }                    keys = Object.keys(obj.context);                    length = keys.length;                    for (var i = 0; i < length; ++i) {                        key = keys[i];                        newObj = obj.context[key];                        if (newObj === context) {                            return (obj.identifier !== '') ? (obj.identifier + '.' + key) : key;                        }                        queue.push({                            context: newObj,                            identifier: (obj.identifier !== '') ? (obj.identifier + '.' + key) : key                        });                    }                }                if (!found) {                    return;                }                return obj.identifier;            }            /**             * @name getAbsoluteIdentifier             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             *              * @description             * Finds the absolute identifier string associated with the given context object. The string returned             * is the path from a control's root ancestor's context.             *              * @param {any} context The object/primitive to locate on the root control's context.             *              * @returns {string} The input context's identifier string as seen from the root context object.             */            getAbsoluteIdentifier(context: any): string {                if (context === this.context) {                    return this.absoluteContextPath;                }                var localIdentifier = this.getIdentifier(context);                if (isNull(localIdentifier)) {                    return localIdentifier;                }                return this.absoluteContextPath + '.' + localIdentifier;            }            /**             * @name getResources             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             *              * @description             * Finds the associated resources and builds a context object containing             * the values.             *              * @param {Array<string>} aliases An array of aliases to search for.             * @param {any} resources? An optional resources object to extend, if no resources object is passed in a new one will be created.             *              * @returns {IObject<any>} The context object containing the values of the associated resources.             */            getResources(aliases: Array<string>, resources?: any): IObject<any> {                return TemplateControl.getResources(this, aliases, resources);            }            /**             * @name findResource             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             *              * @description             * Starts at a control and searches up its parent chain for a particular resource alias.              * If the resource is found, it will be returned along with the control instance on which             * the resource was found.             *              * @param {string} alias The alias to search for.             *              * @returns {{ resource: plat.ui.IResource; control: plat.ui.ITemplateControl; }} An object consisting of the              * found resource along with its corresponding control.             */            findResource(alias: string): { resource: IResource; control: ITemplateControl; } {                return TemplateControl.findResource(this, alias);            }            /**             * @name evaluateExpression             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @variation 0             *              * @description             * Evaluates an expression string, using the input context or control.context.             *              * @param {string} expression The expression string to evaluate.             * @param {any} context? An optional context with which to parse. If              * no context is specified, the control.context will be used.             *              * @returns {any} The evaluated object/primitive.             */            evaluateExpression(expression: string, context?: any): any;            /**             * @name evaluateExpression             * @memberof plat.ui.TemplateControl             * @kind function             * @access public             * @variation 1             *              * @description             * Evaluates an expression string, using the input context or control.context.             *              * @param {plat.expressions.IParsedExpression} expression The previously parsed expression to evaluate.             * @param {any} context? An optional context with which to parse. If              * no context is specified, the control.context will be used.             *              * @returns {any} The evaluated object/primitive.             */            evaluateExpression(expression: expressions.IParsedExpression, context?: any): any;            evaluateExpression(expression: any, context?: any): any {                return TemplateControl.evaluateExpression(expression, this, context);            }        }        /**         * The Type for referencing the '$TemplateControlFactory' injectable as a dependency.         */        export function ITemplateControlFactory(            $ResourcesFactory?: IResourcesFactory,            $BindableTemplatesFactory?: IBindableTemplatesFactory,            $ManagerCache?: storage.ICache<processing.IElementManager>,            $TemplateCache?: storage.ITemplateCache,            $Parser?: expressions.IParser,            $Http?: async.IHttp,            $Promise?: async.IPromise): ITemplateControlFactory {                TemplateControl.$ResourcesFactory = $ResourcesFactory;                TemplateControl.$BindableTemplatesFactory = $BindableTemplatesFactory;                TemplateControl.$ManagerCache = $ManagerCache;                TemplateControl.$TemplateCache = $TemplateCache;                TemplateControl.$Parser = $Parser;                TemplateControl.$Http = $Http;                TemplateControl.$Promise = $Promise;                return TemplateControl;        }        register.injectable(__TemplateControlFactory, ITemplateControlFactory, [            __ResourcesFactory,            __BindableTemplatesFactory,            __ManagerCache,            __TemplateCache,            __Parser,            __Http,            __Promise        ], __FACTORY);        /**         * @name ITemplateControlFactory         * @memberof plat.ui         * @kind interface         *          * @description         * Creates and manages {@link plat.ui.ITemplateControl|ITemplateControls}.         */        export interface ITemplateControlFactory {            /**             * @name evaluateExpression             * @memberof plat.ui.ITemplateControlFactory             * @kind function             * @access public             * @static             * @variation 0             *              * @description             * Evaluates an expression string with a given control and optional control's context and aliases.             *              * @param {string} expression The expression string (e.g. 'foo + foo').             * @param {plat.ui.ITemplateControl} control? The control used for evaluation context.             * @param {any} aliases? An optional alias object containing resource alias values             *              * @returns {any} The evaluated object.             */            evaluateExpression(expression: string, control?: ITemplateControl, aliases?: any): any;            /**             * @name evaluateExpression             * @memberof plat.ui.ITemplateControlFactory             * @kind function             * @access public             * @static             * @variation 1             *              * @description             * Evaluates an expression string with a given control and optional control's context and aliases.             *              * @param {plat.expressions.IParsedExpression} expression A parsed expression object created using the              * plat.expressions.IParser injectable.             * @param {plat.ui.ITemplateControl} control? The control used for evaluation context.             * @param {any} aliases? An optional alias object containing resource alias values             *              * @returns {any} The evaluated object.             */            evaluateExpression(expression: expressions.IParsedExpression, control?: ITemplateControl, aliases?: any): any;            /**             * @name getResources             * @memberof plat.ui.ITemplateControlFactory             * @kind function             * @access public             * @static             *              * @description             * Given a control and Array of aliases, finds the associated resources and builds a context object containing             * the values. Returns the object.             *              * @param {plat.ui.ITemplateControl} control The control used as the starting point for finding resources.             * @param {Array<string>} aliases An array of aliases to search for.             * @param {any} resources? An optional resources object to extend, if no resources object is passed in a new one will be created.             *              * @returns {IObject<any>} An object representing a set of resources.             */            getResources(control: ITemplateControl, aliases: Array<string>, resources?: any): IObject<any>;            /**             * @name findResource             * @memberof plat.ui.ITemplateControlFactory             * @kind function             * @access public             * @static             *              * @description             * Starts at a control and searches up its parent chain for a particular resource alias.              * If the resource is found, it will be returned along with the control instance on which             * the resource was found.             *              * @param {plat.ui.ITemplateControl} control The control on which to start searching for the resource alias.             * @param {string} alias The alias to search for.             *              * @returns {{ resource: plat.ui.IResource; control: plat.ui.ITemplateControl; }} An object consisting of the              * found resource along with its corresponding control.             */            findResource(control: ITemplateControl, alias: string): { resource: IResource; control: ITemplateControl; };            /**             * @name dispose             * @memberof plat.ui.ITemplateControlFactory             * @kind function             * @access public             * @static             *              * @description             * Recursively disposes a control and its children.             *              * @param {plat.ui.ITemplateControl} control A control to dispose.             *              * @returns {void}             */            dispose(control: ITemplateControl): void;            /**             * @name loadControl             * @memberof plat.ui.ITemplateControlFactory             * @kind function             * @access public             * @static             *              * @description             * Loads the control tree depth first (visit children, then visit self).             *              * @param {plat.ui.ITemplateControl} control The control serving as the root control to load.             *              * @returns {void}             */            loadControl(control: ITemplateControl): void;            /**             * @name contextChanged             * @memberof plat.ui.ITemplateControlFactory             * @kind function             * @access public             * @static             * @variation 0             *              * @description             * Notifies a control that its context has been changed by              * calling the "control.contextChanged" method if it exists.             *              * @param {plat.IControl} control The control whose context changed.             * @param {any} newValue The new value of the control's context.             * @param {any} oldValue The old value of the control's context.             *              * @returns {void}             */            contextChanged(control: IControl, newValue: any, oldValue: any): void;            /**             * @name contextChanged             * @memberof plat.ui.ITemplateControlFactory             * @kind function             * @access public             * @static             * @variation 1             *              * @description             * Notifies a control that its context has been changed by              * calling the "control.contextChanged" method if it exists.             *              * @param {plat.ui.ITemplateControl} control The control whose context changed.             * @param {any} newValue The new value of the control's context.             * @param {any} oldValue The old value of the control's context.             *              * @returns {void}             */            contextChanged(control: ITemplateControl, newValue: any, oldValue: any): void;            /**             * @name setContextResources             * @memberof plat.ui.ITemplateControlFactory             * @kind function             * @access public             * @static             *              * @description             * Sets the 'context' resource value on a {@link plat.ui.ITemplateControl|ITemplateControl}. If the control specifies              * hasOwnContext as true, the 'rootContext' resource value will be set.             *              * @param {plat.ui.ITemplateControl} control The control whose context resources will be set.             *              * @returns {void}             */            setContextResources(control: ITemplateControl): void;            /**             * @name removeElement             * @memberof plat.ui.ITemplateControlFactory             * @kind function             * @access public             * @static             *              * @description             * Completely removes a control's element from its parentNode. If the              * control implements replaceWith=null, All of its nodes between its              * startNode and endNode (inclusive) will be removed.             *              * @param {plat.ui.ITemplateControl} control The control whose element should be removed.             *              * @returns {void}             */            removeElement(control: ITemplateControl): void;            /**             * @name setAbsoluteContextPath             * @memberof plat.ui.ITemplateControlFactory             * @kind function             * @access public             * @static             *              * @description             * Sets the absoluteContextPath read-only property on a control.             *              * @param {plat.ui.ITemplateControl} control The control on which to set the absoluteContextPath.             * @param {string} path The path to set on the control.             *              * @returns {void}             */            setAbsoluteContextPath(control: ITemplateControl, path: string): void;            /**             * @name determineTemplate             * @memberof plat.ui.ITemplateControlFactory             * @kind function             * @access public             * @static             *              * @description             * Determines the template for a control by searching for a templateUrl,              * using the provided templateUrl, or serializing the control's templateString.             *              * @param {plat.ui.ITemplateControl} control The control whose template is being determined.             * @param {string} templateUrl? The potential template URL to use to grab the template.             *              * @returns {plat.async.IThenable<DocumentFragment>} A promise that resolves to the proper template.             */            determineTemplate(control: ITemplateControl, templateUrl?: string): async.IThenable<DocumentFragment>;            /**             * @name detach             * @memberof plat.ui.ITemplateControlFactory             * @kind function             * @access public             * @static             *              * @description             * Detaches a {@link plat.ui.TemplateControl|TemplateControl}. Disposes its children,              * but does not dispose the {@link plat.ui.TemplateControl|TemplateControl}.             *              * @param {plat.ui.ITemplateControl} control The control to be detached.             *              * @returns {void}             */            detach(control: ITemplateControl): void;            /**             * @name getInstance             * @memberof plat.ui.ITemplateControlFactory             * @kind function             * @access public             * @static             *              * @description             * Returns a new instance of {@link plat.ui.TemplateControl|TemplateControl}.             *              * @returns {plat.ui.ITemplateControl} The new {@link plat.ui.TemplateControl|TemplateControl} instance.             */            getInstance(): ITemplateControl;        }        /**         * @name ITemplateControl         * @memberof plat.ui         * @kind interface         *          * @extends {plat.IControl}         *          * @description         * Describes a control which provides properties and methods for managing its body HTML.         */        export interface ITemplateControl extends IControl {            /**             * @name context             * @memberof plat.ui.ITemplateControl             * @kind property             * @access public             *              * @type {any}             *              * @description             * The context of an {@link plat.ui.ITemplateControl|ITemplateControl}, used for inheritance and data-binding.             */            context?: any;            /**             * @name absoluteContextPath             * @memberof plat.ui.ITemplateControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * Specifies the absolute path from where the context was created to this IControl's context.             * Used by the {@link plat.observable.ContextManager|ContextManager} for maintaining context parity              * (i.e. 'context.childContextProperty.grandChildContextProperty').             */            absoluteContextPath?: string;            /**             * @name resources             * @memberof plat.ui.ITemplateControl             * @kind property             * @access public             *              * @type {plat.ui.IResources}             *              * @description             * Resources are used for providing aliases to use in markup expressions. They              * are particularly useful when trying to access properties outside of the              * current context, as well as reassigning context at any point in an app.             *              * @remarks             * By default, every control has a resource for '@control' and '@context'.             * {@link plat.ui.IViewControl|IViewControl} objects also have a resource for '@root' and '@rootContext',              * which is a reference to their root control and root context.             *              * Resources can be created in HTML, or through the exposed control.resources              * object. If specified in HTML, they must be the first element child of the              * control upon which the resources will be placed. IViewControls that use a              * templateUrl can have resources as their first element in the templateUrl.             *              * In the provided example, the resources can be accessed by using '@Cache' and '@testObj'.             * The type of resource is denoted by the element name.             *              * Only resources of type 'observable' will have data binding. The types of resources are:             * function, injectable, observable, and object. Resources of type 'function' will have their             * associated function context bound to the control that contains the resource.             *              * When an alias is found in a markup expression, the framework will search up the control chain              * to find the alias on a control's resources. This first matching alias will be used.             *              * @example             * <custom-control>             *     <plat-resources>             *         <injectable alias="Cache">$CacheFactory</injectable>             *         <observable alias="testObj">             *              {              *                  foo: 'foo',              *                  bar: 'bar',              *                  baz: 2              *              }             *         </observable>             *     </plat-resources>             * </custom-control>             */            resources?: IResources;            /**             * @name hasOwnContext             * @memberof plat.ui.ITemplateControl             * @kind property             * @access public             *              * @type {boolean}             *              * @description             * Flag indicating whether or not the {@link plat.ui.ITemplateControl|ITemplateControl} defines the context property.             */            hasOwnContext?: boolean;            /**             * @name templateString             * @memberof plat.ui.ITemplateControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * A string representing the DOM template for this control. If this property is             * defined on a {@link plat.ui.ITemplateControl|ITemplateControl} then DOM will be created and put in the              * control's element prior to calling the 'setTemplate' method.             */            templateString?: string;            /**             * @name templateUrl             * @memberof plat.ui.ITemplateControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * A url containing a string representing the DOM template for this control. If this property is             * defined on a {@link plat.ui.ITemplateControl|ITemplateControl} then DOM will be created and put in the              * control's element prior to calling the 'setTemplate' method. This property takes              * precedence over templateString. In the event that both are defined, templateString             * will be ignored.             */            templateUrl?: string;            /**             * @name innerTemplate             * @memberof plat.ui.ITemplateControl             * @kind property             * @access public             *              * @type {DocumentFragment}             *              * @description             * A DocumentFragment representing the innerHTML that existed when this control was instantiated.             * This property will only contain the innerHTML when either a templateString or templateUrl is             * defined. Its important to clone this property when injecting it somewhere, else its childNodes             * will disappear.             *              * @example this.innerTemplate.cloneNode(true); //Useful if this is not a one-time injection.             */            innerTemplate?: DocumentFragment;            /**             * @name bindableTemplates             * @memberof plat.ui.ITemplateControl             * @kind property             * @access public             *              * @type {plat.ui.IBindableTemplates}             *              * @description             * An {@link plat.ui.IBindableTemplates|IBindableTemplates} object used for binding a data context to a template.              * This is an advanced function of a {@link plat.ui.ITemplateControl|ITemplateControl}.             */            bindableTemplates?: IBindableTemplates;            /**             * @name controls             * @memberof plat.ui.ITemplateControl             * @kind property             * @access public             *              * @type {Array<plat.IControl>}             *              * @description             * An array of child controls. Any controls created by this control can be found in this array. The controls in             * this array will have reference to this control in their parent property.             */            controls?: Array<IControl>;            /**             * @name elementNodes             * @memberof plat.ui.ITemplateControl             * @kind property             * @access public             *              * @type {Array<Node>}             *              * @description             * A Node array for managing the {@link plat.ui.ITemplateControl|ITemplateControl's} childNodes in the event that this control              * replaces its element. This property will only exist/be of use for a {@link plat.ui.ITemplateControl|ITemplateControl} that              * implements the replaceWith property.             */            elementNodes?: Array<Node>;            /**             * @name startNode             * @memberof plat.ui.ITemplateControl             * @kind property             * @access public             *              * @type {Node}             *              * @description             * The first node in the {@link plat.ui.ITemplateControl|ITemplateControl's} body. This property will be a Comment node when the              * control implements replaceWith = null, otherwise it will be null. This property allows an              * {@link plat.ui.ITemplateControl|ITemplateControl} to add nodes to its body in the event that it replaces its element.             *              * @example this.startNode.parentNode.insertBefore(node, this.startNode.nextSibling);             */            startNode?: Node;            /**             * @name endNode             * @memberof plat.ui.ITemplateControl             * @kind property             * @access public             *              * @type {Node}             *              * @description             * The last node in the {@link plat.ui.ITemplateControl|ITemplateControl's} body. This property will be a Comment node when the              * control implements the replaceWith property, otherwise it will be null. This property allows a              * {@link plat.ui.ITemplateControl|ITemplateControl} to add nodes to its body in the event that it replaces its element.             *              * @example this.endNode.parentNode.insertBefore(node, this.endNode);             */            endNode?: Node;            /**             * @name replaceWith             * @memberof plat.ui.ITemplateControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * Allows a {@link plat.ui.ITemplateControl|ITemplateControl} to either swap its element with another element (e.g. plat-select),              * or replace its element altogether. If null or empty string, the element will be removed from the DOM, and the              * childNodes of the element will be in its place. In addition, when the element is placed startNode and endNode Comments              * are created, and the childNodes are added to the elementNodes property on the control. The replaceWith              * property can be any property that works with document.createElement(). If the control's element had              * attributes (as well as attribute IControls), those attributes will be carried to the swapped element. The default              * replaceWith is 'any,' meaning it will default to a 'div' in the case that the control type is used as the              * element's nodename (i.e. <plat-foreach plat-context="..."></plat-foreach>), but will maintain whatever element type              * is used otherwise (i.e. <tr plat-control="plat-foreach" plat-context="..."></tr>).             */            replaceWith?: string;            /**             * @name root             * @memberof plat.ui.ITemplateControl             * @kind property             * @access public             *              * @type {plat.ui.ITemplateControl}             *              * @description             * Set to the root ancestor control from which this control inherits its context. This value             * can be equal to this control.             */            root?: ITemplateControl;            /**             * @name setTemplate             * @memberof plat.ui.ITemplateControl             * @kind function             * @access public             *              * @description             * A method called for {@link plat.ui.ITemplateControl|ITemplateControls} to set their template.              * During this method a control should ready its template for compilation. Whatever is in the control's              * element (or elementNodes if replaceWith is implemented) after this method's execution will be compiled              * and appear on the DOM.             *              * @returns {void}             */            setTemplate? (): void;            /**             * @name contextChanged             * @memberof plat.ui.ITemplateControl             * @kind function             * @access public             *              * @description             * This event is fired when an {@link plat.ui.ITemplateControl|ITemplateControl's} context property              * is changed by an ancestor control.             *              * @param {any} newValue? The new value of the context.             * @param {any} oldValue? The old value of the context.             *              * @returns {void}             */            contextChanged? (newValue: any, oldValue: any): void;            /**             * @name getIdentifier             * @memberof plat.ui.ITemplateControl             * @kind function             * @access public             *              * @description             * Finds the identifier string associated with the given context object. The string returned             * is the path from a control's context.             *              * @param {any} context The object/primitive to locate on the control's context.             *              * @returns {string} The input context's identifier string.             *              * @example              *     // returns 'title.font'             *     this.getIdentifier(this.context.title.font);             */            getIdentifier? (context: any): string;            /**             * @name getAbsoluteIdentifier             * @memberof plat.ui.ITemplateControl             * @kind function             * @access public             *              * @description             * Finds the absolute identifier string associated with the given context object. The string returned             * is the path from a control's root ancestor's context.             *              * @param {any} context The object/primitive to locate on the root control's context.             *              * @returns {string} The input context's identifier string as seen from the root context object.             */            getAbsoluteIdentifier? (context: any): string;            /**             * @name getResources             * @memberof plat.ui.ITemplateControl             * @kind function             * @access public             *              * @description             * Finds the associated resources and builds a context object containing             * the values.             *              * @param {Array<string>} aliases An array of aliases to search for.             * @param {any} resources? An optional resources object to extend, if no resources object is passed in a new one will be created.             *              * @returns {IObject<any>} The context object containing the values of the associated resources.             */            getResources? (aliases: Array<string>, resources?: any): IObject<any>;            /**             * @name findResource             * @memberof plat.ui.ITemplateControl             * @kind function             * @access public             *              * @description             * Starts at a control and searches up its parent chain for a particular resource alias.              * If the resource is found, it will be returned along with the control instance on which             * the resource was found.             *              * @param {string} alias The alias to search for.             *              * @returns {{ resource: plat.ui.IResource; control: plat.ui.ITemplateControl; }} An object consisting of the              * found resource along with its corresponding control.             */            findResource? (alias: string): { resource: IResource; control: ITemplateControl; };            /**             * @name evaluateExpression             * @memberof plat.ui.ITemplateControl             * @kind function             * @access public             * @variation 0             *              * @description             * Evaluates an expression string, using the input context or control.context.             *              * @param {string} expression The expression string to evaluate.             * @param {any} context? An optional context with which to parse. If              * no context is specified, the control.context will be used.             *              * @returns {any} The evaluated object/primitive.             */            evaluateExpression? (expression: string, context?: any): any;            /**             * @name evaluateExpression             * @memberof plat.ui.ITemplateControl             * @kind function             * @access public             * @variation 1             *              * @description             * Evaluates an expression string, using the input context or control.context.             *              * @param {plat.expressions.IParsedExpression} expression The previously parsed expression to evaluate.             * @param {any} context? An optional context with which to parse. If              * no context is specified, the control.context will be used.             *              * @returns {any} The evaluated object/primitive.             */            evaluateExpression? (expression: expressions.IParsedExpression, context?: any): any;        }        export class BindablePropertyControl extends TemplateControl implements IBindablePropertyControl {            /**             * The set of functions added externally that listens              * for property changes.             */            _listeners: Array<(newValue: any, oldValue?: any) => void> = [];            /**             * Adds a listener to be called when the bindable property changes.             *              * @param listener The function that acts as a listener.             */            observeProperty(listener: (newValue: any, oldValue?: any) => void): IRemoveListener {                var listeners = this._listeners,                    length = listener.length;                listeners.push(listener);                return () => {                    listeners.splice(length, 1);                };            }            /**             * A function that lets the BindablePropertyControl know when the context's value of the bindable              * property has changed.             *              * @param newValue The new value of the bindable property.             * @param oldValue The old value of the bindable property.             * @param firstTime A boolean signifying whether this is the first set of the property.             */            setProperty(newValue: any, oldValue?: any, firstTime?: boolean): void { }            /**             * A function that signifies when BindablePropertyControl's bindable property has changed.             *              * @param newValue The new value of the property after the change.             * @param oldValue The old value of the property prior to the change.             */            propertyChanged(newValue: any, oldValue?: any): void {                if (newValue === oldValue) {                    return;                }                var listeners = this._listeners,                    length = listeners.length;                for (var i = 0; i < length; ++i) {                    listeners[i](newValue, oldValue);                }            }            /**             * Removes references to the listeners              * defined externally.             */            dispose(): void {                this._listeners = [];            }        }        export interface IBindablePropertyControl extends ITemplateControl {            /**             * Adds a listener to be called when the bindable property changes.             *              * @param listener The function that acts as a listener.             */            observeProperty(listener: (newValue: any, oldValue?: any) => void): IRemoveListener;            /**             * A function that lets the BindablePropertyControl know when the context's value of the bindable              * property has changed.             *              * @param newValue The new value of the bindable property.             * @param oldValue The old value of the bindable property.             * @param firstTime A boolean signifying whether this is the first set of the property.             */            setProperty(newValue: any, oldValue?: any, firstTime?: boolean): void;            /**             * A function that signifies when BindablePropertyControl's bindable property has changed.             *              * @param newValue The new value of the property after the change.             * @param oldValue The old value of the property prior to the change.             */            propertyChanged(newValue: any, oldValue?: any): void;        }        /**         * @name BaseViewControl         * @memberof plat.ui         * @kind class         *          * @extends {plat.ui.TemplateControl}         * @implements {plat.ui.IBaseViewControl}         *          * @description         * A control used in a {@link plat.ui.controls.IBaseport|IBaseport} for simulated page navigation. The          * control has navigation events that are called when navigating to and from the control.         */        export class BaseViewControl extends TemplateControl implements IBaseViewControl {            /**             * @name detach             * @memberof plat.ui.BaseViewControl             * @kind function             * @access public             * @static             *              * @description             * Detaches a {@link plat.ui.BaseViewControl|BaseViewControl}. Disposes its children, but does not dispose the              * {@link plat.ui.BaseViewControl|BaseViewControl}. Useful for the Navigator when storing the              * {@link plat.ui.BaseViewControl|BaseViewControl} in history.             *              * @param {plat.ui.BaseViewControl} control The control to be detached.             *              * @returns {void}             */            static detach(control: IBaseViewControl): void {                TemplateControl.detach(control);            }            /**             * @name dispose             * @memberof plat.ui.BaseViewControl             * @kind function             * @access public             * @static             *              * @description             * Recursively disposes a {@link plat.ui.BaseViewControl|BaseViewControl} and its children.             *              * @param {plat.ui.BaseViewControl} control A control to dispose.             *              * @returns {void}             */            static dispose(control: IBaseViewControl): void {                TemplateControl.dispose(control);            }            /**             * @name getInstance             * @memberof plat.ui.BaseViewControl             * @kind function             * @access public             * @static             *              * @description             * Returns a new instance of a {@link plat.ui.BaseViewControl|BaseViewControl}.             *              * @returns {plat.ui.BaseViewControl} A new {@link plat.ui.BaseViewControl|BaseViewControl} instance.             */            static getInstance(): IBaseViewControl {                return new BaseViewControl();            }            /**             * @name hasOwnContext             * @memberof plat.ui.BaseViewControl             * @kind property             * @access public             *              * @type {boolean}             *              * @description             * Specifies that this control will have its own context, and it should not inherit a context.             */            hasOwnContext: boolean = true;            /**             * @name navigator             * @memberof plat.ui.BaseViewControl             * @kind property             * @access public             *              * @type {plat.navigation.IBaseNavigator}             *              * @description             * Specifies the navigator for this control. Used for navigating to other {@link plat.ui.IBaseViewControl|IBaseViewControls}             * in a {plat.ui.controls.IBaseport|IBaseport}.             */            navigator: navigation.IBaseNavigator;            /**             * @name navigatedTo             * @memberof plat.ui.BaseViewControl             * @kind function             * @access public             *              * @description             * This event is fired when this control has been navigated to.             *              * @param {any} parameter? A navigation parameter sent from the previous              * {@link plat.ui.IBaseViewControl|IBaseViewControl}.             *              * @returns {void}             */            navigatedTo(parameter?: any): void { }            /**             * @name navigatingFrom             * @memberof plat.ui.BaseViewControl             * @kind function             * @access public             *              * @description             * This event is fired when this control is being navigated away from.             *              * @returns {void}             */            navigatingFrom(): void { }        }        /**         * The Type for referencing the '$ViewControlFactory' injectable as a dependency.         */        export function IBaseViewControlFactory(): IBaseViewControlFactory {            return BaseViewControl;        }        register.injectable(__BaseViewControlFactory, IBaseViewControlFactory, null, __FACTORY);        /**         * @name IBaseViewControlFactory         * @memberof plat.ui         * @kind interface         *          * @description         * Creates and manages {@link plat.ui.IBaseViewControl|IBaseViewControls}.         */        export interface IBaseViewControlFactory {            /**             * @name detach             * @memberof plat.ui.IBaseViewControlFactory             * @kind function             * @access public             * @static             *              * @description             * Detaches a {@link plat.ui.BaseViewControl|BaseViewControl}. Disposes its children, but does not dispose the              * {@link plat.ui.BaseViewControl|BaseViewControl}. Useful for the Navigator when storing the              * {@link plat.ui.BaseViewControl|BaseViewControl} in history.             *              * @param {plat.ui.BaseViewControl} control The control to be detached.             *              * @returns {void}             */            detach(control: IBaseViewControl): void;            /**             * @name dispose             * @memberof plat.ui.IBaseViewControlFactory             * @kind function             * @access public             * @static             *              * @description             * Recursively disposes a {@link plat.ui.BaseViewControl|BaseViewControl} and its children.             *              * @param {plat.ui.BaseViewControl} control A control to dispose.             *              * @returns {void}             */            dispose(control: IBaseViewControl): void;            /**             * @name getInstance             * @memberof plat.ui.IBaseViewControlFactory             * @kind function             * @access public             * @static             *              * @description             * Returns a new instance of a {@link plat.ui.BaseViewControl|BaseViewControl}.             *              * @returns {plat.ui.BaseViewControl} A new {@link plat.ui.BaseViewControl|BaseViewControl} instance.             */            getInstance(): IBaseViewControl;        }        /**         * @name IBaseViewControl         * @memberof plat.ui         * @kind interface         *          * @extends {plat.ui.ITemplateControl}         *          * @description         * Describes a control used in a {@link plat.ui.controls.IBaseport|IBaseport} for simulated page navigation. The          * control has navigation events that are called when navigating to and from the control.         */        export interface IBaseViewControl extends ITemplateControl {            /**             * @name hasOwnContext             * @memberof plat.ui.IBaseViewControl             * @kind property             * @access public             *              * @type {boolean}             *              * @description             * Specifies that this control will have its own context, and it should not inherit a context.             */            hasOwnContext?: boolean;            /**             * @name navigator             * @memberof plat.ui.IBaseViewControl             * @kind property             * @access public             *              * @type {plat.navigation.IBaseNavigator}             *              * @description             * Specifies the navigator for this control. Used for navigating to other {@link plat.ui.IBaseViewControl|IBaseViewControls}             * in a {plat.ui.controls.IBaseport|IBaseport}.             */            navigator?: navigation.IBaseNavigator;            /**             * @name navigatedTo             * @memberof plat.ui.IBaseViewControl             * @kind function             * @access public             *              * @description             * This event is fired when this control has been navigated to.             *              * @param {any} parameter? A navigation parameter sent from the previous              * {@link plat.ui.IBaseViewControl|IBaseViewControl}.             *              * @returns {void}             */            navigatedTo? (parameter?: any): void;            /**             * @name navigatingFrom             * @memberof plat.ui.IBaseViewControl             * @kind function             * @access public             *              * @description             * This event is fired when this control is being navigated away from.             *              * @returns {void}             */            navigatingFrom? (): void;        }        /**         * @name ViewControl         * @memberof plat.ui         * @kind class         *          * @extends {plat.ui.BaseViewControl}         * @implements {plat.ui.IViewControl}         *          * @description         * A control used in a {@link plat.ui.controls.Viewport|Viewport} for simulated page navigation. The          * control has navigation events that are called when navigating to and from the control.         */        export class ViewControl extends BaseViewControl implements IViewControl {            /**             * @name navigator             * @memberof plat.ui.ViewControl             * @kind property             * @access public             *              * @type {plat.navigation.INavigatorInstance}             *              * @description             * Specifies the navigator for this control. Used for navigating to other {@link plat.ui.IViewControl|IViewControls}              * in a {@link plat.ui.controls.Viewport|Viewport}.             */            navigator: navigation.INavigatorInstance;        }        /**         * @name IViewControl         * @memberof plat.ui         * @kind interface         *          * @extends {plat.ui.IBaseViewControl}         *          * @description         * Describes a control used in a {@link plat.ui.controls.Viewport|Viewport} for simulated page navigation. The          * control has navigation events that are called when navigating to and from the control.         */        export interface IViewControl extends IBaseViewControl {            /**             * @name navigator             * @memberof plat.ui.IViewControl             * @kind property             * @access public             *              * @type {plat.navigation.INavigatorInstance}             *              * @description             * Specifies the navigator for this control. Used for navigating to other {@link plat.ui.IViewControl|IViewControls}              * in a {@link plat.ui.controls.Viewport|Viewport}.             */            navigator?: navigation.INavigatorInstance;        }        /**         * @name WebViewControl         * @memberof plat.ui         * @kind class         *          * @extends {plat.ui.BaseViewControl}         * @implements {plat.ui.IWebViewControl}         *          * @description         * A control used in a {@link plat.ui.controls.Routeport|Routeport} for simulated page navigation. The          * control has navigation events that are called when navigating to and from the control.         * It also provides functionality for setting the title of a page.         */        export class WebViewControl extends BaseViewControl implements IWebViewControl {            /**             * @name titleElement             * @memberof plat.ui.WebViewControl             * @kind property             * @access public             * @static             *              * @type {HTMLTitleElement}             *              * @description             * The title of the HTML web page.             */            static titleElement: HTMLTitleElement;            /**             * @name descriptionElement             * @memberof plat.ui.WebViewControl             * @kind property             * @access public             * @static             *              * @type {HTMLMetaElement}             *              * @description             * The description meta tag.             */            static descriptionElement: HTMLMetaElement;            /**             * @name setTitle             * @memberof plat.ui.WebViewControl             * @kind function             * @access public             * @static             *              * @description             * Sets the title programmatically and has it reflect in the browser title.             *              * @param {string} title The title to set.             *              * @returns {void}             */            static setTitle(title: string): void {                var element = WebViewControl.titleElement;                if (!isNode(element)) {                    var $document = plat.acquire(plat.Document);                    element = WebViewControl.titleElement = <HTMLTitleElement>$document.head.querySelector('title');                    if (!isNode(element)) {                        element = WebViewControl.titleElement = <HTMLTitleElement>$document.head.appendChild($document.createElement('title'));                    }                }                element.textContent = title.replace(/\//g, ' ');            }            /**             * @name setDescription             * @memberof plat.ui.WebViewControl             * @kind function             * @access public             * @static             *              * @description             * Sets the meta description programmatically.             *              * @param {string} description The description to set.             *              * @returns {void}             */            static setDescription(description: string): void {                var element = WebViewControl.descriptionElement;                if (!isNode(element)) {                    var $document = plat.acquire(plat.Document);                    element = WebViewControl.descriptionElement = <HTMLMetaElement>$document.head.querySelector('meta[name="description"]');                    if (!isNode(element)) {                        element = WebViewControl.descriptionElement = <HTMLMetaElement>$document.head.appendChild($document.createElement('meta'));                        element.setAttribute('name', 'description');                    }                }                element.setAttribute('content', description.replace(/\//g, ' '));            }            /**             * @name title             * @memberof plat.ui.WebViewControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The title of the page, corresponds to the textContent of the title element in the HTML head.             */            title = '';            /**             * @name description             * @memberof plat.ui.WebViewControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The title of the page, corresponds to the content of the description meta element in the HTML head.             */            description = '';            /**             * @name navigator             * @memberof plat.ui.WebViewControl             * @kind property             * @access public             *              * @type {plat.navigation.IRoutingNavigator}             *              * @description             * Specifies the navigator for this control. Used for navigating to other {@link plat.ui.IWebViewControl|IWebViewControls}              * in a {@link plat.ui.controls.Routeport|Routeport}.             */            navigator: navigation.IRoutingNavigator;            /**             * @name constructor             * @memberof plat.ui.WebViewControl             * @kind function             * @access public             *              * @description             * The constructor for a {@link plat.ui.WebViewControl|WebViewControl}. Sets the page title and description              * upon the navigation event occurring.             *              * @returns {plat.ui.WebViewControl} A {@link plat.ui.WebViewControl|WebViewControl} instance.             */            constructor() {                super();                this.on('navigated', () => {                    if (isEmpty(this.title)) {                        this.title = '';                    }                    if (isEmpty(this.description)) {                        this.description = '';                    }                    WebViewControl.setTitle(this.title);                    WebViewControl.setDescription(this.description);                });            }            /**             * @name setTitle             * @memberof plat.ui.WebViewControl             * @kind function             * @access public             *              * @description             * Allows the {@link plat.ui.WebViewControl|WebViewControl} set its title programmatically and              * have it reflect in the browser title.             *              * @param {string} title The title to set.             *              * @returns {void}             */            setTitle(title: string): void {                this.title = title;                WebViewControl.setTitle(title);            }            /**             * @name setDescription             * @memberof plat.ui.WebViewControl             * @kind function             * @access public             *              * @description             * Allows the {@link plat.ui.WebViewControl|WebViewControl} set its description programmatically and              * have it reflect in the browser meta description tag.             *              * @param {string} description The description to set.             *              * @returns {void}             */            setDescription(description: string): void {                this.description = description;                WebViewControl.setDescription(description);            }        }        /**         * @name IWebViewControl         * @memberof plat.ui         * @kind interface         *          * @extends {plat.ui.IBaseViewControl}         *          * @description         * Defines an object intended to be used inside of a {@link plat.ui.controls.Routeport|Routeport}          * to simulate page navigation.         */        export interface IWebViewControl extends IBaseViewControl {            /**             * @name title             * @memberof plat.ui.IWebViewControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The title of the page, corresponds to the textContent of the title element in the HTML head.             */            title?: string;            /**             * @name description             * @memberof plat.ui.IWebViewControl             * @kind property             * @access public             *              * @type {string}             *              * @description             * The title of the page, corresponds to the content of the description meta element in the HTML head.             */            description?: string;            /**             * @name navigator             * @memberof plat.ui.IWebViewControl             * @kind property             * @access public             *              * @type {plat.navigation.IRoutingNavigator}             *              * @description             * Specifies the navigator for this control. Used for navigating to other {@link plat.ui.IWebViewControl|IWebViewControls}              * in a {@link plat.ui.controls.Routeport|Routeport}.             */            navigator?: navigation.IRoutingNavigator;            /**             * @name setTitle             * @memberof plat.ui.IWebViewControl             * @kind function             * @access public             * @static             *              * @description             * Allows the {@link plat.ui.WebViewControl|WebViewControl} set its title programmatically and              * have it reflect in the browser title.             *              * @param {string} title The title to set.             *              * @returns {void}             */            setTitle? (title: string): void;            /**             * @name setDescription             * @memberof plat.ui.IWebViewControl             * @kind function             * @access public             *              * @description             * Allows the {@link plat.ui.WebViewControl|WebViewControl} set its description programmatically and              * have it reflect in the browser meta description tag.             *              * @param {string} description The description to set.             *              * @returns {void}             */            setDescription(description: string): void;        }        /**         * An extensible class dealing with the creation, deletion, and modification          * of DOM.         */        export class Dom implements IDom {            $DomEvents: ui.IDomEvents = acquire(__DomEvents);            addEventListener(element: Node, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener;            addEventListener(element: Window, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener;            addEventListener(element: Node, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;            addEventListener(element: Window, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;            addEventListener(element: any, type: string, listener: ui.IGestureListener, useCapture?: boolean) {                return this.$DomEvents.addEventListener(element, type, listener, useCapture);            }            appendChildren(nodeList: Array<Node>): DocumentFragment;            appendChildren(nodeList: NodeList): DocumentFragment;            appendChildren(nodeList: Array<Node>, root?: Node): Node;            appendChildren(nodeList: NodeList, root?: Node): Node;            appendChildren(nodeList: any, root?: Node): any {                return appendChildren(nodeList, root);            }            clearNode(node: Node) {                return clearNode(node);            }            clearNodeBlock(nodeList: Array<Node>, parent?: Node): void;            clearNodeBlock(nodeList: NodeList, parent?: Node): void;            clearNodeBlock(nodeList: any, parent?: Node) {                return clearNodeBlock(nodeList, parent);            }            setInnerHtml(node: Node, html: string): Node {                return setInnerHtml(node, html);            }            insertBefore(parent: Node, nodes: Array<Node>, endNode?: Node): Array<Node>;            insertBefore(parent: Node, nodes: NodeList, endNode?: Node): Array<Node>;            insertBefore(parent: Node, fragment: DocumentFragment, endNode?: Node): Array<Node>;            insertBefore(parent: Node, nodes: any, endNode?: Node) {                return insertBefore(parent, nodes, endNode);            }            replace(node: Node): Array<Node> {                return replace(node);            }            replaceWith(node: Node, newElement: HTMLElement): HTMLElement;            replaceWith(node: Node, newElement: Element): Element;            replaceWith(node: Node, newNode: Node): Node;            replaceWith(node: any, newNode: any): any {                return replaceWith(node, newNode);            }            serializeHtml(html: string): DocumentFragment {                return serializeHtml(html);            }            removeBetween(startNode: Node, endNode?: Node): void {                return removeBetween(startNode, endNode);            }            removeAll(startNode: Node, endNode?: Node): void {                return removeAll(startNode, endNode);            }            addClass(element: Element, className: string): void {                return addClass(<HTMLElement>element, className);            }            removeClass(element: Element, className: string): void {                return removeClass(<HTMLElement>element, className);            }            toggleClass(element: Element, className: string): void {                return toggleClass(<HTMLElement>element, className);            }            hasClass(element: Element, className: string): boolean {                return hasClass(<HTMLElement>element, className);            }        }        /**         * The Type for referencing the '$Dom' injectable as a dependency.         */        export function IDom(): IDom {            return new Dom();        }        register.injectable(__Dom, IDom);        /**         * An object that deals with the creation, deletion, and modification          * of DOM.         */        export interface IDom {            /**             * Adds an event listener of the specified type to the specified element.             *              * @param element The element to add the event listener to.             * @param type The type of event to listen to.             * @param listener The listener to fire when the event occurs.             * @param useCapture Whether to fire the event on the capture or the bubble phase              * of event propagation.             */            addEventListener(element: Node, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener;            /**             * Adds an event listener of the specified type to the specified element.             *              * @param element The window object.             * @param type The type of event to listen to.             * @param listener The listener to fire when the event occurs.             * @param useCapture Whether to fire the event on the capture or the bubble phase              * of event propagation.             */            addEventListener(element: Window, type: string, listener: ui.IGestureListener, useCapture?: boolean): IRemoveListener;            /**             * Adds an event listener of the specified type to the specified element.             *              * @param element The element to add the event listener to.             * @param type The type of event to listen to.             * @param listener The listener to fire when the event occurs.             * @param useCapture Whether to fire the event on the capture or the bubble phase              * of event propagation.             */            addEventListener(element: Node, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;            /**             * Adds an event listener of the specified type to the specified element.             *              * @param element The window object.             * @param type The type of event to listen to.             * @param listener The listener to fire when the event occurs.             * @param useCapture Whether to fire the event on the capture or the bubble phase              * of event propagation.             */            addEventListener(element: Window, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;            /**             * Takes a Node Array and either adds it to the passed in Node,             * or creates a DocumentFragment and adds the NodeList to the             * Fragment.             *              * @param nodeList A Node Array to be appended to the root/DocumentFragment             *              * @returns {Node} The root Node or a DocumentFragment.             */            appendChildren(nodeList: Array<Node>): DocumentFragment;            /**             * Takes a Node Array and either adds it to the passed in Node,             * or creates a DocumentFragment and adds the NodeList to the             * Fragment.             *              * @param nodeList A Node Array to be appended to the root/DocumentFragment             * @param root An optional Node to append the nodeList.             *              * @returns {Node} The root Node or a DocumentFragment.             */            appendChildren(nodeList: NodeList): DocumentFragment;            /**             * Takes a Node Array and either adds it to the passed in Node,             * or creates a DocumentFragment and adds the NodeList to the             * Fragment.             *              * @param nodeList A Node Array to be appended to the root/DocumentFragment             * @param root An optional Node to append the nodeList.             *              * @returns {Node} The root Node or a DocumentFragment.             */            appendChildren(nodeList: Array<Node>, root?: Node): Node;            /**             * Takes a NodeList and either adds it to the passed in Node,             * or creates a DocumentFragment and adds the NodeList to the             * Fragment.             *              * @param nodeList A NodeList to be appended to the root/DocumentFragment             * @param root An optional Node to append the nodeList.             *              * @returns {Node} The root Node or a DocumentFragment.             */            appendChildren(nodeList: NodeList, root?: Node): Node;            /**             * Clears a DOM Node by removing all of its childNodes.             *              * @param node The DOM Node to clear.             */            clearNode(node: Node): void;            /**             * Removes all the Nodes in the Array from the parent Node.             *              * @param nodeList The Node Array to remove from the parent Node.             * @param parent The parent Node used to remove the nodeList.             */            clearNodeBlock(nodeList: Array<Node>, parent?: Node): void;            /**             * Removes all the Nodes in the NodeList from the parent Node.             *              * @param nodeList The NodeList to remove from the parent Node.             * @param parent The parent Node used to remove the nodeList.             */            clearNodeBlock(nodeList: NodeList, parent?: Node): void;            /**             * Sets the innerHTML of a Node. Can take in a Node rather than an Element             * because it does not use innerHTML on the passed-in Node (it appends its             * childNodes).             *              * @param node The Node to set innerHTML.             * @param html HTML string to be put inside the node.             *              * @returns {Node} The same node passed in, with innerHTML set.             */            setInnerHtml(node: Node, html: string): Node;            /**             * Inserts a list of Nodes before the designated end Node.             *              * @param parent The parent node into which to insert nodes.             * @param nodes The Node Array to insert into the parent.             * @param endNode An optional endNode to use to insert nodes.             *              * @returns {Array<Node>} An Array copy of nodes.             */            insertBefore(parent: Node, nodes: Array<Node>, endNode?: Node): Array<Node>;            /**             * Inserts a list of Nodes before the designated end Node.             *              * @param parent The parent node into which to insert nodes.             * @param nodes The NodeList to insert into the parent.             * @param endNode An optional endNode to use to insert nodes.             *              * @returns {Array<Node>} An Array copy of nodes.             */            insertBefore(parent: Node, nodes: NodeList, endNode?: Node): Array<Node>;            /**             * Inserts a list of Nodes before the designated end Node.             *              * @param parent The parent node into which to insert nodes.             * @param fragment The DocumentFragment to insert into the parent.             * @param endNode An optional endNode to use to insert the fragment.             *              * @returns {Array<Node>} An Array copy of the fragment's childNodes.             */            insertBefore(parent: Node, fragment: DocumentFragment, endNode?: Node): Array<Node>;            /**             * Takes the child nodes of the given node and places them above the node             * in the DOM. Then removes the given node.             *              * @param node The Node to replace.             *              * @returns {Array<Node>} A Node Array that represents the childNodes of the             * given node.             */            replace(node: Node): Array<Node>;            /**             * Takes the childNodes of the given element and appends them to the newElement.             * Then replaces the element in its parent's tree with the newElement.             *              * @param node The Node to remove from its parent.             * @param newElement The HTMLElement populate with childNodes and add to the             * element's parent.             *              * @returns {HTMLElement} The replaced element (newElement).             */            replaceWith(node: Node, newElement: HTMLElement): HTMLElement;            /**             * Takes the childNodes of the given element and appends them to the newElement.             * Then replaces the element in its parent's tree with the newElement.             *              * @param node The Node to remove from its parent.             * @param newElement The Element populate with childNodes and add to the             * element's parent.             *              * @returns {Element} The replaced element (newElement).             */            replaceWith(node: Node, newElement: Element): Element;            /**             * Takes the childNodes of the given Node and appends them to the newNode.             * Then replaces the Node in its parent's tree with the newNode.             *              * @param node The Node to remove from its parent.             * @param newElement The Node populate with childNodes and add to the             * node's parent.             *              * @returns {Node} The replaced Node (newNode).             */            replaceWith(node: Node, newNode: Node): Node;            /**             * Takes in a string representing innerHTML and returns a DocumentFragment             * containing the serialized DOM.             *              * @param html The DOM string.             *              * @returns {DocumentFragment} The serialized DOM.             */            serializeHtml(html?: string): DocumentFragment;            /**             * Takes in a startNode and endNode, each having the same parentNode.             * Removes every node in between the startNode.  If endNode is not specified,             * DOM will be removed until the end of the parentNode's children.             *              * @param startNode The starting node, which will not be removed.             * @param endNode The ending node, which will not be removed.             */            removeBetween(startNode: Node, endNode?: Node): void;            /**             * Takes in a startNode and endNode, each having the same parentNode.             * Removes every node in between the startNode and endNode as well as             * the startNode and the endNode.  If endNode is not specified, DOM             * will be removed until the end of the parentNode's children.             *              * @param startNode The first node to remove.             * @param endNode The last node to remove.             */            removeAll(startNode: Node, endNode?: Node): void;            /**             * Adds a class to the specified element.             *              * @param element The element to which the class name is being added.             * @param className The class name to add to the element.             */            addClass(element: Element, className: string): void;            /**             * Removes a class from the specified element.             *              * @param element The element from which the class name is being removed.             * @param className The class name to remove from the element.             */            removeClass(element: Element, className: string): void;            /**             * Toggles a class from the specified element.             *              * @param element The element on which the class name is being toggled.             * @param className The class name to toggle on the element.             */            toggleClass(element: Element, className: string): void;            /**             * Returns whether or not an element has a particular class assigned to it.             *              * @param element The element on which the class name is being checked.             * @param className The class name to check on the element.             */            hasClass(element: Element, className: string): void;        }        /**         * An object describing custom element properties added to elements for hashing purposes.         */        export interface ICustomElementProperty extends IObject<string> {            /**             * A unique id given to the element if it's registered for a custom DOM event.             */            domEvent?: string;            /**             * A unique id given to the element if it's registered for an animation.             */            animation?: string;        }        /**         * An interface for describing an Element with an ICustomElementProperty attached.         */        export interface ICustomElement extends HTMLElement {            /**             * The PlatypusTS custom element.             */            __plat: ICustomElementProperty;        }        /**         * The class which provides a way for ITemplateControls to bind a template          * to a context. Useful for narrowing context without needing another          * ITemplateControl. In addition, this object provides a performance increase because          * it will only compile the template once. This object is also useful when a          * ITemplateControl expects multiple configuration templates in its innerHTML. It can          * separate those templates and reuse them accordingly.         */        export class BindableTemplates implements IBindableTemplates {            /**             * Creates a new instance of BindableTemplates and returns it. If a BindableTemplates is              * passed in, it will use the properties on the original BindableTemplates.             *              * @static             * @param control The ITemplateControl containing the new BindableTemplate object, used for data context              * inheritance for templates.             * @param originalBindableTemplates An optional IBindableTemplates object to copy.             * @returns {BindableTemplates} The newly instantiated BindableTemplates object.             */            static create(control: ITemplateControl, original?: IBindableTemplates): IBindableTemplates;            static create(control: ITemplateControl, original?: BindableTemplates): IBindableTemplates {                var bindableTemplates = new BindableTemplates();                bindableTemplates.control = control;                if (!isNull(original)) {                    bindableTemplates.templates = original.templates;                    bindableTemplates._cache = original._cache;                }                return bindableTemplates;            }            /**             * Clears the memory being held by control's bindableTemplates.             *              * @static             * @param control The control whose bindableTemplates will be disposed.             */            static dispose(control: ITemplateControl): void {                if (isNull(control)) {                    return;                }                var instance = control.bindableTemplates;                if (isNull(instance) || !isFunction(instance.dispose)) {                    return;                }                instance.dispose();            }            $ResourcesFactory: IResourcesFactory = acquire(__ResourcesFactory);            $TemplateControlFactory: ITemplateControlFactory = acquire(__TemplateControlFactory);            $Promise: async.IPromise = acquire(__Promise);            $ManagerCache: storage.ICache<processing.IElementManager> = acquire(__ManagerCache);            $Document: Document = acquire(__Document);            $ElementManagerFactory: processing.IElementManagerFactory = acquire(__ElementManagerFactory);            control: ITemplateControl;            templates: IObject<async.IThenable<DocumentFragment>> = {};            /**             * A keyed cache of IElementManagers that represent the roots of compiled templates              * created by this instance of BindableTemplates.             */            _cache: IObject<processing.IElementManager> = {};            private __compiledControls: Array<ITemplateControl> = [];            bind(key: string, relativeIdentifier?: string, resources?: IObject<IResource>): async.IThenable<DocumentFragment>;            bind(key: string, relativeIdentifier?: number, resources?: IObject<IResource>): async.IThenable<DocumentFragment>;            bind(key: any, relativeIdentifier?: any, resources?: IObject<IResource>): async.IThenable<DocumentFragment> {                var templatePromise = this.templates[key],                    $exception: IExceptionStatic;                if (isNull(templatePromise)) {                    $exception = acquire(__ExceptionStatic);                    $exception.fatal('Cannot bind template, no template stored with key: ' + key,                        $exception.TEMPLATE);                    return;                }                if (!(isNull(relativeIdentifier) || isNumber(relativeIdentifier) || isString(relativeIdentifier))) {                    $exception = acquire(__ExceptionStatic);                    $exception.warn('Cannot bind template with relativeIdentifier: ' +                        relativeIdentifier +                        '. Identifier must be either a string or number', $exception.BIND);                    return;                }                return templatePromise.then((result: DocumentFragment) => {                    return this._bindTemplate(key, <DocumentFragment>result.cloneNode(true), relativeIdentifier, resources);                }, (error: any) => {                    postpone(() => {                        $exception = acquire(__ExceptionStatic);                        $exception.fatal(error, $exception.BIND);                    });                    return <DocumentFragment>null;                });            }            add(key: string, template: Element): void;            add(key: string, template: Array<Node>): void;            add(key: string, template: NodeList): void;            add(key: string, template: DocumentFragment): void;            add(key: string, template: Node): void;            add(key: string, template: any) {                if (isNull(template)) {                    return;                }                if (isDocumentFragment(template)) {                    this._compile(key, template);                    return;                }                var fragment = this.$Document.createDocumentFragment();                if (isNode(template)) {                    fragment.appendChild(template);                } else if (isArrayLike(template)) {                    appendChildren(template, fragment);                } else {                    return;                }                this._compile(key, fragment);            }            dispose(): void {                var dispose = this.$TemplateControlFactory.dispose,                    compiledControls = this.__compiledControls,                    length = compiledControls.length;                for (var i = 0; i < length; ++i) {                    dispose(compiledControls[i]);                }                this.__compiledControls = [];                this.control = null;                this._cache = {};                this.templates = {};            }            /**             * Creates the template's bound control and INodeMap and initiates              * the binding of the INodeMap for a cloned template.             */            _bindTemplate(key: string, template: DocumentFragment, context: string,                resources: IObject<IResource>): async.IThenable<DocumentFragment> {                var control = this._createBoundControl(key, template, context, resources),                    nodeMap = this._createNodeMap(control, template, context),                    disposed = false,                    dispose = control.dispose;                control.dispose = () => {                    disposed = true;                    dispose.call(control);                    control.dispose = dispose;                };                return this._bindNodeMap(nodeMap, key).then(() => {                    var $document = this.$Document;                    if (disposed) {                        return $document.createDocumentFragment();                    }                    control.startNode = template.insertBefore($document.createComment(control.type + __START_NODE),                        template.firstChild);                    control.endNode = template.insertBefore($document.createComment(control.type + __END_NODE),                        null);                    return template;                }, (error: any) => {                    postpone(() => {                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);                        $exception.fatal(error, $exception.COMPILE);                    });                    return <DocumentFragment>null;                });            }            /**             * Clones the compiled IElementManager using the newly created              * INodeMap and binds and loads this control's IElementManager.             */            _bindNodeMap(nodeMap: processing.INodeMap, key: string): async.IThenable<void> {                var manager = this._cache[key],                    child = nodeMap.uiControlNode.control,                    template = nodeMap.element,                    $managerCache = this.$ManagerCache;                this.control.controls.push(child);                manager.clone(template, $managerCache.read(this.control.uid), nodeMap);                return $managerCache.read(child.uid).bindAndLoad();            }            /**             * Creates the template's compiled, bound control and INodeMap and initiates              * the compilation of the template.             */            _compile(key: string, template: DocumentFragment): void {                var control = this._createBoundControl(key + __COMPILED, template),                    nodeMap = this._createNodeMap(control, template);                this.__compiledControls.push(control);                this._compileNodeMap(control, nodeMap, key);            }            /**             * Instantiates a new IElementManager for the root of this template and resolves              * any asynchronous url templates within the template being compiled.             */            _compileNodeMap(control: ITemplateControl, nodeMap: processing.INodeMap, key: string) {                var manager = this.$ElementManagerFactory.getInstance(),                    promises: Array<async.IThenable<void>> = [];                manager.isClone = true;                manager.initialize(nodeMap, null);                manager.setUiControlTemplate();                this._cache[key] = manager;                promises.push(manager.fulfillTemplate());                this.templates[key] = this.$Promise.all(promises).then(() => {                    var element = nodeMap.element,                        startNode: Comment,                        endNode: Comment;                    var clone = <DocumentFragment>nodeMap.element.cloneNode(true);                    startNode = control.startNode = this.$Document.createComment(control.type + __START_NODE);                    endNode = control.endNode = this.$Document.createComment(control.type + __END_NODE);                    element.insertBefore(startNode, element.firstChild);                    element.insertBefore(endNode, null);                    return clone;                });            }            /**             * Creates an INodeMap for either a template being compiled or a template being bound.             */            _createNodeMap(uiControl: ITemplateControl, template: Node, childContext?: string): processing.INodeMap {                return {                    element: <HTMLElement>template,                    attributes: {},                    nodes: [],                    childContext: childContext,                    uiControlNode: {                        control: uiControl,                        nodeName: uiControl.type,                        expressions: [],                        injector: null                    }                };            }            /**             * Creates a bound control for either a template being compiled or a template being bound.             */            _createBoundControl(key: string, template: DocumentFragment,                relativeIdentifier?: string, resources?: IObject<IResource>): ITemplateControl {                var $TemplateControlFactory = this.$TemplateControlFactory,                    control = $TemplateControlFactory.getInstance(),                    $ResourcesFactory = this.$ResourcesFactory,                    parent = this.control;                var _resources = $ResourcesFactory.getInstance();                _resources.initialize(control, resources);                control.resources = _resources;                $ResourcesFactory.addControlResources(control);                control.parent = parent;                control.controls = [];                control.element = <HTMLElement>template;                control.type = parent.type + __BOUND_PREFIX + key;                return control;            }        }        /**         * The Type for referencing the '$BindableTemplatesFactory' injectable as a dependency.         */        export function IBindableTemplatesFactory(): IBindableTemplatesFactory {            return BindableTemplates;        }        register.injectable(__BindableTemplatesFactory, IBindableTemplatesFactory, null, __FACTORY);        /**         * The external interface for the '$BindableTemplatesFactory' injectable.         */        export interface IBindableTemplatesFactory {            /**             * Creates a new instance of BindableTemplates and returns it. If a BindableTemplates is             * passed in, it will use the properties on the original BindableTemplates.             *              * @static             * @param control The ITemplateControl containing the new BindableTemplate object, used for data context             * inheritance for templates.             * @param originalBindableTemplates An optional IBindableTemplates object to copy.             * @returns {BindableTemplates} The newly instantiated BindableTemplates object.             */            create(control: ITemplateControl, original?: IBindableTemplates): IBindableTemplates;            /**             * Clears the memory being held by control's bindableTemplates.             *              * @static             * @param control The control whose bindableTemplates will be disposed.             */            dispose(control: ITemplateControl): void;        }        /**         * Describes an object which provides a way for ITemplateControls to bind a template          * to a data context. Useful for narrowing data context without needing another          * ITemplateControl. In addition, this object provides a performance increase because          * it will only compile the template once. This object is also useful when a          * ITemplateControl expects multiple configuration templates in its innerHTML. It can          * separate those templates and reuse them accordingly.         */        export interface IBindableTemplates {            /**             * The control containing the IBindableTemplate object.             */            control: ITemplateControl;            /**             * Stores the compiled templates for this object, ready to be bound to a data context.              * All created templates are DocumentFragments, allowing a ITemplateControl to             * easily insert the template into the DOM (without iterating over childNodes). This object             * may contain a template promise.             */            templates: {};            /**             * Method for linking a new template to a data context and returning a clone of the template,              * with all new IControls created if the template contains controls. It is not necessary             * to specify a data context.             *              * @param key The key used to retrieve the template.             * @param relativeIdentifier The identifier string relative to this control's context             * (e.g. 'foo.bar.baz' would signify the object this.context.foo.bar.baz). This is the              * most efficient way of specifying context, else the framework has to search for the              * object.             * @param resources An object used as the resources for any top-level              * controls created in the template.             */            bind(key: string, relativeIdentifier?: string,                resources?: IObject<IResource>): async.IThenable<DocumentFragment>;            /**             * Method for linking a new template to a data context and returning a clone of the template,              * with all new IControls created if the template contains controls. It is not necessary             * to specify a data context.             *              * @param key The key used to retrieve the template.             * @param relativeIdentifier The identifier number relative to this control's context. Only              * necessary when context is an array.             * @param resources An object used as the resources for any top-level              * controls created in the template.             */            bind(key: string, relativeIdentifier?: number,                resources?: IObject<IResource>): async.IThenable<DocumentFragment>;            /**             * Adds a template to this object. The template will be stored with the key,             * and it will be transformed into a DocumentFragment.             *              * @param key The key used to store the template.             * @param template An Element represending the template DOM.             */            add(key: string, template: Element): void;            /**             * Adds a template to this object. The template will be stored with the key,             * and it will be transformed into a DocumentFragment.             *              * @param key The key used to store the template.             * @param template A Node array represending the template DOM.             */            add(key: string, template: Array<Node>): void;            /**             * Adds a template to this object. The template will be stored with the key,             * and it will be transformed into a DocumentFragment.             *              * @param key The key used to store the template.             * @param template A NodeList represending the template DOM.             */            add(key: string, template: NodeList): void;            /**             * Adds a template to this object. The template will be stored with the key.             *              * @param key The key used to store the template.             * @param template A DocumentFragment represending the template DOM.             */            add(key: string, template: DocumentFragment): void;            /**             * Adds a template to this object. The template will be stored with the key,             * and it will be transformed into a DocumentFragment.             *              * @param key The key used to store the template.             * @param template A Node represending the template DOM.             */            add(key: string, template: Node): void;            /**             * Clears the memory being held by this BindableTemplates instance.             */            dispose(): void;        }        /**         * The class that stores the information about an Element's attribute NamedNodeMap.         * Methods are implemented to allow you to observe for changes on an attribute.         *          * Attributes for this object are converted from dash-notation to camelCase notation.         */        export class Attributes implements IAttributesInstance {            private __listeners: IObject<Array<(newValue: any, oldValue?: any) => void>> = {};            private __control: IControl;            initialize(control: IControl, attributes: IObject<string>): void {                this.__control = control;                var keys = Object.keys(attributes),                    attributeListeners = this.__listeners,                    key: string,                    length = keys.length;                for (var i = 0; i < length; ++i) {                    key = keys[i];                    (<any>this)[key] = attributes[key];                    attributeListeners[key] = [];                }            }            observe(key: string, listener: (newValue: any, oldValue?: any) => void): IRemoveListener {                var listeners = this.__listeners[camelCase(key)];                if (isNull(listeners)) {                    return noop;                }                var length = listeners.length;                listeners.push(listener);                return () => {                    listeners.splice(length, 1);                };            }            /**             * Used to show an attribute has been changed and forces listeners to be fired.             *              * @param key The attribute being observed for changes (e.g. 'platOptions').             * @param newValue The new value of the attribute.             * @param oldValue The previous value of the attribute.             */            attributeChanged(key: string, newValue: any, oldValue: any): void {                var control = this.__control,                    listeners = this.__listeners[camelCase(key)],                    length = listeners.length;                for (var i = 0; i < length; ++i) {                    listeners[i].call(control, newValue, oldValue);                }            }        }        /**         * The Type for referencing the '$Attributes' injectable as a dependency.         */        export function IAttributesInstance(): IAttributesInstance {            return new Attributes();        }        register.injectable(__AttributesInstance, IAttributesInstance, null, __INSTANCE);        /**         * Describes an object that stores the information about an Element's attribute NamedNodeMap.         * Methods are implemented to allow you to observe for changes on an attribute.         *          * Attributes for this object are converted from dash-notation to camelCase notation.         */        export interface IAttributesInstance {            /**             * Stores the information about an Element's attribute NamedNodeMap, and allows a control to observe              * for changes on an attribute. The interface takes in a generic type, allowing ITemplateControls              * to specify an interface for their plat-options.             *              * Attributes for this object are converted from dash-notation to camelCase notation. 'plat-options' are              * parsed and stored as an object on this object, all other attributes are stored with their string values.             */            initialize(control: IControl, attributes: IObject<string>): void;            /**             * Provides a way to observe an attribute for changes.             *              * @param key The attribute to observe for changes.             * @param listener The listener function to be called when the attribute changes.             */            observe(key: string, listener: (newValue: any, oldValue: any) => void): IRemoveListener;            /**             * Used to show an attribute has been changed and forces listeners to be fired.             *              * @param key The attribute being observed for changes (e.g. 'platOptions').             * @param newValue The new value of the attribute.             * @param oldValue The previous value of the attribute.             */            attributeChanged(key: string, newValue: any, oldValue: any): void;        }        /**         * Resources are used for providing aliases to use in markup expressions. They          * are particularly useful when trying to access properties outside of the          * current context, as well as reassigning context at any point in an app.         *          * By default, every control has a resource for '@control' and '@context'.         * IViewControl objects also have a resource for '@root' and '@rootContext',          * which is a reference to the control and its context.         *          * Resources can be created in HTML, or through the exposed control.resources          * object. If specified in HTML, they must be the first element child of the          * control upon which the resources will be placed. IViewControls that use a          * templateUrl can have resources as their first element in the templateUrl.         *          * @example          * <custom-control>         *     <plat-resources>         *         <injectable alias="Cache">$CacheFactory</injectable>         *         <observable alias="testObj">         *              {          *                  foo: 'foo',          *                  bar: 'bar',          *                  baz: 2          *              }         *         </observable>         *     </plat-resources>         * </custom-control>         *          * In the above example, the resources can be accessed by using '@Cache' and '@testObj'.         * The type of resource is denoted by the element name.         *          * Only resources of type 'observable' will have data binding. The types of resources are:         * function, injectable, observable, and object. Resources of type 'function' will have their         * associated function context bound to the control that contains the resource.         *          * When an alias is found in a markup expression, the framework will search up the control chain          * to find the alias on a control's resources. This first matching alias will be used.         */        export class Resources implements IResources {            static $ContextManagerStatic: observable.IContextManagerStatic;            static $Regex: expressions.IRegex;            /**             * Populates an IResource value if necessary, and adds it to the given              * control's resources.             *              * @static             * @param control The control for which to create a resource.             * @param resource The IResource used to set the value.             */            static create(control: ITemplateControl, resource: IResource): IResource {                if (isNull(resource)) {                    return resource;                }                var value: any;                switch (resource.type.toLowerCase()) {                    case 'injectable':                        var injector = injectableInjectors[resource.value];                        if (!isNull(injector)) {                            resource.value = injector.inject();                        }                        break;                    case 'observable':                        Resources._observeResource(control, resource);                        break;                    case 'object':                        value = resource.value;                        if (isString(value)) {                            resource.value = control.evaluateExpression(value);                        }                        break;                    case 'function':                        value = resource.value;                        if (isString(value)) {                            value = (<any>control)[value];                            if (isFunction(value)) {                                resource.value = value.bind(control);                            } else {                                var $exception: IExceptionStatic = acquire(__ExceptionStatic);                                $exception.warn('Attempted to create a "function" ' +                                    'type Resource with a function not found on your control.',                                    $exception.BIND);                                resource.value = noop;                            }                        }                        break;                }                return resource;            }            /**             * Adds resource aliases for '@control' and '@context'. The resources are              * aliases for the control instance and the control.context.             *              * @static             * @param control The control on which to add the resources.             */            static addControlResources(control: ITemplateControl): void {                control.resources.add({                    context: {                        value: control.context,                        type: 'observable'                    },                    control: {                        value: control,                        type: 'object'                    }                });                if (control.hasOwnContext) {                    Resources.__addRoot(<IViewControl>control);                }            }            /**             * Binds the resources in a resource instance. This involves injecting              * the injectable resources, creating object/observable resources, and             * binding functions to the associated control's instance.             *              * @static             * @param resourcesInstance The instance of the IResources object.             */            static bindResources(resourcesInstance: IResources): void;            static bindResources(resourcesInstance: Resources) {                var resources = resourcesInstance.__resources,                    control = resourcesInstance.__controlInstance,                    aliases = Object.keys(resources),                    controlResources = Resources.__controlResources,                    length = aliases.length,                    alias: string;                for (var i = 0; i < length; ++i) {                    alias = aliases[i];                    if (controlResources.indexOf(alias) !== -1) {                        continue;                    }                    (<any>resourcesInstance)[alias] = resources[alias] = Resources.create(control,                        (<any>resourcesInstance)[alias]);                }                resourcesInstance.__bound = true;            }            /**             * Disposes a resource instance, removing its reference              * from a control and breaking references to all resource              * objects.             *              * @static             * @param control The control whose resources will be disposed.             * @param persist Whether or not to persist a resource object post              * disposal or set it to null.             */            static dispose(control: ITemplateControl, persist?: boolean): void {                var resources = <Resources>control.resources;                if (isNull(resources)) {                    return;                }                var keys = Object.keys(resources.__resources),                    key: string,                    length = keys.length,                    define = Resources.$ContextManagerStatic.defineProperty,                    resource: IResource;                for (var i = 0; i < length; ++i) {                    key = keys[i];                    resource = (<any>resources)[key];                    if (!isNull(resource) && resource.type === 'observable') {                        define(resources, key, persist ? _clone(resource, true) : null, true, true);                    }                }                Resources._removeListeners(resources.__controlInstance);            }            /**             * Parses a resources Element and creates              * an IObject<IResource> with its element children.             *              * @static             * @param element The resources element to parse.             *              * @returns {IObject<IResource>} The resources created              * using element.             */            static parseElement(element: Element): IObject<IResource> {                var children: Array<Element> = Array.prototype.slice.call((<HTMLElement>element).children),                    child: Element,                    $regex = Resources.$Regex,                    whiteSpaceRegex = $regex.whiteSpaceRegex,                    quotationRegex = $regex.quotationRegex,                    resources: IObject<IResource> = {},                    resource: IResource,                    types = Resources.__resourceTypes,                    attrs: NamedNodeMap,                    attr: Attr,                    nodeName: string,                    text: string;                while (children.length > 0) {                    child = children.pop();                    nodeName = child.nodeName.toLowerCase();                    if (types.indexOf(nodeName) === -1) {                        continue;                    }                    attrs = child.attributes;                    resource = <IResource>{};                    attr = attrs.getNamedItem('alias');                    if (isNull(attr)) {                        continue;                    }                    resource.alias = attr.value;                    text = child.textContent.replace(whiteSpaceRegex, '$1');                    if (isEmpty(text)) {                        continue;                    }                    resource.value = (nodeName === 'injectable') ?                        text.replace(quotationRegex, '') : text;                    resource.type = nodeName;                    resources[resource.alias] = resource;                }                return resources;            }            /**             * Returns a new instance of IResources.             *              * @static             */            static getInstance(): IResources {                return new Resources();            }            /**             * Observes the resource if the type is 'observable'.             *              * @static             * @param control The control in charge of the observable resource.             * @param resource The resource to observe.             */            static _observeResource(control: ITemplateControl, resource: IResource): void {                var value = resource.value,                    uid = control.uid,                    removeListeners = Resources.__observableResourceRemoveListeners[uid];                if (isNull(removeListeners)) {                    removeListeners = Resources.__observableResourceRemoveListeners[uid] = [];                }                if (isString(value)) {                    if (!isNull(resource.initialValue)) {                        value = resource.initialValue;                    } else {                        resource.initialValue = value;                    }                    var listener = control.observeExpression(value, (newValue) => {                        resource.value = newValue;                    });                    resource.value = control.evaluateExpression(value);                    removeListeners.push(listener);                }            }            /**             * Removes observable resource listeners for a specified control.             *              * @static             * @param control The control whose listeners are being removed.             */            static _removeListeners(control: ITemplateControl): void {                if (isNull(control)) {                    return;                }                var uid = control.uid,                    removeListeners = Resources.__observableResourceRemoveListeners[uid];                if (isArray(removeListeners)) {                    var length = removeListeners.length;                    for (var i = 0; i < length; ++i) {                        removeListeners[i]();                    }                }                deleteProperty(Resources.__observableResourceRemoveListeners, uid);            }            private static __controlResources = ['control', 'context', 'root', 'rootContext'];            private static __resourceTypes = ['injectable', 'object', 'observable', 'function'];            private static __observableResourceRemoveListeners: IObject<Array<IRemoveListener>> = {};            /**             * Adds a '@root' alias and '@rootContext' to a control, specifying that it contains the root              * and root context. Root controls are the root IViewControl.             *              * @param control The root IViewControl.             */            private static __addRoot(control: IViewControl): void {                control.resources.add({                    root: {                        value: control,                        type: 'object',                        alias: 'root'                    },                    rootContext: {                        value: control.context,                        type: 'observable',                        alias: 'rootContext'                    }                });            }            private __resources: IObject<IResource> = {};            private __bound: boolean = false;            private __controlInstance: ITemplateControl;            initialize(control: ITemplateControl, element?: Element): void;            initialize(control: ITemplateControl, resources?: IObject<IResource>): void;            initialize(control: ITemplateControl, resources?: IResources): void;            initialize(controlInstance: ITemplateControl, resources?: any) {                this.__controlInstance = controlInstance;                if (isNull(resources)) {                    return;                } else if (isNode(resources)) {                    resources = Resources.parseElement(resources);                } else if (isObject(resources.resources)) {                    resources = resources.resources;                }                this.__resources = resources;                var keys = Object.keys(resources),                    key: string,                    length = keys.length;                for (var i = 0; i < length; ++i) {                    key = keys[i];                    (<any>this)[key] = resources[key];                }            }            add(resources: IObject<IResource>): void;            add(element: Element): void;            add(resources: any) {                if (isNull(resources)) {                    return;                } else if (isNode(resources)) {                    resources = Resources.parseElement(resources);                }                var keys = Object.keys(resources),                    length = keys.length,                    resource: IResource,                    control = this.__controlInstance,                    bound = this.__bound,                    key: string,                    create = Resources.create;                for (var i = 0; i < length; ++i) {                    key = keys[i];                    resource = resources[key];                    resource.alias = key;                    (<any>this)[key] = this.__resources[key] = bound ? create(control, resource) : resource;                }            }        }        /**         * The Type for referencing the '$ResourcesFactory' injectable as a dependency.         */        export function IResourcesFactory(            $ContextManagerStatic?: observable.IContextManagerStatic,            $Regex?: expressions.IRegex): IResourcesFactory {                Resources.$ContextManagerStatic = $ContextManagerStatic;                Resources.$Regex = $Regex;                return Resources;        }        register.injectable(__ResourcesFactory, IResourcesFactory, [            __ContextManagerStatic,            __Regex        ], __FACTORY);        /**         * Creates and manages IResources for TemplateControls.         */        export interface IResourcesFactory {            /**             * Populates an IResource value if necessary, and adds it to the given             * control's resources.             *              * @static             * @param control The control for which to create a resource.             * @param resource The IResource used to set the value.             */            create(control: ITemplateControl, resource: IResource): IResource;            /**             * Adds resource aliases for '@control' and '@context'. The resources are             * aliases for the control instance and the control.context.             *              * @static             * @param control The control on which to add the resources.             */            addControlResources(control: ITemplateControl): void;            /**             * Binds the resources in a resource instance. This involves injecting             * the injectable resources, creating object/observable resources, and             * binding functions to the associated control's instance.             *              * @static             * @param resourcesInstance The instance of the IResources object.             */            bindResources(resourcesInstance: IResources): void;            /**             * Disposes a resource instance, removing its reference             * from a control and breaking references to all resource             * objects.             *              * @static             * @param control The control whose resources will be disposed.             * @param persist Whether or not to persist a resource object post              * disposal or set it to null.             */            dispose(control: ITemplateControl, persist?: boolean): void;            /**             * Parses a resources Element and creates             * an IObject<IResource> with its element children.             *              * @static             * @param element The resources element to parse.             *              * @returns {IObject<IResource>} The resources created             * using element.             */            parseElement(element: Element): IObject<IResource>;            /**             * Returns a new instance of IResources             *              * @static             */            getInstance(): IResources;        }        /**         * Resources are used for providing aliases to use in markup expressions. They          * are particularly useful when trying to access properties outside of the          * current context, as well as reassigning context at any point in an app.         *          * By default, every control has a resource for '@control' and '@context'.         * IViewControl objects also have a resource for '@root' and '@rootContext',          * which is a reference to the control and its context.         *          * Resources can be created in HTML, or through the exposed control.resources          * object. If specified in HTML, they must be the first element child of the          * control upon which the resources will be placed. IViewControls that use a          * templateUrl can have resources as their first element in the templateUrl.         *          * @example          * <custom-control>         *     <plat-resources>         *         <injectable alias="Cache">$CacheFactory</injectable>         *         <observable alias="testObj">         *              {          *                  foo: 'foo',          *                  bar: 'bar',          *                  baz: 2          *              }         *         </observable>         *     </plat-resources>         * </custom-control>         *          * In the above example, the resources can be accessed by using '@Cache' and '@testObj'.         * The type of resource is denoted by the element name.         *          * Only resources of type 'observable' will have data binding. The types of resources are:         * function, injectable, observable, and object. Resources of type 'function' will have their         * associated function context bound to the control that contains the resource.         *          * When an alias is found in a markup expression, the framework will search up the control chain          * to find the alias on a control's resources. This first matching alias will be used.         */        export interface IResources {            /**             * Used for programatically adding IResource objects.             *              * @param resources An IObject<IResource> used to add              * resources, keyed by their alias.             *              * @example control.resources.add({             *     myAlias: {             *         type: 'observable',             *         value: {              *             hello: 'Hello World!'             *         }              *     }             * });             */            add(resources: IObject<IResource>): void;            /**             * Used for programatically adding IResource objects.             *              * @param element An Element containing resource element children.             *              * @example             *     <plat-resources>             *         <injectable alias="Cache">$CacheFactory</injectable>             *         <observable alias="testObj">{ foo: 'foo', bar: 'bar', baz: 2 }</observable>             *     </plat-resources>             *              * The resource type is specified by the element name.             */            add(element: Element): void;            /**             * @param control The control containing this Resources instance.             * @param element An optional element used to create initial IResource objects.             */            initialize(control: ITemplateControl, element?: Element): void;            /**             * @param control The control containing this Resources instance.             * @param resources An optional IObject<IResource> used to populate initial             * IResource objects.             */            initialize(control: ITemplateControl, resources?: IObject<IResource>): void;            /**             * @param control The control containing this Resources instance.             * @param element An optional IResources object used to populate initial              * IResource objects.             */            initialize(control: ITemplateControl, resources?: IResources): void;        }        /**         * Defines a single resource on the IResources object.         */        export interface IResource {            /**             * The type of resource.             * - injectable             * - observable             * - object             * - function             */            type: string;            /**             * The alias used to reference the Resource.             */            alias?: string;            /**             * The value of the Resource             */            value?: any;            /**             * The initial value prior to it being observed.             */            initialValue?: any;        }        /**         * A class for managing DOM event registration and handling.         */        export class DomEvents implements IDomEvents {            /**             * A configuration object for all DOM events.             */            static config: IDomEventsConfig = {                /**                 * An object containing the different time intervals that govern the behavior of certain                  * custom DOM events.                 */                intervals: {                    /**                     * The max time in milliseconds a user can hold down on the screen                      * for a tap event to be fired.                     */                    tapInterval: 200,                    /**                     * The max time in milliseconds a user can wait between consecutive                      * taps for a dbltap event to be fired.                     */                    dblTapInterval: 300,                    /**                     * The time in milliseconds a user must hold down on the screen                      * before a hold event is fired or a release event can be fired.                     */                    holdInterval: 400,                    /**                     * The delay in milliseconds between the time a user taps to the time                      * the tap event fires. Used in the case where a double-tap-to-zoom                      * feature is required.                     */                    dblTapZoomDelay: 0                },                /**                 * An object containing the different minimum/maximum distances that govern the behavior of certain                  * custom DOM events.                 */                distances: {                    /**                     * The minimum distance a user must move after touch down to register                      * it as a scroll instead of a tap.                     */                    minScrollDistance: 5,                    /**                     * The maximum distance between consecutive taps a user is allowed to                      * register a dbltap event.                     */                    maxDblTapDistance: 20                },                /**                 * An object containing the different minimum/maximum velocities that govern the behavior of certain                  * custom DOM events.                 */                velocities: {                    /**                     * The minimum velocity a user must move after touch down to register                      * a swipe event.                     */                    minSwipeVelocity: 0.8                },                /**                 * The default CSS styles applied to elements listening for custom DOM events. If using                  * platypus.css, you must overwrite the styles in platypus.css or create your own and                  * change the classNames in the config.                 */                styleConfig: [{                    /**                     * The className that will be used to define the custom style for                      * allowing the best touch experience. This class is added to every                      * element that registers for a custom DOM event (denoted by a prefixed '$').                     */                    className: 'plat-gesture',                    /**                     * An array of string styles to be placed on an element to allow for the                      * best touch experience. In the format 'CSS identifier: value'                     * (i.e. 'width : 100px')                     */                    styles: [                        '-moz-user-select: none',                        '-khtml-user-select: none',                        '-webkit-touch-callout: none',                        '-webkit-user-select: none',                        '-webkit-user-drag: none',                        '-webkit-tap-highlight-color: transparent',                        '-webkit-overflow-scrolling: touch',                        '-ms-user-select: none',                        '-ms-touch-action: manipulation',                        'touch-action: manipulation'                    ]                }, {                    /**                     * The className that will be used to define the custom style for                      * blocking touch action scrolling, zooming, etc on the element.                     */                    className: 'plat-no-touch-action',                    /**                     * An array of string styles that block touch action scrolling, zooming, etc.                      * Primarily useful on elements such as a canvas.                     * In the format 'CSS identifier: value'                     * (i.e. 'width : 100px')                     */                    styles: [                        '-ms-touch-action: none',                        'touch-action: none'                    ]                }]            };            $Document: Document = acquire(__Document);            $Compat: ICompat = acquire(__Compat);            /**             * Whether or not the DomEvents are currently active.              * They become active at least one element on the current              * page is listening for a custom event.             */            _isActive: boolean;            /**             * Whether or not the user is currently touching the screen.             */            _inTouch: boolean;            /**             * An array of subscriptions that keep track of all of the              * events registered on a particular element.             */            _subscribers: IObject<IEventSubscriber> = {};            /**             * The touch start events defined by this browser.             */            _startEvents: Array<string>;            /**             * The touch move events defined by this browser.             */            _moveEvents: Array<string>;            /**             * The touch end events defined by this browser.             */            _endEvents: Array<string>;            /**             * An object containing the event types for all of the              * supported gestures.             */            _gestures: IGestures<string> = {                $tap: __$tap,                $dbltap: __$dbltap,                $hold: __$hold,                $release: __$release,                $swipe: __$swipe,                $swipeleft: __$swipeleft,                $swiperight: __$swiperight,                $swipeup: __$swipeup,                $swipedown: __$swipedown,                $track: __$track,                $trackleft: __$trackleft,                $trackright: __$trackright,                $trackup: __$trackup,                $trackdown: __$trackdown,                $trackend: __$trackend            };            /**             * An object containing the number of currently active              * events of each type.             */            _gestureCount: IGestures<number> = {                $tap: 0,                $dbltap: 0,                $hold: 0,                $release: 0,                $swipe: 0,                $track: 0,                $trackend: 0            };            private __START = 'start';            private __MOVE = 'move';            private __END = 'end';            private __hasMoved = false;            private __hasSwiped = false;            private __hasRelease = false;            private __detectingMove = false;            private __tapCount = 0;            private __touchCount = 0;            private __tapTimeout: number;            private __holdTimeout: number;            private __cancelRegex = /cancel/i;            private __pointerEndRegex = /up|cancel/i;            private __lastTouchDown: IPointerEvent;            private __lastTouchUp: IPointerEvent;            private __swipeOrigin: IPointerEvent;            private __lastMoveEvent: IPointerEvent;            private __capturedTarget: ICustomElement;            private __focusedElement: HTMLInputElement;            private __mappedEventListener = this.__handleMappedEvent.bind(this);            private __reverseMap = {};            private __swipeSubscribers: { master: IDomEventInstance; directional: IDomEventInstance };            private __pointerHash: IObject<IPointerEvent> = {};            private __pointerEvents: Array<IPointerEvent> = [];            private __listeners: ICustomEventListener = {                start: this._onTouchStart.bind(this),                move: this._onMove.bind(this),                end: this._onTouchEnd.bind(this)            };            /**             * Retrieve the type of touch events for this browser and create the default gesture style.             */            constructor() {                this.__getTypes();            }            addEventListener(element: Node, type: string, listener: IGestureListener, useCapture?: boolean): IRemoveListener;            addEventListener(element: Window, type: string, listener: IGestureListener, useCapture?: boolean): IRemoveListener;            addEventListener(element: Node, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;            addEventListener(element: Window, type: string, listener: EventListener, useCapture?: boolean): IRemoveListener;            addEventListener(element: any, type: string, listener: IGestureListener, useCapture?: boolean): IRemoveListener {                var $compat = this.$Compat,                    mappedGestures = $compat.mappedEvents,                    mappedType = mappedGestures[type],                    mappingExists = !isNull(mappedType),                    mappedRemoveListener = noop,                    mappedTouchRemoveListener = noop,                    gestures = this._gestures;                if (mappingExists) {                    (<any>this.__reverseMap)[mappedType] = type;                    this.__registerElement(element, type);                    mappedRemoveListener = this.__addMappedEvent(mappedType, useCapture);                    if ($compat.hasTouchEvents) {                        mappedType = mappedType                            .replace('touch', 'mouse')                            .replace('start', 'down')                            .replace('end', 'up');                        (<any>this.__reverseMap)[mappedType] = type;                        mappedTouchRemoveListener = this.__addMappedEvent(mappedType, useCapture);                    }                }                element.addEventListener(type, listener, useCapture);                if (!isUndefined(element['on' + type]) || isUndefined((<any>gestures)[type]) || mappingExists) {                    return () => {                        mappedRemoveListener();                        mappedTouchRemoveListener();                        element.removeEventListener(type, listener, useCapture);                    };                }                var swipeGesture = gestures.$swipe,                    trackGesture = gestures.$track,                    countType = type;                if (type.indexOf(trackGesture) !== -1) {                    var trackend = gestures.$trackend;                    countType = type === trackend ? trackend : trackGesture;                } else if (type.indexOf(swipeGesture) !== -1) {                    countType = swipeGesture;                }                (<any>this._gestureCount)[countType]++;                this.__registerElement(element, type);                return () => {                    this.__removeEventListener(element, type, listener, useCapture);                };            }            dispose(): void {                this.__unregisterTypes();                this._gestureCount = {                    $tap: 0,                    $dbltap: 0,                    $hold: 0,                    $release: 0,                    $swipe: 0,                    $track: 0,                    $trackend: 0                };                this._isActive = false;                this._subscribers = {};                this.__pointerEvents = [];                this.__pointerHash = {};                this.__reverseMap = {};                this.__tapCount = 0;                this.__touchCount = 0;                this.__detectingMove = false;                this.__hasMoved = false;                this.__hasRelease = false;                this.__hasSwiped = false;                this.__swipeOrigin = null;                this.__lastMoveEvent = null;                this.__lastTouchDown = null;                this.__lastTouchUp = null;                this.__capturedTarget = null;                this.__focusedElement = null;            }            /**             * A listener for touch/mouse start events.             *              * @param ev The touch start event object.             */            _onTouchStart(ev: IPointerEvent): boolean {                var isTouch = ev.type !== 'mousedown';                if (isTouch) {                    this._inTouch = true;                } else if (this._inTouch === true) {                    // return immediately if mouse event and currently in a touch                    ev.preventDefault();                    return false;                }                // set any captured target back to null                this.__capturedTarget = null;                this.__standardizeEventObject(ev);                this.__lastTouchDown = this.__swipeOrigin = ev;                this.__lastMoveEvent = null;                this.__hasMoved = false;                if ((this.__touchCount = ev.touches.length) > 1) {                    ev.preventDefault();                    return false;                }                this.__registerType(this.__MOVE);                this.__detectingMove = true;                var gestureCount = this._gestureCount,                    noHolds = gestureCount.$hold <= 0,                    noRelease = gestureCount.$release <= 0;                // return if no hold or release events are registered                if (noHolds && noRelease) {                    return true;                }                var holdInterval = DomEvents.config.intervals.holdInterval,                    domEvent: IDomEventInstance,                    subscribeFn: () => void;                if (noHolds) {                    this.__hasRelease = false;                    this.__holdTimeout = setTimeout(() => {                        this.__hasRelease = true;                    }, holdInterval);                    return;                } else if (noRelease) {                    domEvent = this.__findFirstSubscriber(<ICustomElement>ev.target, this._gestures.$hold);                    subscribeFn = () => {                        domEvent.trigger(ev);                        this.__holdTimeout = null;                    };                } else {                    this.__hasRelease = false;                    // has both hold and release events registered                    domEvent = this.__findFirstSubscriber(<ICustomElement>ev.target, this._gestures.$hold);                    subscribeFn = () => {                        domEvent.trigger(ev);                        this.__hasRelease = true;                        this.__holdTimeout = null;                    };                }                // set timeout to fire the subscribeFn                if (!isNull(domEvent)) {                    this.__holdTimeout = setTimeout(subscribeFn, holdInterval);                }                return true;            }            /**             * A listener for touch/mouse move events.             *              * @param ev The touch start event object.             */            _onMove(ev: IPointerEvent): boolean {                // clear hold event                this.__clearHold();                // return immediately if there are multiple touches present, or                 // if it is a mouse event and currently in a touch                if (this.__touchCount > 1 || (this._inTouch === true && ev.type === 'mousemove')) {                    ev.preventDefault();                    return false;                }                this.__standardizeEventObject(ev);                var gestureCount = this._gestureCount,                    noTracking = gestureCount.$track <= 0,                    config = DomEvents.config,                    swipeOrigin = this.__swipeOrigin,                    x = ev.clientX,                    y = ev.clientY,                    lastX = swipeOrigin.clientX,                    lastY = swipeOrigin.clientY,                    minMove = this.__getDistance(lastX, x, lastY, y) >= config.distances.minScrollDistance;                // if minimum distance moved                if (minMove) {                    this.__hasMoved = true;                }                // if no move events or no tracking events and the user hasn't moved the minimum swipe distance                if ((gestureCount.$swipe <= 0 && noTracking) || (noTracking && !minMove)) {                    return true;                }                var lastMove = this.__lastMoveEvent,                    direction = ev.direction = isNull(lastMove) ? this.__getDirection(x - lastX, y - lastY) :                        this.__getDirection(x - lastMove.clientX, y - lastMove.clientY);                if (this.__checkForOriginChanged(direction)) {                    ev.preventDefault();                }                var velocity = ev.velocity = this.__getVelocity(x - swipeOrigin.clientX, y - swipeOrigin.clientY,                    ev.timeStamp - swipeOrigin.timeStamp);                this.__hasSwiped = (this.__isHorizontal(direction) ? velocity.x : velocity.y) >= config.velocities.minSwipeVelocity;                // if tracking events exist                if (!noTracking) {                    this.__handleTrack(ev);                }                this.__lastMoveEvent = ev;                return true;            }            /**             * A listener for touch/mouse end events.             *              * @param ev The touch start event object.             */            _onTouchEnd(ev: IPointerEvent): boolean {                var eventType = ev.type,                    hasMoved = this.__hasMoved,                    inTouch = this._inTouch;                // return immediately if there were multiple touches present                if (this.__touchCount > 1) {                    ev.preventDefault();                    if (eventType === 'touchend') {                        this.__preventClickFromTouch();                    }                    return false;                }                if (eventType !== 'mouseup') {                    if (eventType === 'touchend') {                        var target = <HTMLInputElement>ev.target;                        if (hasMoved) {                            ev.preventDefault();                            this.__preventClickFromTouch();                        } else if (this.__isFocused(target)) {                            this.__preventClickFromTouch();                        } else {                            ev.preventDefault();                            if (inTouch === true) {                                this.__handleInput(target);                            }                        }                        this._inTouch = false;                    }                } else if (!isUndefined(inTouch)) {                    ev.preventDefault();                    return false;                }                // clear hold event                this.__clearHold();                if (this.__detectingMove) {                    this.__unregisterType(this.__MOVE);                    this.__detectingMove = false;                }                this.__standardizeEventObject(ev);                // check for cancel event,                if (this.__cancelRegex.test(eventType)) {                    this.__tapCount = 0;                    this.__hasRelease = false;                    this.__hasSwiped = false;                    return true;                }                // return if the touch count was greater than 0 (should only happen with pointerevents),                 // or handle release                if (ev.touches.length > 0) {                    ev.preventDefault();                    return false;                } else if (this.__hasRelease) {                    this.__handleRelease(ev);                }                // handle swipe events                if (this.__hasSwiped) {                    this.__handleSwipe();                }                var config = DomEvents.config,                    intervals = config.intervals,                    touchEnd = ev.timeStamp,                    touchDown = this.__lastTouchDown;                // if the user moved their finger (for scroll) we handle $trackend and return,                // else if they had their finger down too long to be considered a tap, we want to return                if (hasMoved) {                    this.__handleTrackEnd(ev);                    this.__tapCount = 0;                    return false;                } else if (isNull(touchDown) || ((touchEnd - touchDown.timeStamp) > intervals.tapInterval)) {                    this.__tapCount = 0;                    return true;                }                var lastTouchUp = this.__lastTouchUp,                    x = ev.clientX,                    y = ev.clientY;                // check if can be a double tap event by checking number of taps, distance between taps,                 // and time between taps                if (this.__tapCount > 0 &&                    this.__getDistance(x, lastTouchUp.clientX, y, lastTouchUp.clientY) <= config.distances.maxDblTapDistance &&                    ((touchEnd - lastTouchUp.timeStamp) <= intervals.dblTapInterval)) {                    // handle dbltap events                    this.__handleDbltap(ev);                } else {                    this.__tapCount = 0;                }                // handle tap events                this.__handleTap(ev);                this.__lastTouchUp = ev;                return true;            }            // gesture handling methods            private __handleTap(ev: IPointerEvent): void {                this.__tapCount++;                if (this._gestureCount.$tap <= 0) {                    return;                }                var gestures = this._gestures,                    domEvent = this.__findFirstSubscriber(<ICustomElement>ev.target, gestures.$tap);                if (isNull(domEvent)) {                    return;                }                // fire tap event immediately if no dbltap zoom                // or a mouse is being used                if (DomEvents.config.intervals.dblTapZoomDelay <= 0 ||                    ev.pointerType === 'mouse' || ev.type === 'mouseup') {                    domEvent.trigger(ev);                    return;                }                // setTimeout for tap delay in case of                 // dbltap zoom                this.__tapTimeout = setTimeout(() => {                    domEvent.trigger(ev);                    this.__tapCount = 0;                    this.__tapTimeout = null;                }, DomEvents.config.intervals.dblTapZoomDelay);            }            private __handleDbltap(ev: IPointerEvent): void {                this.__tapCount = 0;                if (!isNull(this.__tapTimeout)) {                    clearTimeout(this.__tapTimeout);                    this.__tapTimeout = null;                }                if (this._gestureCount.$dbltap <= 0) {                    return;                }                var domEvent = this.__findFirstSubscriber(<ICustomElement>ev.target, this._gestures.$dbltap);                if (isNull(domEvent)) {                    return;                }                domEvent.trigger(ev);                // set touch count to -1 to prevent repeated fire on sequential taps                this.__tapCount = -1;            }            private __handleRelease(ev: IPointerEvent): void {                var domEvent = this.__findFirstSubscriber(<ICustomElement>ev.target, this._gestures.$release);                if (!isNull(domEvent)) {                    domEvent.trigger(ev);                }                this.__hasRelease = false;            }            private __handleSwipe(): void {                var lastMove = this.__lastMoveEvent;                if (isNull(lastMove)) {                    this.__hasSwiped = false;                    return;                }                var swipeSubscribers = this.__swipeSubscribers,                    swipeDomEvent = swipeSubscribers.master,                    swipeDirectionDomEvent = swipeSubscribers.directional;                if (!isNull(swipeDomEvent)) {                    swipeDomEvent.trigger(lastMove);                }                if (!isNull(swipeDirectionDomEvent)) {                    swipeDirectionDomEvent.trigger(lastMove);                }                this.__hasSwiped = false;                this.__lastMoveEvent = null;                this.__swipeSubscribers = null;            }            private __handleTrack(ev: IPointerEvent): void {                var trackGesture = this._gestures.$track,                    direction = ev.direction,                    trackDirectionGesture = trackGesture + direction,                    eventTarget = this.__capturedTarget || <ICustomElement>ev.target,                    trackDomEvent = this.__findFirstSubscriber(eventTarget, trackGesture),                    trackDirectionDomEvent = this.__findFirstSubscriber(eventTarget, trackDirectionGesture);                if (!isNull(trackDomEvent)) {                    ev.preventDefault();                    trackDomEvent.trigger(ev);                }                if (!isNull(trackDirectionDomEvent)) {                    ev.preventDefault();                    trackDirectionDomEvent.trigger(ev);                }            }            private __handleTrackEnd(ev: IPointerEvent): void {                if (this._gestureCount.$trackend <= 0) {                    return;                }                var eventTarget = this.__capturedTarget || <ICustomElement>ev.target,                    domEvent = this.__findFirstSubscriber(eventTarget, this._gestures.$trackend);                if (isNull(domEvent)) {                    return;                }                domEvent.trigger(ev);            }            private __handleMappedEvent(ev: IExtendedEvent): void {                var mappedType = ev.type,                    eventType = (<any>this.__reverseMap)[mappedType],                    domEvent = this.__findFirstSubscriber(<ICustomElement>ev.target, eventType);                if (isNull(domEvent)) {                    return;                }                this.__standardizeEventObject(ev);                domEvent.trigger(ev);            }            // touch type and element registration            private __getTypes(): void {                var $compat = this.$Compat,                    touchEvents = $compat.mappedEvents;                if ($compat.hasPointerEvents) {                    this._startEvents = [touchEvents.$touchstart];                    this._moveEvents = [touchEvents.$touchmove];                    this._endEvents = [touchEvents.$touchend, touchEvents.$touchcancel];                    return;                } else if ($compat.hasTouchEvents) {                    this._startEvents = [touchEvents.$touchstart, 'mousedown'];                    this._moveEvents = [touchEvents.$touchmove, 'mousemove'];                    this._endEvents = [touchEvents.$touchend, touchEvents.$touchcancel, 'mouseup'];                    return;                }                var cancelEvent = touchEvents.$touchcancel;                this._startEvents = [touchEvents.$touchstart];                this._moveEvents = [touchEvents.$touchmove];                this._endEvents = isNull(cancelEvent) ? [touchEvents.$touchend] : [touchEvents.$touchend, cancelEvent];            }            private __registerTypes(): void {                this.__registerType(this.__START);                this.__registerType(this.__END);            }            private __unregisterTypes(): void {                this.__unregisterType(this.__START);                this.__unregisterType(this.__MOVE);                this.__unregisterType(this.__END);            }            private __registerType(event: string): void {                var events: Array<string>,                    listener = this.__listeners[event],                    $document = this.$Document;                switch (event) {                    case this.__START:                        events = this._startEvents;                        break;                    case this.__MOVE:                        events = this._moveEvents;                        break;                    case this.__END:                        events = this._endEvents;                        break;                    default:                        return;                }                var index = events.length;                while (index-- > 0) {                    $document.addEventListener(events[index], listener, false);                }            }            private __unregisterType(event: string): void {                var events: Array<string>,                    listener = this.__listeners[event],                    $document = this.$Document;                switch (event) {                    case this.__START:                        events = this._startEvents;                        break;                    case this.__MOVE:                        events = this._moveEvents;                        break;                    case this.__END:                        events = this._endEvents;                        break;                    default:                        return;                }                var index = events.length;                while (index-- > 0) {                    $document.removeEventListener(events[index], listener, false);                }            }            private __registerElement(element: ICustomElement, type: string): void {                var id: string,                    plat = element.__plat;                if (isNull(plat)) {                    id = uniqueId('domEvent_');                    element.__plat = plat = {                        domEvent: id                    };                } else if (isNull(plat.domEvent)) {                    id = uniqueId('domEvent_');                    plat.domEvent = id;                }                // check if DomEvents is ready                if (!this._isActive) {                    this.__registerTypes();                    if (isNull(this._isActive)) {                        this.__appendGestureStyle();                    }                    this._isActive = true;                }                var $domEvent: IDomEventInstance;                if (isNull(id)) {                    var subscriber = this._subscribers[plat.domEvent];                    if (isUndefined((<any>subscriber)[type])) {                        $domEvent = new CustomDomEvent(element, type);                        (<any>subscriber)[type] = $domEvent;                    } else {                        (<any>subscriber)[type].count++;                    }                    subscriber.gestureCount++;                } else {                    var newSubscriber = { gestureCount: 1 };                    $domEvent = new CustomDomEvent(element, type);                    (<any>newSubscriber)[type] = $domEvent;                    this._subscribers[id] = newSubscriber;                    if (!isUndefined((<HTMLElement>element).className)) {                        addClass(<HTMLElement>element, DomEvents.config.styleConfig[0].className);                    }                    this.__removeSelections(element);                }            }            private __unregisterElement(element: ICustomElement, type: string): void {                var plat = element.__plat;                if (isNull(plat) || isNull(plat.domEvent)) {                    return;                }                var domEventId = plat.domEvent,                    eventSubscriber = this._subscribers[domEventId],                    domEvent: ICustomDomEventInstance = (<any>eventSubscriber)[type];                if (isNull(domEvent)) {                    return;                }                domEvent.count--;                if (domEvent.count === 0) {                    deleteProperty(eventSubscriber, type);                }                eventSubscriber.gestureCount--;                if (eventSubscriber.gestureCount === 0) {                    deleteProperty(this._subscribers, domEventId);                    this.__removeElement(element);                }            }            private __setTouchPoint(ev: IPointerEvent): void {                var eventType = ev.type,                    $compat = this.$Compat;                if ($compat.hasPointerEvents) {                    if (eventType === 'pointerdown') {                        this.__setCapture(ev.target);                    }                    this.__updatePointers(ev, this.__pointerEndRegex.test(eventType));                } else if ($compat.hasMsPointerEvents) {                    if (eventType === 'MSPointerDown') {                        this.__setCapture(ev.target);                    }                    this.__updatePointers(ev, this.__pointerEndRegex.test(eventType));                } else if (eventType === 'mousedown') {                    ev.pointerType = 'mouse';                    this.__setCapture(ev.target);                } else {                    // do not need to set catpure for touchstart events                    ev.pointerType = eventType.indexOf('mouse') === -1 ? 'touch' : 'mouse';                }            }            private __setCapture(target: EventTarget) {                if (isNull(this.__capturedTarget) && !isDocument(target)) {                    this.__capturedTarget = <ICustomElement>target;                }            }            private __updatePointers(ev: IPointerEvent, remove: boolean): void {                var id = ev.pointerId,                    pointer = this.__pointerHash[id];                if (remove) {                    if (!isUndefined(pointer)) {                        this.__pointerEvents.splice(this.__pointerEvents.indexOf(pointer), 1);                        deleteProperty(this.__pointerHash, id);                    }                } else {                    ev.identifier = ev.pointerId;                    if (isUndefined(pointer)) {                        this.__pointerEvents.push(ev);                    } else {                        this.__pointerEvents.splice(this.__pointerEvents.indexOf(pointer), 1, ev);                    }                    this.__pointerHash[id] = ev;                }            }            // event and subscription handling            private __findFirstSubscriber(eventTarget: ICustomElement, type: string): IDomEventInstance {                var plat: ICustomElementProperty,                    subscriber: IEventSubscriber,                    domEvent: IDomEventInstance;                do {                    plat = eventTarget.__plat;                    if (isUndefined(plat) || isUndefined(plat.domEvent)) {                        continue;                    }                    subscriber = this._subscribers[plat.domEvent];                    domEvent = (<any>subscriber)[type];                    if (isUndefined(domEvent)) {                        continue;                    }                    return domEvent;                } while (!isNull(eventTarget = <ICustomElement>eventTarget.parentNode));            }            private __addMappedEvent(mappedEvent: string, useCapture?: boolean): IRemoveListener {                var $document = this.$Document;                $document.addEventListener(mappedEvent, this.__mappedEventListener, useCapture);                return () => {                    $document.removeEventListener(mappedEvent, this.__mappedEventListener, useCapture);                };            }            private __removeEventListener(element: ICustomElement, type: string, listener: IGestureListener,                useCapture?: boolean): void {                var gestures = this._gestures;                element.removeEventListener(type, listener, useCapture);                var swipeGesture = gestures.$swipe,                    trackGesture = gestures.$track,                    countType = type;                if (type.indexOf(trackGesture) !== -1) {                    countType = trackGesture;                } else if (type.indexOf(swipeGesture) !== -1) {                    countType = swipeGesture;                }                (<any>this._gestureCount)[countType]--;                this.__unregisterElement(element, type);            }            private __removeElement(element: ICustomElement): void {                this.__returnSelections(element);                if (!isUndefined(element.className)) {                    removeClass(element, DomEvents.config.styleConfig[0].className);                }                var plat = element.__plat;                deleteProperty(plat, 'domEvent');                if (isEmpty(plat)) {                    deleteProperty(element, '__plat');                }                // check if no elements are left listening                if (isEmpty(this._subscribers)) {                    this.dispose();                }            }            private __standardizeEventObject(ev: IExtendedEvent): void {                this.__setTouchPoint(ev);                ev.touches = ev.touches || this.__pointerEvents;                var evtObj = ev;                if (isUndefined(ev.clientX)) {                    if (ev.touches.length > 0) {                        evtObj = ev.touches[0];                    } else if (((<any>ev).changedTouches || []).length > 0) {                        evtObj = (<any>ev).changedTouches[0];                    }                    ev.clientX = evtObj.clientX;                    ev.clientY = evtObj.clientY;                }                if (isUndefined(ev.offsetX) || !isNull(this.__capturedTarget)) {                    ev.offset = this.__getOffset(ev);                    return;                }                ev.offset = {                    x: ev.offsetX,                    y: ev.offsetY                };            }            private __getOffset(ev: IExtendedEvent): IPoint {                var target = this.__capturedTarget || <any>ev.target;                if (isDocument(target)) {                    return {                        x: ev.clientX,                        y: ev.clientY                    };                }                var x = target.offsetLeft,                    y = target.offsetTop;                while (!isNull(target = target.offsetParent)) {                    x += target.offsetLeft;                    y += target.offsetTop;                }                return {                    x: (ev.clientX - x),                    y: (ev.clientY - y)                };            }            private __clearHold(): void {                if (!isNull(this.__holdTimeout)) {                    clearTimeout(this.__holdTimeout);                    this.__holdTimeout = null;                }            }            // utility methods            private __getDistance(x1: number, x2: number, y1: number, y2: number): number {                var x = Math.abs(x2 - x1),                    y = Math.abs(y2 - y1);                return Math.sqrt((x * x) + (y * y));            }            private __getVelocity(dx: number, dy: number, dt: number): IVelocity {                return {                    x: Math.abs(dx / dt) || 0,                    y: Math.abs(dy / dt) || 0                };            }            private __getDirection(dx: number, dy: number): string {                var distanceX = Math.abs(dx),                    distanceY = Math.abs(dy);                if (distanceY > distanceX) {                    return dy < 0 ? 'up' : 'down';                }                return dx < 0 ? 'left' : 'right';            }            private __checkForOriginChanged(direction: string): boolean {                var lastMove = this.__lastMoveEvent;                if (isNull(lastMove)) {                    this.__hasSwiped = false;                    return this.__checkForRegisteredSwipe(direction);                }                var swipeDirection = lastMove.direction;                if (swipeDirection === direction) {                    return false;                }                this.__swipeOrigin = lastMove;                this.__hasSwiped = false;                return this.__checkForRegisteredSwipe(direction);            }            private __checkForRegisteredSwipe(direction: string): boolean {                var swipeTarget = <ICustomElement>this.__swipeOrigin.target,                    swipeGesture = this._gestures.$swipe,                    swipeDirectionGesture = swipeGesture + direction,                    domEventSwipe = this.__findFirstSubscriber(swipeTarget, swipeGesture),                    domEventSwipeDirection = this.__findFirstSubscriber(swipeTarget, swipeDirectionGesture);                this.__swipeSubscribers = {                    master: domEventSwipe,                    directional: domEventSwipeDirection                };                return !isNull(domEventSwipe) || !isNull(domEventSwipeDirection);            }            private __isHorizontal(direction: string): boolean {                return direction === 'left' || direction === 'right';            }            private __appendGestureStyle(): void {                var $document = this.$Document,                    styleClasses: Array<IDefaultStyle>,                    classLength: number;                if (this.$Compat.platCss) {                    return;                } else if (!isNull($document.styleSheets) && $document.styleSheets.length > 0) {                    var styleSheet = <CSSStyleSheet>$document.styleSheets[0];                    styleClasses = DomEvents.config.styleConfig;                    classLength = styleClasses.length;                    while (classLength-- > 0) {                        styleSheet.insertRule(this.__createStyle(styleClasses[classLength]), 0);                    }                    return;                }                var head = $document.head,                    style = <HTMLStyleElement>$document.createElement('style'),                    textContent = '';                style.type = 'text/css';                styleClasses = DomEvents.config.styleConfig;                classLength = styleClasses.length;                while (classLength-- > 0) {                    textContent = this.__createStyle(styleClasses[classLength]) + textContent;                }                style.textContent = textContent;                head.appendChild(style);            }            private __createStyle(styleClass: IDefaultStyle): string {                var styles: Array<string> = styleClass.styles || [],                    styleLength = styles.length,                    style = '.' + styleClass.className + ' { ',                    textContent = '';                    styleLength = styles.length;                    for (var j = 0; j < styleLength; ++j) {                        textContent += styles[j] + ';';                    }                    style += textContent + ' } ';                return style;            }            private __isFocused(target: EventTarget): boolean {                return target === this.__focusedElement;            }            private __handleInput(target: HTMLInputElement): void {                var nodeName = target.nodeName,                    focusedElement = this.__focusedElement || <HTMLInputElement>{};                if (!isString(nodeName)) {                    this.__focusedElement = null;                    if (isFunction(focusedElement.blur)) {                        focusedElement.blur();                    }                    return;                }                var remover: IRemoveListener,                    $document: Document;                switch (nodeName.toLowerCase()) {                    case 'input':                        switch (target.type) {                            case 'range':                                if (isFunction(focusedElement.blur)) {                                    focusedElement.blur();                                }                                break;                            case 'button':                            case 'submit':                            case 'checkbox':                            case 'radio':                            case 'file':                                if (isFunction(focusedElement.blur)) {                                    focusedElement.blur();                                }                                $document = this.$Document;                                postpone(() => {                                    if ($document.body.contains(target)) {                                        target.click();                                    }                                });                                break;                            default:                                this.__focusedElement = target;                                target.focus();                                remover = this.addEventListener(target, 'blur', () => {                                    if (this.__isFocused(target)) {                                        this.__focusedElement = null;                                    }                                    remover();                                }, false);                                return;                        }                        break;                    case 'a':                    case 'button':                    case 'select':                    case 'label':                        if (isFunction(focusedElement.blur)) {                            focusedElement.blur();                        }                        $document = this.$Document;                        postpone(() => {                            if ($document.body.contains(target)) {                                target.click();                            }                        });                        break;                    case 'textarea':                        this.__focusedElement = target;                        target.focus();                        remover = this.addEventListener(target, 'blur', () => {                            if (this.__isFocused(target)) {                                this.__focusedElement = null;                            }                            remover();                        }, false);                        return;                    default:                        if (isFunction(focusedElement.blur)) {                            focusedElement.blur();                        }                        break;                }                this.__focusedElement = null;                return;            }            private __preventClickFromTouch(): void {                var $document = this.$Document,                    delayedClickRemover = defer(() => {                        $document.removeEventListener('click', preventDefault, true);                        $document.removeEventListener('mousedown', preventDefault, true);                        $document.removeEventListener('mouseup', preventDefault, true);                    }, 400),                    preventDefault = (ev: Event) => {                        ev.preventDefault();                        ev.stopPropagation();                        $document.removeEventListener(ev.type, preventDefault, true);                        if (delayedClickRemover === noop) {                            return false;                        }                        delayedClickRemover();                        delayedClickRemover = noop;                        var touchDown = this.__lastTouchDown;                        if (isNull(touchDown) || this.__isFocused(touchDown.target)) {                            return false;                        }                        this.__handleInput(<HTMLInputElement>touchDown.target);                        return false;                    };                $document.addEventListener('click', preventDefault, true);                $document.addEventListener('mousedown', preventDefault, true);                $document.addEventListener('mouseup', preventDefault, true);            }            private __removeSelections(element: Node): void {                if (!isNode(element)) {                    return;                }                if (!isUndefined((<any>element).onselectstart)) {                    element.addEventListener('selectstart', this.__preventDefault, false);                }                if (!isUndefined((<any>element).ondragstart)) {                    element.addEventListener('dragstart', this.__preventDefault, false);                }            }            private __returnSelections(element: Node): void {                if (!isNode(element)) {                    return;                }                if (!isUndefined((<any>element).onselectstart)) {                    element.removeEventListener('selectstart', this.__preventDefault, false);                }                if (!isUndefined((<any>element).ondragstart)) {                    element.removeEventListener('dragstart', this.__preventDefault, false);                }            }            private __preventDefault(ev: Event): boolean {                var nodeName = (<Node>ev.target).nodeName;                if (isString(nodeName)) {                    nodeName = nodeName.toLowerCase();                }                if (nodeName === 'input' || nodeName === 'textarea') {                    return true;                }                ev.preventDefault();                return false;            }        }        /**         * The Type for referencing the '$DomEvents' injectable as a dependency.         */        export function IDomEvents(): IDomEvents {            return new DomEvents();        }        register.injectable(__DomEvents, IDomEvents);        /**         * Describes an object for managing DOM event registration and handling.         */        export interface IDomEvents {            /**             * Add an event listener for the specified event type on the specified element.              *              * @param element The node listening for the event.             * @param type The type of event being listened to.             * @param listener The listener to be fired.             * @param useCapture Whether to fire the event on the capture or bubble phase of propagation.             * @returns {IRemoveListener} A function to remove the added event listener.             */            addEventListener(element: Node, type: string, listener: IGestureListener,                useCapture?: boolean): IRemoveListener;            /**             * Add an event listener for the specified event type on the specified element.              *              * @param element The window object.             * @param type The type of event being listened to.             * @param listener The listener to be fired.             * @param useCapture Whether to fire the event on the capture or bubble phase of propagation.             * @returns {IRemoveListener} A function to remove the added event listener.             */            addEventListener(element: Window, type: string, listener: IGestureListener,                useCapture?: boolean): IRemoveListener;            /**             * Add an event listener for the specified event type on the specified element.              *              * @param element The node listening for the event.             * @param type The type of event being listened to.             * @param listener The listener to be fired.             * @param useCapture Whether to fire the event on the capture or bubble phase of propagation.             * @returns {IRemoveListener} A function to remove the added event listener.             */            addEventListener(element: Node, type: string, listener: EventListener,                useCapture?: boolean): IRemoveListener;            /**             * Add an event listener for the specified event type on the specified element.              *              * @param element The window object.             * @param type The type of event being listened to.             * @param listener The listener to be fired.             * @param useCapture Whether to fire the event on the capture or bubble phase of propagation.             * @returns {IRemoveListener} A function to remove the added event listener.             */            addEventListener(element: Window, type: string, listener: EventListener,                useCapture?: boolean): IRemoveListener;            /**             * Stops listening for touch events and resets the DomEvents instance.             */            dispose(): void;        }        /**         * The Type for referencing the '$DomEventsConfig' injectable as a dependency.         */        export function IDomEventsConfig(): IDomEventsConfig {            return DomEvents.config;        }        register.injectable(__DomEventsConfig, IDomEventsConfig);        /**         * A class for managing a single custom event.         */        export class DomEvent implements IDomEventInstance {            $Document: Document = acquire(__Document);            element: any;            event: string;            initialize(element: Node, event: string): void;            initialize(element: Window, event: string): void;            initialize(element: any, event: string): void {                this.element = element;                this.event = event;            }            trigger(eventExtension?: Object): void {                var customEv = <CustomEvent>this.$Document.createEvent('CustomEvent');                if (isObject(eventExtension)) {                    extend(customEv, eventExtension);                }                customEv.initCustomEvent(this.event, true, true, 0);                this.element.dispatchEvent(customEv);            }        }        /**         * The Type for referencing the '$DomEventInstance' injectable as a dependency.         */        export function IDomEventInstance(): IDomEventInstance {            return new DomEvent();        }        register.injectable(__DomEventInstance, IDomEventInstance, null, __INSTANCE);        /**         * A specialized class for managing a single custom touch event in DomEvents.         */        class CustomDomEvent extends DomEvent {            count = 0;            constructor(element: Node, event: string);            constructor(element: Window, event: string);            constructor(element: any, event: string) {                super();                this.element = element;                this.event = event;                this.count++;            }            trigger(ev: IPointerEvent): void {                var customEv = <CustomEvent>this.$Document.createEvent('CustomEvent');                this.__extendEventObject(customEv, ev);                customEv.initCustomEvent(this.event, true, true, 0);                this.element.dispatchEvent(customEv);            }            private __extendEventObject(customEv: IGestureEvent, ev: IPointerEvent): void {                // not using extend function because this gets called so often for certain events.                var pointerType = ev.pointerType;                customEv.clientX = ev.clientX;                customEv.clientY = ev.clientY;                customEv.offsetX = ev.offset.x;                customEv.offsetY = ev.offset.y;                customEv.direction = ev.direction || 'none';                customEv.touches = ev.touches;                customEv.velocity = ev.velocity || { x: 0, y: 0 };                customEv.identifier = ev.identifier || 0;                customEv.pointerType = isNumber(pointerType) ? this.__convertPointerType(pointerType, ev.type) : pointerType;                customEv.screenX = ev.screenX;                customEv.screenY = ev.screenY;                customEv.pageX = ev.pageX;                customEv.pageY = ev.pageY;            }            private __convertPointerType(pointerType: any, eventType: string): string {                switch (<any>pointerType) {                    case MSPointerEvent.MSPOINTER_TYPE_MOUSE:                        return 'mouse';                    case MSPointerEvent.MSPOINTER_TYPE_PEN:                        return 'pen';                    case MSPointerEvent.MSPOINTER_TYPE_TOUCH:                        return 'touch';                }                return (eventType.indexOf('mouse') === -1) ? 'touch' : 'mouse';            }        }        interface ICustomDomEventInstance extends IDomEventInstance {            /**             * The number of events registered to this IDomEventInstance.             */            count: number;            /**             * Triggers a custom event to bubble up to all elements in this branch of the DOM tree.             *              * @param ev The event object used to extend the custom touch event.             */            trigger(ev: IPointerEvent): void;        }        /**         * Describes an object used for managing a single custom event.         */        export interface IDomEventInstance {            /**             * The node or window object associated with this IDomEventInstance object.             */            element: any;            /**             * The event type associated with this IDomEventInstance.             */            event: string;            /**             * Initializes the element and event of the IDomEventInstance object             *              * @param The node associated with this IDomEventInstance.              * @param event The type of event this IDomEventInstance is managing.             */            initialize(element: Node, event: string): void;            /**             * Initializes the element and event of the IDomEventInstance object             *              * @param The window object.              * @param event The type of event this IDomEventInstance is managing.             */            initialize(element: Window, event: string): void;            /**             * Triggers a custom event to bubble up to all elements in this branch of the DOM tree.             *              * @param eventExtension object containing properties to extend the custom DOM event.             */            trigger(eventExtension?: Object): void;        }        /**         * Describes the touch event listeners for the document.         */        interface ICustomEventListener extends IObject<EventListener> {            /**             * The touch start event.             */            start: EventListener;            /**             * The touch end event.             */            end: EventListener;            /**             * The touch move event.             */            move: EventListener;        }        /**         * An extended event object potentially containing coordinate and movement information.         */        export interface IExtendedEvent extends Event {            /**             * The x-coordinate of the event on the screen relative to the upper left corner of the              * browser window. This value cannot be affected by scrolling.             */            clientX?: number;            /**             * The y-coordinate of the event on the screen relative to the upper left corner of the              * browser window. This value cannot be affected by scrolling.             */            clientY?: number;            /**             * The x-coordinate of the event on the screen relative to the upper left corner of the              * physical screen or monitor.             */            screenX?: number;            /**             * The y-coordinate of the event on the screen relative to the upper left corner of the              * physical screen or monitor.             */            screenY?: number;            /**             * The x-coordinate of the event on the screen relative to the upper left corner of the              * fully rendered content area in the browser window. This value can be altered and/or affected by              * embedded scrollable pages when the scroll bar is moved.             */            pageX?: number;            /**             * The y-coordinate of the event on the screen relative to the upper left corner of the              * fully rendered content area in the browser window. This value can be altered and/or affected by              * embedded scrollable pages when the scroll bar is moved.             */            pageY?: number;            /**             * The x-coordinate of the event relative to the top-left corner of the              * offsetParent element that fires the event.             */            offsetX?: number;            /**             * The y-coordinate of the event relative to the top-left corner of the              * offsetParent element that fires the event.             */            offsetY?: number;            /**             * The x and y-coordinates of the event as an object relative to the top-left corner of the              * offsetParent element that fires the event.             */            offset: IPoint;            /**             * The potential direction associated with the event.             */            direction?: string;            /**             * The potential velocity associated with the event.             */            velocity?: IVelocity;            /**             * An array containing all current touch points. The IExtendedEvents              * may slightly differ depending on the browser implementation.             */            touches?: Array<IExtendedEvent>;        }        /**         * An extended event object potentially containing coordinate and movement information as          * well as pointer type for pointer events.         */        export interface IPointerEvent extends IExtendedEvent {            /**             * The type of interaction associated with the touch event ('touch', 'pen', 'mouse', '')             */            pointerType?: string;            /**             * A unique touch identifier.             */            pointerId?: number;            /**             * A unique touch identifier.             */            identifier?: number;        }        /**         * The type of event object passed into the listeners for our custom events.         */        export interface IGestureEvent extends CustomEvent {            /**             * The x-coordinate of the event on the screen relative to the upper left corner of the              * browser window. This value cannot be affected by scrolling.             */            clientX?: number;            /**             * The y-coordinate of the event on the screen relative to the upper left corner of the              * browser window. This value cannot be affected by scrolling.             */            clientY?: number;            /**             * The x-coordinate of the event on the screen relative to the upper left corner of the              * physical screen or monitor.             */            screenX?: number;            /**             * The y-coordinate of the event on the screen relative to the upper left corner of the              * physical screen or monitor.             */            screenY?: number;            /**             * The x-coordinate of the event on the screen relative to the upper left corner of the              * fully rendered content area in the browser window. This value can be altered and/or affected by              * embedded scrollable pages when the scroll bar is moved.             */            pageX?: number;            /**             * The y-coordinate of the event on the screen relative to the upper left corner of the              * fully rendered content area in the browser window. This value can be altered and/or affected by              * embedded scrollable pages when the scroll bar is moved.             */            pageY?: number;            /**             * The x-coordinate of the event relative to the top-left corner of the              * offsetParent element that fires the event.             */            offsetX?: number;            /**             * The y-coordinate of the event relative to the top-left corner of the              * offsetParent element that fires the event.             */            offsetY?: number;            /**             * The potential direction associated with the event.             */            direction?: string;            /**             * The potential velocity associated with the event.             */            velocity?: IVelocity;            /**             * An array containing all current touch points. The IExtendedEvents              * may slightly differ depending on the browser implementation.             */            touches?: Array<IExtendedEvent>;            /**             * The type of interaction associated with the touch event ('touch', 'pen', 'mouse', '')             */            pointerType?: string;            /**             * A unique touch identifier.             */            identifier?: number;        }        /**         * The listener interface for our custom DOM events.         */        export interface IGestureListener {            /**             * An EventListener with the argument as an IGestureEvent.             */            (ev?: IGestureEvent): void;        }        /**         * Describes an object to keep track of a single          * element's registered custom event types.         */        export interface IEventSubscriber extends IGestures<IDomEventInstance> {            /**             * The total registered gesture count for the associated element.             */            gestureCount: number;        }        /**         * Describes an object containing information          * regarding all our custom events.         */        export interface IGestures<T> {            /**             * The string type|number of events associated with the tap event.             */            $tap?: T;            /**             * The string type|number of events associated with the dbltap event.             */            $dbltap?: T;            /**             * The string type|number of events associated with the hold event.             */            $hold?: T;            /**             * The string type|number of events associated with the release event.             */            $release?: T;            /**             * The string type|number of events associated with the swipe event.             */            $swipe?: T;            /**             * The string type|number of events associated with the swipeleft event.             */            $swipeleft?: T;            /**             * The string type|number of events associated with the swiperight event.             */            $swiperight?: T;            /**             * The string type|number of events associated with the swipeup event.             */            $swipeup?: T;            /**             * The string type|number of events associated with the swipedown event.             */            $swipedown?: T;            /**             * The string type|number of events associated with the track event.             */            $track?: T;            /**             * The string type|number of events associated with the trackleft event.             */            $trackleft?: T;            /**             * The string type|number of events associated with the trackright event.             */            $trackright?: T;            /**             * The string type|number of events associated with the trackup event.             */            $trackup?: T;            /**             * The string type|number of events associated with the trackdown event.             */            $trackdown?: T;            /**             * The string type|number of events associated with the trackend event.             */            $trackend?: T;        }        /**         * Describes an object containing information about a single point touched.         */        export interface ITouchPoint extends IPoint {            /**             * The touch target.             */            target: EventTarget;            /**             * The time of the touch.             */            timeStamp: number;            /**             * Prevents the default action of the browser             */            preventDefault?: () => void;        }        /**         * Describes an object containing x and y coordinates         */        export interface IPoint {            /**             * The x-coordinate.             */            x: number;            /**             * The y-coordinate             */            y: number;        }        /**         * Describes an object containing a speed in both the horizontal and vertical directions.         */        export interface IVelocity {            /**             * The horizontal speed.             */            x: number;            /**             * The vertical speed.             */            y: number;        }        /**         * Describes an object containing time interval information that          * governs the behavior of certain custom DOM events.         */        export interface IIntervals {            /**             * The max time in milliseconds a user can hold down on the screen              * for a tap event to be fired. Defaults to 200 ms.             */            tapInterval: number;            /**             * The max time in milliseconds a user can wait between consecutive              * taps for a dbltap event to be fired. Defaults to 300 ms.             */            dblTapInterval: number;            /**             * The time in milliseconds a user must hold down on the screen              * before a hold event is fired or a release event can be fired.              * Defaults to 400 ms.             */            holdInterval: number;            /**             * The delay in milliseconds between the time a user taps to the time              * the tap event fires. Used in the case where a double-tap-to-zoom              * feature is required. Defaults to 0 ms.             */            dblTapZoomDelay: number;        }        /**         * Describes an object containing distance information that          * governs the behavior of certain custom DOM events.         */        export interface IDistances {            /**             * The minimum distance a user must move after touch down to register              * it as a scroll instead of a tap. Defaults to 5.             */            minScrollDistance: number;            /**             * The maximum distance between consecutive taps a user is allowed to              * register a dbltap event. Defaults to 20.             */            maxDblTapDistance: number;        }        /**         * Describes an object containing velocity information that          * governs the behavior of certain custom DOM events.         */        export interface IVelocities {            /**             * The minimum velocity a user must move after touch down to register              * a swipe event. Defaults to 0.5.             */            minSwipeVelocity: number;        }        /**         * Describes an object used for creating a custom class for styling an element          * listening for a custom DOM event.         */        export interface IDefaultStyle {            /**             * The className that will be used to define the custom style.             */            className: string;            /**             * An array of string styles in the format:             * CSS identifier : value             * (i.e. 'width : 100px')             */            styles: Array<string>;        }        /**         * Describes a configuration object for all custom DOM events.         */        export interface IDomEventsConfig {            /**             * An object containing the different time intervals that govern the behavior of certain              * custom DOM events.             */            intervals: IIntervals;            /**             * An object containing the different minimum/maximum distances that govern the behavior of certain              * custom DOM events.             */            distances: IDistances;            /**             * An object containing the different minimum/maximum velocities that govern the behavior of certain              * custom DOM events.             */            velocities: IVelocities;            /**             * The default CSS styles applied to elements listening for custom DOM events.             */            styleConfig: Array<IDefaultStyle>;        }        /**         * A class used for animating elements.         */        export class Animator implements IAnimator {            $Compat: ICompat = acquire(__Compat);            /**             * All elements currently being animated.             */            _elements: IObject<IAnimatedElement> = {};            private __cssWarning = false;            /**             * Animates the element with the defined animation denoted by the key.             *              * @param element The Element to be animated.             * @param key The identifier specifying the type of animation.             * @param options Specified options for the animation.             */            animate(element: Element, key: string, options?: any): IAnimationPromise {                if (!isNode(element) || element.nodeType !== Node.ELEMENT_NODE || this.__parentIsAnimating(element)) {                    return this.__resolvePromise();                }                var $compat = this.$Compat,                    animation = animationInjectors[key],                    jsAnimation = jsAnimationInjectors[key],                    animationInstance: IBaseAnimation;                if (!$compat.animationSupported || isUndefined(animation)) {                    if (isUndefined(jsAnimation)) {                        return this.__resolvePromise();                    }                    animationInstance = jsAnimation.inject();                } else {                    if (!(this.__cssWarning || $compat.platCss)) {                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);                        $exception.warn('CSS animation occurring and platypus.css was not found prior to platypus.js. If you ' +                            'intend to use platypus.css, please move it before platypus.js inside your head or body declaration.',                            $exception.ANIMATION);                        this.__cssWarning = true;                    }                    animationInstance = animation.inject();                }                var id = this.__setAnimationId(element, animationInstance);                this.__stopChildAnimations(element, id);                var animationObj = this._elements[id],                    animationPromise = (<BaseAnimation>animationInstance)._init(element, options).then(() => {                        animationObj.promise = null;                        animationObj.animationEnd();                    });                if (!isNull(animationObj.promise)) {                    return animationObj.promise.then(() => {                        return animationPromise;                    });                }                return (animationObj.promise = animationPromise);            }            private __parentIsAnimating(element: Node): boolean {                while (!isDocument(element = element.parentNode) && element.nodeType === Node.ELEMENT_NODE) {                    if (hasClass(<HTMLElement>element, __Animating)) {                        return true;                    }                }                return false;            }            private __setAnimationId(element: Node, animationInstance: IBaseAnimation): string {                var elements = this._elements,                    plat = (<ICustomElement>element).__plat,                    id: string;                if (isUndefined(plat)) {                    (<ICustomElement>element).__plat = plat = {};                }                if (isUndefined(plat.animation)) {                    plat.animation = id = uniqueId('animation_');                } else {                    id = plat.animation;                }                var animationObj = elements[id],                    removeListener = (reanimating?: boolean) => {                    if (reanimating === true) {                        animationInstance.cancel();                        return;                    }                    removeClass(<HTMLElement>element, __Animating);                    deleteProperty(elements, id);                    deleteProperty(plat, 'animation');                    if (isEmpty(plat)) {                        deleteProperty(element, '__plat');                    }                };                if (isUndefined(animationObj)) {                    addClass(<HTMLElement>element, __Animating);                    elements[id] = {                        animationEnd: removeListener                    };                } else {                    animationObj.animationEnd(true);                    animationObj.animationEnd = removeListener;                }                return id;            }            private __stopChildAnimations(element: Element, id: string): void {                var elements = this._elements,                    animatedElements = Array.prototype.slice.call(element.querySelectorAll('.' + __Animating)),                    length = animatedElements.length,                    animatedElement: ICustomElement,                    plat: ICustomElementProperty;                while (length-- > 0) {                    animatedElement = animatedElements[length];                    plat = animatedElement.__plat;                    if (isUndefined(plat) || isUndefined(plat.animation)) {                        continue;                    }                    id = plat.animation;                    if (isFunction(elements[id])) {                        elements[id].animationEnd();                    }                }            }            private __resolvePromise() {                return new AnimationPromise((resolve) => {                    resolve();                });            }        }        /**         * The Type for referencing the '$Animator' injectable as a dependency.         */        export function IAnimator(): IAnimator {            return new Animator();        }        register.injectable('$Animator', IAnimator);        /**         * Describes an object used for animating elements.         */        export interface IAnimator {            /**             * Animates the element with the defined animation denoted by the key.             *              * @param element The Element to be animated.             * @param key The identifier specifying the type of animation.             * @param options Specified options for the animation.             */            animate(element: Element, key: string, options?: any): IAnimationPromise;        }        /**         * Describes an object representing a currenlty animated element.         */        export interface IAnimatedElement {            /**             * The function called at the conclusion of the animation.             *              * @param reanimated Specifies whether the element is being reanimated while              * in a current animation.             */            animationEnd: (reanimated?: boolean) => void;            /**             * A promise representing an element's current state of animation.             */            promise?: IAnimationThenable<any>;        }        /**         * Describes a type of Promise that fulfills with an IAjaxResponse and can be optionally cancelled.         */        export class AnimationPromise extends async.Promise<void> implements IAnimationPromise {            private __animationInstance: IBaseAnimation;            constructor(resolveFunction: (resolve: (value?: void) => any) => void, promise?: any) {                super(resolveFunction);                if (!isNull(promise)) {                    this.__animationInstance = promise.__animationInstance;                }            }            cancel(): IAnimationPromise {                if (!isNull(this.__animationInstance)) {                    this.__animationInstance.cancel();                    this.__animationInstance.end();                }                return this;            }            then<U>(onFulfilled: (success: void) => U): IAnimationThenable<U>;            then<U>(onFulfilled: (success: void) => async.IThenable<U>): IAnimationThenable<U>;            then<U>(onFulfilled: (success: void) => any): IAnimationThenable<U>  {                return <IAnimationThenable<U>><any>super.then<U>(onFulfilled);            }            catch<U>(onRejected: (error: any) => IAnimationThenable<U>): IAnimationThenable<U>;            catch<U>(onRejected: (error: any) => U): IAnimationThenable<U>;            catch<U>(onRejected: (error: any) => any): IAnimationThenable<U> {                return <IAnimationThenable<U>><any>super.catch<U>(onRejected);            }        }        /**         * Describes a type of IThenable that can optionally cancel it's associated animation.         */        export interface IAnimationThenable<R> extends async.IThenable<R> {            /**             * A method to cancel the current animation.             */            cancel(): IAnimationPromise;            /**             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @param onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             * @param onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: R) => IAnimationThenable<U>,                onRejected?: (error: any) => IAnimationThenable<U>): IAnimationThenable<U>;            /**             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @param onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             * @param onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: R) => IAnimationThenable<U>, onRejected?: (error: any) => U): IAnimationThenable<U>;            /**             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @param onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             * @param onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => IAnimationThenable<U>): IAnimationThenable<U>;            /**             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @param onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             * @param onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             */            then<U>(onFulfilled: (success: R) => U, onRejected?: (error: any) => U): IAnimationThenable<U>;            /**             * A wrapper method for Promise.then(undefined, onRejected);             *              * @param onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             */            catch<U>(onRejected: (error: any) => IAnimationThenable<U>): IAnimationThenable<U>;            /**             * A wrapper method for Promise.then(undefined, onRejected);             *              * @param onRejected A method called when/if the promise rejects. If undefined the next             * onRejected method in the promise chain will be called.             */            catch<U>(onRejected: (error: any) => U): IAnimationThenable<U>;        }        /**         * Describes a type of IPromise that fulfills when an animation is finished and can be optionally cancelled.         */        export interface IAnimationPromise extends IAnimationThenable<void> {            /**             * A method to cancel the current animation.             */            cancel(): IAnimationPromise;            /**             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @param onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             */            then<U>(onFulfilled: (success: void) => U): IAnimationThenable<U>;            /**             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @param onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             */            then<U>(onFulfilled: (success: void) => async.IThenable<U>): IAnimationThenable<U>;            /**             * Takes in two methods, called when/if the promise fulfills/rejects.             *              * @param onFulfilled A method called when/if the promise fulills. If undefined the next             * onFulfilled method in the promise chain will be called.             */            then<U>(onFulfilled: (success: void) => IAnimationThenable<U>): IAnimationThenable<U>;        }        /**         * A class representing a single animation for a single element.         */        export class BaseAnimation implements IBaseAnimation {            $Compat: ICompat = acquire(__Compat);            /**             * The node having the animation performed on it.             */            element: HTMLElement;            /**             * Contains DOM helper methods for manipulating this control's element.             */            dom: IDom = acquire(__Dom);            /**             * Specified options for the animation.             */            options: any;            private __resolve: () => void;            /**             * A function for initializing the animation or any of its properties before start.             */            initialize(): void { }            /**             * A function denoting the start of the animation.             */            start(): void { }            /**             * A function to be called when the animation is over.             */            end(): void {                if (isFunction(this.__resolve)) {                    this.__resolve();                }                this.dispose();            }            /**             * A function to be called to let it be known the animation is being cancelled.             */            cancel(): void {                this.end();            }            /**             * A function for reverting any modifications or changes that may have been made as a              * result of this animation.             */            dispose(): void {                this.__resolve = null;            }            /**             * Initializes the element and key properties of this animation and passes in the function              * to resolve when finished.             *              * @param element The element on which the animation will occur.             * @param options Specified options for the animation.             */            _init(element: Element, options?: any): IAnimationPromise {                this.element = <HTMLElement>element;                this.options = options;                return new AnimationPromise((resolve) => {                    this.__resolve = resolve;                    this.initialize();                    this.start();                }, { __animationInstance: this });            }        }        /**         * Describes an object representing a single animation for a single element.         */        export interface IBaseAnimation {            /**             * The node having the animation performed on it.             */            element: HTMLElement;            /**             * Contains DOM helper methods for manipulating this control's element.             */            dom: IDom;            /**             * Specified options for the animation.             */            options: any;            /**             * A function for initializing the animation or any of its properties before start.             */            initialize(): void;            /**             * A function denoting the start of the animation.             */            start(): void;            /**             * A function to be called when the animation is over.             */            end(): void;            /**             * A function for reverting any modifications or changes that may have been made as a              * result of this animation.             */            dispose(): void;            /**             * A function to be called to let it be known the animation is being cancelled.             */            cancel(): void;        }        /**         * A class representing a single CSS animation for a single element.         */        export class CssAnimation extends BaseAnimation implements ICssAnimation {            private __animationEvents: IAnimationEvents = this.$Compat.animationEvents;            private __subscribers: Array<() => void> = [];            private __removeListener: IRemoveListener;            /**             * A function for reverting any modifications or changes that may have been made as a              * result of this animation.             */            dispose(): void {                if (isFunction(this.__removeListener)) {                    this.__removeListener();                    this.__removeListener = null;                }                this.__subscribers = [];                super.dispose();            }            /**             * A function to listen to the start of an animation event.             *              * @param listener The function to call when the animation begins.             */            animationStart(listener: () => void): ICssAnimation {                return this.__addEventListener(this.__animationEvents.$animationStart, listener);            }            /**             * A function to listen to the start of a transition event.             *              * @param listener The function to call when the transition begins.             */            transitionStart(listener: () => void): ICssAnimation {                return this.__addEventListener(this.__animationEvents.$transitionStart, listener);            }            /**             * A function to listen to the end of an animation event.             *              * @param listener The function to call when the animation ends.             */            animationEnd(listener: () => void): ICssAnimation {                return this.__addEventListener(this.__animationEvents.$animationEnd, listener);            }            /**             * A function to listen to the end of a transition event.             *              * @param listener The function to call when the transition ends.             */            transitionEnd(listener: () => void): ICssAnimation {                return this.__addEventListener(this.__animationEvents.$transitionEnd, listener);            }            private __addEventListener(event: string, listener: () => void): ICssAnimation {                var subscribers = this.__subscribers,                    subscriber = () => {                        this.__removeListener = this.dom.addEventListener(this.element, event, (ev: Event) => {                            this.__removeListener();                            this.__removeListener = null;                            if (subscribers.length === 0) {                                return;                            }                            listener.call(this);                            subscribers.shift();                            if (subscribers.length === 0) {                                return;                            }                            subscribers[0]();                        }, false);                    };                subscribers.push(subscriber);                if (subscribers.length === 1) {                    subscriber();                }                return this;            }        }        /**         * Describes an object representing a single CSS animation for a single element.         */        export interface ICssAnimation extends IBaseAnimation {            /**             * A function to listen to the start of an animation event.             *              * @param listener The function to call when the animation begins.             */            animationStart(listener: () => void): ICssAnimation;            /**             * A function to listen to the start of a transition event.             *              * @param listener The function to call when the transition begins.             */            transitionStart(listener: () => void): ICssAnimation;            /**             * A function to listen to the end of an animation event.             *              * @param listener The function to call when the animation ends.             */            animationEnd(listener: () => void): ICssAnimation;            /**             * A function to listen to the end of a transition event.             *              * @param listener The function to call when the transition ends.             */            transitionEnd(listener: () => void): ICssAnimation;        }        /**         * A class for creating a single JavaScript animation for a single element.         */        export class JsAnimation extends BaseAnimation implements IJsAnimation {            /**             * A flag specifying that this animation is a JavaScript implementation.             */            isJs = true;        }        /**         * Describes an object representing a single JavaScript animation for a single element.         */        export interface IJsAnimation extends IBaseAnimation {            /**             * A flag specifying that this animation is a JavaScript implementation.             */            isJs: boolean;        }        export module animations {            /**             * A simple Css Animation class that places the 'plat-animation' class on an              * element, checks for animation properties, and waits for the animation to end.             */            export class SimpleCssAnimation extends CssAnimation implements ISimpleCssAnimation {                $Window: Window = acquire(__Window);                /**                 * The class name added to the animated element.                 */                className = __SimpleAnimation;                start(): void {                    var animationId = this.$Compat.animationEvents.$animation,                        element = this.element,                        className = this.className;                    addClass(element, className);                    var computedStyle = this.$Window.getComputedStyle(element),                        animationName = computedStyle[<any>(animationId + 'Name')];                    if (animationName === '' ||                        animationName === 'none' ||                        computedStyle[<any>(animationId + 'PlayState')] === 'paused') {                        removeClass(element, className);                        this.end();                        return;                    }                    this.animationEnd(() => {                        removeClass(element, className);                        this.end();                    });                }                cancel(): void {                    removeClass(this.element, this.className);                    super.cancel();                }            }            register.animation(__SimpleAnimation, SimpleCssAnimation);            /**             * An interface for extending the SimpleCssAnimation or SimpleCssTransition and allowing for              * custom class names to initiate animations or transitions.             */            export interface ISimpleCssAnimation extends ICssAnimation {                /**                 * The class name to place on the element.                 */                className: string;            }            /**             * An animation control that fades in an element as defined by the included CSS.             */            export class FadeIn extends SimpleCssAnimation {                className = __FadeIn;            }            register.animation(__FadeIn, FadeIn);            /**             * An animation control that fades out an element as defined by the included CSS.             */            export class FadeOut extends SimpleCssAnimation {                className = __FadeOut;            }            register.animation(__FadeOut, FadeOut);            /**             * An animation control that causes an element to enter as defined by the included CSS.             */            export class Enter extends SimpleCssAnimation {                className = __Enter;            }            register.animation(__Enter, Enter);            /**             * An animation control that causes an element to leave as defined by the included CSS.             */            export class Leave extends SimpleCssAnimation {                className = __Leave;            }            register.animation(__Leave, Leave);            /**             * A simple Css Animation class that places the 'plat-transition' class on an              * element, checks for transition properties, and waits for the transition to end.             */            export class SimpleCssTransition extends CssAnimation implements ISimpleCssTransition {                $Window: Window = acquire(__Window);                /**                 * A JavaScript object with key value pairs for adjusting transition values.                  * (i.e. { width: '800px' } would set the element's width to 800px.                 */                options: plat.IObject<string>;                /**                 * The class name added to the animated element.                 */                className = __SimpleTransition;                start(): void {                    var transitionId = this.$Compat.animationEvents.$transition,                        element = this.element,                        className = this.className,                        endFn = () => {                            removeClass(element, className);                            this.end();                        };                    addClass(element, className);                    var computedStyle = this.$Window.getComputedStyle(element),                        transitionProperty = computedStyle[<any>(transitionId + 'Property')],                        transitionDuration = computedStyle[<any>(transitionId + 'Duration')];                    if (transitionProperty === '' || transitionProperty === 'none' ||                        transitionDuration === '' || transitionDuration === '0s') {                        this._animate();                        endFn();                        return;                    }                    this.transitionEnd(endFn);                    if (this._animate()) {                        return;                    }                    endFn();                }                cancel(): void {                    removeClass(this.element, this.className);                    super.cancel();                }                /**                 * Animate the element based on the options passed in                 */                _animate(): boolean {                    var style = this.element.style || {},                        options = this.options || {},                        keys = Object.keys(options),                        length = keys.length,                        key: any,                        currentProperty: string,                        newProperty: string,                        unchanged = 0;                    for (var i = 0; i < length; ++i) {                        key = keys[i];                        currentProperty = style[key];                        newProperty = options[key];                        if (!isString(newProperty)) {                            unchanged++;                            continue;                        }                        style[key] = newProperty;                        if (currentProperty === style[key]) {                            unchanged++;                        }                    }                    return unchanged < length;                }            }            register.animation(__SimpleTransition, SimpleCssTransition);            export interface ISimpleCssTransition extends ISimpleCssAnimation {                /**                 * A JavaScript object with key value pairs for adjusting transition values.                  * (i.e. { width: '800px' } would set the element's width to '800px'.                 */                options: plat.IObject<string>;            }        }        /**         * @name controls         * @memberof plat.ui         * @kind namespace         *          * @description         * Holds classes and interfaces related to event management.         */        export module controls {            export class Baseport extends TemplateControl implements IBaseport {                $ManagerCache: storage.ICache<processing.IElementManager> = acquire(__ManagerCache);                $Document: Document = acquire(__Document);                $ElementManagerFactory: processing.IElementManagerFactory = acquire(__ElementManagerFactory);                $Animator: IAnimator = acquire(__Animator);                $Promise: async.IPromise = acquire(__Promise);                /**                 * @param navigator The navigator used for navigating between pages.                 */                constructor(public navigator: navigation.IBaseNavigator) {                    super();                }                /**                 * Clears the Baseport's innerHTML.                 */                setTemplate(): void {                    this.dom.clearNode(this.element);                    this._load();                }                /**                 * Initializes the navigator.                 *                  * @param navigationParameter A parameter needed                  * to perform the specified type of navigation.                 * @param options The IBaseNavigationOptions                  * needed on load for the inherited form of                  * navigation.                 */                _load(navigationParameter?: any, options?: navigation.IBaseNavigationOptions): void {                    var navigator = this.navigator;                    navigator.initialize(this);                    navigator.navigate(navigationParameter, options);                }                /**                 * Clean up any memory being held.                 */                dispose() {                    this.navigator.dispose();                }                /**                 * Grabs the root of this Baseport's manager                  * tree, clears it, and initializes the                  * creation of a new one by kicking off a                  * navigate.                 *                  * @param ev The navigation options                 */                navigateTo(ev: IBaseportNavigateToOptions): void {                    var control = ev.target,                        parameter = ev.parameter,                        options = ev.options,                        element = this.element,                        controlType = ev.type,                        newControl = dependency.Injector.isInjector(control),                        injectedControl = newControl ? control.inject() : control,                        replaceType = injectedControl.replaceWith,                        node = (isEmpty(replaceType) || replaceType === 'any') ? this.$Document.createElement('div') :                            <HTMLElement>this.$Document.createElement(replaceType),                        attributes: IObject<string> = {},                        nodeMap: processing.INodeMap = {                            element: node,                            attributes: attributes,                            nodes: [],                            uiControlNode: {                                control: injectedControl,                                nodeName: controlType,                                expressions: [],                                injector: control,                                childManagerLength: 0                            }                        };                    node.setAttribute('plat-control', controlType);                    element.appendChild(node);                    this.$Animator.animate(this.element, __Enter);                    var viewportManager = this.$ManagerCache.read(this.uid),                        manager = this.$ElementManagerFactory.getInstance(),                        navigator = this.navigator;                    viewportManager.children = [];                    manager.initialize(nodeMap, viewportManager, !newControl);                    control = this.controls[0];                    control.navigator = navigator;                    navigator.navigated(control, parameter, options);                    if (navigator.navigating) {                        return;                    }                    manager.setUiControlTemplate();                }                /**                 * Manages the navigatingFrom lifecycle event for                  * ViewControls.                 *                  * @param fromControl The ViewControl being navigated                  * away from.                 */                navigateFrom(fromControl: IBaseViewControl): async.IThenable<void> {                    if (isNull(fromControl) || !isFunction(fromControl.navigatingFrom)) {                        return this.$Promise.resolve<void>(null);                    }                    fromControl.navigatingFrom();                    return this.$Animator.animate(this.element, __Leave);                }            }            export interface IBaseport extends ITemplateControl {                /**                 * The object in charge of performing the                  * navigation to and from different                  * ViewControls.                 */                navigator: navigation.IBaseNavigator;                /**                 * Grabs the root of this Baseport's manager                  * tree, clears it, and initializes the                  * creation of a new one by kicking off a                  * navigate.                 *                  * @param ev The navigation options                 */                navigateTo(ev: IBaseportNavigateToOptions): void;                /**                 * Manages the navigatingFrom lifecycle event for                  * ViewControls.                 *                  * @param fromControl The ViewControl being navigated                  * away from.                 */                navigateFrom(fromControl: IBaseViewControl): async.IThenable<void>;            }            /**             * Navigation options for a Baseport and all              * controls that inherit from Baseport.             */            export interface IBaseportNavigateToOptions {                /**                 * Either a view control or an injector for a view control.                 */                target: any;                /**                 * The navigation parameter.                 */                parameter: any;                /**                 * The options used for navigation.                 */                options: navigation.IBaseNavigationOptions;                /**                 * The type of view control to navigate to.                 */                type: string;            }            export class Viewport extends Baseport {                /**                 * The evaluated plat-options object.                 */                options: observable.IObservableProperty<IViewportOptions>;                /**                 * A type of navigator that uses either the ViewControl's                  * Constructors or their registered names for navigation                  * from one to another.                 */                navigator: navigation.INavigatorInstance;                /**                 * Checks for a defaultView, finds the ViewControl's injector,                  * and initializes the loading of the view.                 */                _load(): void {                    var $exception: IExceptionStatic;                    if (isNull(this.options)) {                        $exception = acquire(__ExceptionStatic);                        $exception.warn('No defaultView specified in plat-options for plat-viewport.',                            $exception.NAVIGATION);                        return;                    }                    var options = this.options.value || <IViewportOptions>{},                        controlType = options.defaultView,                        injector = viewControlInjectors[controlType];                    if (isNull(injector)) {                        $exception = acquire(__ExceptionStatic);                        $exception.fatal('The defaultView ' + controlType + ' is not a registered view control.',                            $exception.NAVIGATION);                        return;                    }                    super._load(injector);                }            }            /**             * The available options for plat.ui.controls.Viewport.             */            export interface IViewportOptions {                /**                 * The registered name of the default                  * ViewControl to initially navigate to.                 */                defaultView: string;            }            register.control(__Viewport, Viewport, [__NavigatorInstance]);            class Routeport extends Baseport {                /**                 * The evaluated plat-options object.                 */                options: observable.IObservableProperty<IRouteportOptions>;                /**                 * A type of navigator that uses the registered routes                  * for ViewControls to navigate to and from one another.                 */                navigator: navigation.IRoutingNavigator;                /**                 * Looks for a defaultRoute and initializes the loading                  * of the view.                 */                _load(): void {                    var path = '',                        options = this.options;                    if (!isNull(options) && !isNull(options.value)) {                        path = options.value.defaultRoute || '';                    }                    super._load(path, {                        replace: true                    });                }            }            /**             * The available options for plat.ui.controls.Routeport.             */            export interface IRouteportOptions {                /**                 * The registered route of the default                  * ViewControl to initially navigate to.                 */                defaultRoute: string;            }            register.control(__Routeport, Routeport, [__RoutingNavigator]);            export class Template extends TemplateControl {                $Promise: async.IPromise = acquire(__Promise);                $TemplateCache: storage.ITemplateCache = acquire(__TemplateCache);                $Document: Document = acquire(__Document);                /**                 * Removes the <plat-template> node from the DOM                 */                replaceWith: string = null;                /**                 * The evaluated plat-options object.                 */                options: observable.IObservableProperty<ITemplateOptions>;                /**                 * The unique ID used to reference a particular                  * template.                 */                _id: string;                /**                 * The optional URL associated with this                  * particular template.                 */                _url: string;                private __isFirst: boolean = false;                private __templatePromise: async.IThenable<Template>;                private __templateControlCache: storage.ICache<any>;                /**                 * Creates the Template control cache                 */                constructor() {                    super();                    var $cacheFactory: storage.ICacheFactory = acquire(__CacheFactory);                    this.__templateControlCache = $cacheFactory.create<any>('__templateControlCache');                }                /**                 * Initializes the creation of the template.                 */                initialize(): void {                    var id = this._id = this.options.value.id,                        options = this.options.value;                    if (isNull(id)) {                        return;                    }                    this._url = options.templateUrl;                    var templatePromise: async.IThenable<Template> = this.__templateControlCache.read(id);                    if (!isNull(templatePromise)) {                        this.__templatePromise = templatePromise;                        return;                    }                    this.__isFirst = true;                    this._initializeTemplate();                }                /**                 * Decides if this is a template definition or                  * a template instance.                 */                loaded(): void {                    if (!this.__isFirst) {                        this._waitForTemplateControl(this.__templatePromise);                    }                }                /**                 * Removes the template from the template cache.                 */                dispose(): void {                    if (this.__isFirst) {                        this.__templateControlCache.dispose();                    }                }                /**                 * Determines whether a URL or innerHTML is being used,                  * creates the bindable template, and stores the template                  * in a template cache for later use.                 */                _initializeTemplate(): void {                    var id = this._id;                    if (isNull(id)) {                        return;                    }                    var parentNode = this.endNode.parentNode,                        url = this._url,                        template: any;                    if (!isNull(url)) {                        template = this.$TemplateCache.read(url);                        this.dom.clearNodeBlock(this.elementNodes, parentNode);                    } else {                        template = this.$Document.createDocumentFragment();                        this.dom.appendChildren(this.elementNodes, template);                    }                    var controlPromise: async.IThenable<ITemplateControl>;                    if (isPromise(template)) {                        controlPromise = template.catch((error: Error) => {                            if (isNull(error)) {                                return TemplateControl.determineTemplate(this, url);                            }                        }).then((template: DocumentFragment) => {                            this.bindableTemplates.add(id, template.cloneNode(true));                            return this;                        });                    } else {                        this.bindableTemplates.add(id, template.cloneNode(true));                        controlPromise = this.$Promise.resolve(this);                    }                    this.__templateControlCache.put(id, controlPromise);                }                /**                 * Waits for the template promise to resolve, then initializes                  * the binding of the bindable template and places it into the                  * DOM.                 *                  * @param templatePromise The promise associated with the first                  * instance of the template with this ID.                 */                _waitForTemplateControl(templatePromise: async.IThenable<Template>): void {                    var $exception: IExceptionStatic;                    templatePromise.then((templateControl: Template) => {                        if (!(isNull(this._url) || (this._url === templateControl._url))) {                            $exception = acquire(__ExceptionStatic);                            $exception.warn('The specified url: ' + this._url +                                ' does not match the original plat-template with id: ' +                                '"' + this._id + '". The original url will be loaded.',                                $exception.TEMPLATE);                        }                        this.__mapBindableTemplates(templateControl);                        return this.bindableTemplates.bind(this._id);                    }).then((clone) => {                        var endNode = this.endNode;                        this.dom.insertBefore(endNode.parentNode, clone, endNode);                    }).catch((error) => {                        postpone(() => {                            $exception = acquire(__ExceptionStatic);                            $exception.warn('Problem resolving plat-template url: ' +                                error.response, $exception.TEMPLATE);                        });                    });                }                private __mapBindableTemplates(control: Template): void {                    (<BindableTemplates>this.bindableTemplates)._cache =                        (<BindableTemplates>control.bindableTemplates)._cache;                    this.bindableTemplates.templates = control.bindableTemplates.templates;                }            }            /**             * The available options for plat.ui.controls.Template.             */            export interface ITemplateOptions {                /**                 * The unique ID used to label a template                  * and use it as DOM.                 */                id: string;                /**                 * An optional URL to specify a template                  * instead of using the element's innerHTML.                 */                templateUrl: string;            }            register.control(__Template, Template);            export class Ignore extends TemplateControl {                /**                 * Removes the innerHTML from the DOM and saves it.                 */                setTemplate(): void {                    this.innerTemplate = this.dom.appendChildren(this.element.childNodes);                }                /**                 * Places the saved innerHTML back into the DOM.                 */                loaded(): void {                    this.element.appendChild(this.innerTemplate.cloneNode(true));                }            }            register.control(__Ignore, Ignore);            export class ForEach extends TemplateControl {                $Animator: IAnimator = acquire(__Animator);                $Promise: async.IPromise = acquire(__Promise);                /**                 * The required context is an Array.                 */                context: Array<any>;                /**                 * This control needs to load before plat-bind.                 */                priority = 120;                /**                 * The child controls                 */                controls: Array<ITemplateControl>;                /**                 * Will fulfill whenever all items are loaded.                 */                itemsLoaded: async.IThenable<void>;                /**                 * The node length of the element's childNodes (innerHTML)                 */                _blockLength = 0;                private __removeListener: IRemoveListener;                private __currentAnimations: Array<IAnimationThenable<void>> = [];                private __resolveFn: () => void;                constructor() {                    super();                    this.itemsLoaded = new this.$Promise<void>((resolve) => {                        this.__resolveFn = resolve;                    });                }                /**                 * Creates a bindable template with the element's childNodes (innerHTML)                  * specified for the ForEach.                 */                setTemplate(): void {                    var childNodes: Array<Node> = Array.prototype.slice.call(this.element.childNodes);                    this.bindableTemplates.add('item', childNodes);                }                /**                 * Re-syncs the ForEach children controls and DOM with the new                  * array.                 *                  * @param newValue The new Array                 * @param oldValue The old Array                 */                contextChanged(newValue?: Array<any>, oldValue?: Array<any>): void {                    if (isNull(this.__removeListener)) {                        this._setListener();                    }                    if (!isArray(newValue)) {                        return;                    }                    if (newValue.length === 0) {                        this._removeItems(this.controls.length);                        return;                    }                    this._executeEvent({                        method: 'splice',                        arguments: null,                        returnValue: null,                        oldArray: oldValue || [],                        newArray: newValue || []                    });                }                /**                 * Observes the array for changes and adds initial items to the DOM.                 */                loaded(): void {                    var context = this.context;                    if (!isArray(context)) {                        return;                    }                    this._addItems(context.length, 0);                    this._setListener();                }                /**                 * Removes the Array listener                 */                dispose(): void {                    if (isFunction(this.__removeListener)) {                        this.__removeListener();                        this.__removeListener = null;                    }                    this.__resolveFn = null;                }                /**                 * Adds an item to the ForEach's element.                 *                  * @param item The document fragment representing a single item                 * @param animate Whether to animate the entering item                 */                _addItem(item: DocumentFragment, animate?: boolean): void {                    if (!isNode(item) ||                        !isArray(this.context) ||                        this.context.length === 0 ||                        this.controls.length === 0) {                        return;                    }                    var $animator = this.$Animator,                        childNodes: Array<Element>,                        childNode: Element;                    if (animate === true) {                        childNodes = Array.prototype.slice.call(item.childNodes);                        if (this._blockLength === 0) {                            this._blockLength = childNodes.length;                        }                    } else {                        if (this._blockLength === 0) {                            this._blockLength = item.childNodes.length;                        }                        this.dom.insertBefore(this.element, item);                        return;                    }                    this.dom.insertBefore(this.element, item);                    var currentAnimations = this.__currentAnimations;                    while (childNodes.length > 0) {                        childNode = childNodes.shift();                        if (childNode.nodeType === Node.ELEMENT_NODE) {                            currentAnimations.push($animator.animate(childNode, __Enter).then(() => {                                currentAnimations.shift();                            }));                        }                    }                }                /**                 * Removes an item from the ForEach's element.                 */                _removeItem(): void {                    var controls = this.controls,                        length = controls.length - 1;                    TemplateControl.dispose(controls[length]);                }                /**                 * Updates the ForEach's children resource objects when                  * the array changes.                 */                _updateResources(): void {                    var controls = this.controls,                        length = controls.length;                    for (var i = 0; i < length; ++i) {                        controls[i].resources.add(this._getAliases(i));                    }                }                /**                 * Sets a listener for the changes to the array.                 */                _setListener(): void {                    this.__removeListener = this.observeArray(this, 'context', this._arrayChanged);                }                /**                 * Receives an event when a method has been called on an array.                 *                  * @param ev The IArrayMethodInfo                 */                _arrayChanged(ev: observable.IArrayMethodInfo<any>): void {                    if (isFunction((<any>this)['_' + ev.method])) {                        this._executeEvent(ev);                    }                }                /**                 * Maps an array method to its associated method handler.                 *                  * @param ev The IArrayMethodInfo                 */                _executeEvent(ev: observable.IArrayMethodInfo<any>): void {                    (<any>this)['_' + ev.method](ev);                }                /**                 * Adds new items to the ForEach's element when items are added to                  * the array.                 *                  * @param numberOfItems The number of items to add.                 * @param index The point in the array to start adding items.                 * @param animate whether to animate the new items                 */                _addItems(numberOfItems: number, index: number, animate?: boolean): async.IThenable<void> {                    var bindableTemplates = this.bindableTemplates,                        promises: Array<async.IThenable<void>> = [];                    for (var i = 0; i < numberOfItems; ++i, ++index) {                        promises.push(bindableTemplates.bind('item', index, this._getAliases(index)).then((fragment: DocumentFragment) => {                            this._addItem(fragment, animate);                        }).catch((error: any) => {                            postpone(() => {                                var $exception: IExceptionStatic = acquire(__ExceptionStatic);                                $exception.fatal(error, $exception.BIND);                            });                        }));                    }                    if (promises.length > 0) {                        this.itemsLoaded = this.$Promise.all(promises).then<void>(() => {                            if (isFunction(this.__resolveFn)) {                                this.__resolveFn();                                this.__resolveFn = null;                            }                            return;                        });                    } else {                        if (isFunction(this.__resolveFn)) {                            this.__resolveFn();                            this.__resolveFn = null;                        }                        this.itemsLoaded = new this.$Promise<void>((resolve) => {                            this.__resolveFn = resolve;                        });                    }                    return this.itemsLoaded;                }                /**                 * Removes items from the ForEach's element.                 *                  * @param numberOfItems The number of items to remove.                 */                _removeItems(numberOfItems: number): void {                    for (var i = 0; i < numberOfItems; ++i) {                        this._removeItem();                    }                    if (this.controls.length > 0) {                        this._updateResources();                    }                }                /**                 * Returns a resource alias object for an item in the array. The                  * resource object contains index:number, even:boolean, odd:boolean,                  * and first:boolean.                 *                  * @param index The index used to create the resource aliases.                 */                _getAliases(index: number): IObject<IResource> {                    var isEven = (index & 1) === 0;                    return {                        index: {                            value: index,                            type: 'observable'                        },                        even: {                            value: isEven,                            type: 'observable'                        },                        odd: {                            value: !isEven,                            type: 'observable'                        },                        first: {                            value: index === 0,                            type: 'observable'                        },                        last: {                            value: index === (this.context.length - 1),                            type: 'observable'                        }                    };                }                /**                 * Handles items being pushed into the array.                 *                  * @param ev The IArrayMethodInfo                 */                _push(ev: observable.IArrayMethodInfo<any>): void {                    this._addItems(ev.arguments.length, ev.oldArray.length, true);                }                /**                 * Handles items being popped off the array.                 *                  * @param ev The IArrayMethodInfo                 */                _pop(ev: observable.IArrayMethodInfo<any>): void {                    var blockLength = this._blockLength,                        startNode: number,                        animationPromise: plat.ui.IAnimationThenable<void>;                    if (blockLength > 0) {                        startNode = blockLength * ev.newArray.length;                        animationPromise = this._animateItems(startNode, undefined, __Leave);                    }                    if (isNull(animationPromise)) {                        this._removeItems(1);                        return;                    }                    this.itemsLoaded = animationPromise.then(() => {                        this._removeItems(1);                    });                }                /**                 * Handles items being shifted off the array.                 *                  * @param ev The IArrayMethodInfo                 */                _shift(ev: observable.IArrayMethodInfo<any>): void {                    this._removeItems(1);                }                /**                 * Handles adding/removing items when an array is spliced.                 *                  * @param ev The IArrayMethodInfo                 */                _splice(ev: observable.IArrayMethodInfo<any>): void {                    var oldLength = this.controls.length,                        newLength = ev.newArray.length;                    if (newLength > oldLength) {                        this._addItems(newLength - oldLength, oldLength, oldLength === 0);                    } else if (oldLength > newLength) {                        this._removeItems(oldLength - newLength);                    }                }                /**                 * Handles items being unshifted into the array.                 *                  * @param ev The IArrayMethodInfo                 */                _unshift(ev: observable.IArrayMethodInfo<any>): void {                    this._addItems(ev.arguments.length, ev.oldArray.length);                }                /**                 * Handles when the array is sorted.                 *                  * @param ev The IArrayMethodInfo                 */                _sort(ev: observable.IArrayMethodInfo<any>): void {                }                /**                 * Handles when the array is reversed.                 *                  * @param ev The IArrayMethodInfo                 */                _reverse(ev: observable.IArrayMethodInfo<any>): void {                }                /**                 * Animate a block of elements                 *                  * @param startNode The starting childNode of the ForEach to animate                 * @param endNode The ending childNode of the ForEach to animate                 * @param key The animation key/type                 * @param cancel Whether or not the animation should cancel all current animations                 */                _animateItems(startNode: number, endNode: number, key: string, cancel: boolean = true): IAnimationThenable<void> {                    var currentAnimations = this.__currentAnimations,                        length = currentAnimations.length;                    if (length === 0 || !cancel) {                        return this.__handleAnimation(startNode, endNode, key);                    }                    var animationPromises: Array<IAnimationThenable<void>> = [];                    while (length-- > 0) {                        animationPromises.push(currentAnimations[length].cancel());                    }                    return <IAnimationThenable<void>>this.$Promise.all(animationPromises).then(() => {                        return this.__handleAnimation(startNode, endNode, key);                    });                }                private __handleAnimation(startNode: number, endNode: number, key: string): IAnimationThenable<void> {                    var nodes: Array<Node> = Array.prototype.slice.call(this.element.childNodes, startNode, endNode),                        node: Node,                        $animator = this.$Animator,                        currentAnimations = this.__currentAnimations,                        animationPromise: IAnimationThenable<void>;                    while (nodes.length > 0) {                        node = nodes.shift();                        if (node.nodeType === Node.ELEMENT_NODE) {                            animationPromise = $animator.animate(<Element>node, key).then(() => {                                currentAnimations.shift();                            });                            currentAnimations.push(animationPromise);                        }                    }                    return animationPromise;                }            }            register.control(__ForEach, ForEach);            export class Html extends TemplateControl {                /**                 * Loads the new HTML String.                 */                contextChanged(): void {                    this.loaded();                }                /**                 * Loads the context as the innerHTML of the element.                 */                loaded(): void {                    var context = this.context;                    if (!isString(context)) {                        return;                    }                    this.dom.setInnerHtml(this.element, context);                }            }            register.control(__Html, Html);            export class Select extends TemplateControl {                $Promise: async.IPromise = acquire(__Promise);                $Document: Document = acquire(__Document);                /**                 * Replaces the <plat-select> node with                  * a <select> node.                 */                replaceWith: string = 'select';                /**                 * This control needs to load before plat-bind.                 */                priority = 120;                /**                 * Specifies the context as an Array.                 */                context: Array<any>;                /**                 * An object that keeps track of unique                  * optgroups.                 */                groups: IObject<Element> = {};                /**                 * The evaluated plat-options object.                 */                options: observable.IObservableProperty<ISelectOptions>;                /**                 * Will fulfill whenever all items are loaded.                 */                itemsLoaded: async.IThenable<void>;                private __removeListener: IRemoveListener;                private __isGrouped = false;                private __isNativeSelect = false;                private __group: string;                private __defaultOption: HTMLOptionElement;                private __resolveFn: () => void;                constructor() {                    super();                    this.itemsLoaded = new this.$Promise<void>((resolve) => {                        this.__resolveFn = resolve;                    });                }                /**                 * Creates the bindable option template and grouping                  * template if necessary.                 */                setTemplate(): void {                    var $document = this.$Document,                        options = this.options || <observable.IObservableProperty<ISelectOptions>>{},                        platOptions = options.value || <ISelectOptions>{},                        option = $document.createElement('option'),                        value = platOptions.value,                        textContent = platOptions.textContent;                    // check if the element should be treated as a normal select.                    if (isUndefined(value) && isUndefined(textContent)) {                        this.__isNativeSelect = true;                        return;                    }                    if (!isNull(platOptions.group)) {                        var group = this.__group = platOptions.group,                            optionGroup = $document.createElement('optgroup');                        optionGroup.label = __startSymbol + group + __endSymbol;                        this.bindableTemplates.add('group', optionGroup);                    }                    if (!isString(value) || isEmpty(value)) {                        value = undefined;                    }                    if (!isString(textContent) || isEmpty(textContent)) {                        textContent = undefined;                    }                    option.value = __startSymbol + (value || textContent) + __endSymbol;                    option.textContent = __startSymbol + (textContent || value) + __endSymbol;                    this.bindableTemplates.add('option', option);                }                /**                 * Re-observes the new array context and modifies                  * the options accordingly.                 *                  * @param newValue The new array context.                 * @param oldValue The old array context.                 */                contextChanged(newValue?: Array<any>, oldValue?: Array<any>): void {                    if (this.__isNativeSelect || !isArray(newValue)) {                        return;                    }                    var newLength = isArray(newValue) ? newValue.length : 0,                        oldLength = isArray(oldValue) ? oldValue.length : 0;                    if (isNull(this.__removeListener)) {                        this.__removeListener = this.observeArray(this, 'context',                        (ev?: observable.IArrayMethodInfo<any>) => {                            if (isFunction((<any>this)['_' + ev.method])) {                                (<any>this)['_' + ev.method](ev);                            }                        });                    }                    if (newLength > oldLength) {                        this._addItems(newLength - oldLength, oldLength);                    } else if (newLength < oldLength) {                        this._removeItems(oldLength - newLength);                    }                }                /**                 * Observes the new array context and adds                  * the options accordingly.                 */                loaded(): void {                    if (this.__isNativeSelect) {                        return;                    }                    var options = this.options || <observable.IObservableProperty<ISelectOptions>>{},                        platOptions = options.value || <ISelectOptions>{};                    if (isUndefined(platOptions.value) && isUndefined(platOptions.textContent)) {                        this.__isNativeSelect = true;                        return;                    }                    var context = this.context,                        element = this.element,                        firstElementChild = element.firstElementChild;                    if (isNode(firstElementChild) && firstElementChild.nodeName.toLowerCase() === 'option') {                        this.__defaultOption = <HTMLOptionElement>firstElementChild.cloneNode(true);                    }                    this.__isGrouped = !isNull((this.__group = platOptions.group));                    if (!isArray(context)) {                        return;                    }                    this._addItems(context.length, 0);                    this.__removeListener = this.observeArray(this, 'context', (ev?: observable.IArrayMethodInfo<any>) => {                        if (isFunction((<any>this)['_' + ev.method])) {                            (<any>this)['_' + ev.method](ev);                        }                    });                }                /**                 * Stops observing the array context.                 */                dispose(): void {                    if (isFunction(this.__removeListener)) {                        this.__removeListener();                        this.__removeListener = null;                    }                    this.__resolveFn = null;                    this.__defaultOption = null;                }                /**                 * Adds the options to the select element.                 *                  * @param numberOfItems The number of items                  * to add.                 * @param length The current index of the next                  * set of items to add.                 */                _addItems(numberOfItems: number, length: number): async.IThenable<void> {                    var index = length,                        item: any,                        bindableTemplates = this.bindableTemplates,                        promises: Array<async.IThenable<void>> = [];                    for (var i = 0; i < numberOfItems; ++i, ++index) {                        item = this.context[index];                        promises.push(bindableTemplates.bind('option', index).then<void>(this._insertOptions.bind(this, index, item)));                    }                    if (promises.length > 0) {                        this.itemsLoaded = this.$Promise.all(promises).then(() => {                            if (isFunction(this.__resolveFn)) {                                this.__resolveFn();                                this.__resolveFn = null;                            }                            return;                        });                    } else {                        if (isFunction(this.__resolveFn)) {                            this.__resolveFn();                            this.__resolveFn = null;                        }                        this.itemsLoaded = new this.$Promise<void>((resolve) => {                            this.__resolveFn = resolve;                        });                    }                    return this.itemsLoaded;                }                /**                 * The callback used to add an option after                  * its template has been bound.                 *                  * @param index The current index of the item being added.                 * @param item The item being added.                 * @param optionClone The bound DocumentFragment to be                  * inserted into the DOM.                 */                _insertOptions(index: number, item: any, optionClone: DocumentFragment): async.IThenable<any> {                    var element = this.element;                    if (this.__isGrouped) {                        var groups = this.groups,                            newGroup = item[this.__group],                            optgroup: any = groups[newGroup];                        if (isNull(optgroup)) {                            return (groups[newGroup] = <any>this.bindableTemplates.bind('group', index)                                .then((groupClone: DocumentFragment) => {                                    optgroup = groups[newGroup] = <Element>groupClone.childNodes[1];                                    optgroup.appendChild(optionClone);                                    element.appendChild(groupClone);                                    return optgroup;                                }));                        } else if (isPromise(optgroup)) {                            return optgroup.then((group: Element) => {                                group.appendChild(optionClone);                                return group;                            });                        }                        optgroup.appendChild(optionClone);                        return this.$Promise.resolve(null);                    }                    element.appendChild(optionClone);                    return this.$Promise.resolve(null);                }                /**                 * Removes the last option item from the DOM.                 */                _removeItem(index: number): void {                    if (index < 0) {                        return;                    }                    TemplateControl.dispose(this.controls[index]);                }                /**                 * Removes a specified number of elements.                 *                  * @param numberOfItems The number of items                  * to remove.                 */                _removeItems(numberOfItems: number): void {                    var controls = this.controls,                        length = controls.length - 1;                    while (numberOfItems-- > 0) {                        this._removeItem(length--);                    }                }                /**                 * The function called when an item has been removed                  * from the array context.                 *                  * @param ev The array mutation object                 */                _itemRemoved(ev: observable.IArrayMethodInfo<any>): void {                    if (ev.oldArray.length === 0) {                        return;                    } else if (this.__isGrouped) {                        this._resetSelect();                        return;                    }                    this._removeItems(1);                }                /**                 * Resets the select element by removing all its                  * items and adding them back.                 */                _resetSelect(): void {                    var itemLength = this.context.length,                        element = this.element,                        nodeLength = element.childNodes.length;                    this._removeItems(nodeLength);                    this.groups = {};                    if (!isNull(this.__defaultOption)) {                        element.appendChild(this.__defaultOption.cloneNode(true));                    }                    this._addItems(itemLength, 0);                }                /**                 * The function called when an element is pushed to                  * the array context.                 *                  * @param ev The array mutation object                 */                _push(ev: observable.IArrayMethodInfo<any>): void {                    this._addItems(ev.arguments.length, ev.oldArray.length);                }                /**                 * The function called when an item is popped                  * from the array context.                 *                  * @param ev The array mutation object                 */                _pop(ev: observable.IArrayMethodInfo<any>): void {                    this._itemRemoved(ev);                }                /**                 * The function called when an item is shifted                  * from the array context.                 *                  * @param ev The array mutation object                 */                _shift(ev: observable.IArrayMethodInfo<any>): void {                    this._itemRemoved(ev);                }                /**                 * The function called when items are spliced                  * from the array context.                 *                  * @param ev The array mutation object                 */                _splice(ev: observable.IArrayMethodInfo<any>): void {                    if (this.__isGrouped) {                        this._resetSelect();                        return;                    }                    var oldLength = ev.oldArray.length,                        newLength = ev.newArray.length;                    if (newLength > oldLength) {                        this._addItems(newLength - oldLength, oldLength);                    } else if (oldLength > newLength) {                        this._removeItems(oldLength - newLength);                    }                }                /**                 * The function called when an item is unshifted                  * onto the array context.                 *                  * @param ev The array mutation object                 */                _unshift(ev: observable.IArrayMethodInfo<any>): void {                    if (this.__isGrouped) {                        this._resetSelect();                        return;                    }                    this._addItems(ev.arguments.length, ev.oldArray.length);                }                /**                 * The function called when the array context                  * is sorted.                 *                  * @param ev The array mutation object                 */                _sort(ev: observable.IArrayMethodInfo<any>): void {                    if (this.__isGrouped) {                        this._resetSelect();                    }                }                /**                 * The function called when the array context                  * is reversed.                 *                  * @param ev The array mutation object                 */                _reverse(ev: observable.IArrayMethodInfo<any>): void {                    if (this.__isGrouped) {                        this._resetSelect();                    }                }            }            /**             * The available options for plat.ui.controls.Select.             */            export interface ISelectOptions {                /**                 * The property in your context array                  * of objects to use to group the objects                  * into optgroups.                 */                group: string;                /**                 * The property in your context array of                  * objects with which to use to bind to the                  * option's value.                 */                value: string;                /**                 * The property in your context array of                  * objects with which to use to bind to the                  * option's textContent.                 */                textContent: string;            }            register.control(__Select, Select);            export class If extends TemplateControl {                $Animator: IAnimator = acquire(__Animator);                /**                 * The evaluated plat-options object.                 */                options: observable.IObservableProperty<IIfOptions>;                /**                 * The Comment used to hold the place of the plat-if element.                 */                commentNode: Comment;                /**                 * The DocumentFragment that stores the plat-if element when hidden.                 */                fragmentStore: DocumentFragment;                private __condition: boolean = true;                private __removeListener: IRemoveListener;                private __leaveAnimation: IAnimationThenable<void>;                private __enterAnimation: IAnimationThenable<void>;                private __firstTime: boolean = true;                constructor() {                    super();                    var $document: Document = acquire(__Document);                    this.commentNode = $document.createComment('plat-if' + __BOUND_PREFIX + 'placeholder');                    this.fragmentStore = $document.createDocumentFragment();                }                /**                 * Checks the options and initializes the                  * evaluation.                 */                contextChanged(): void {                    var options = this.options.value;                    if (isEmpty(options)) {                        return;                    }                    this._setter(options);                }                /**                 * Sets the visibility to true if no options are                  * defined, kicks off the evaluation, and observes                  * the options for changes.                 */                loaded(): void {                    if (isNull(this.options)) {                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);                        $exception.warn('No condition specified in plat-options for plat-if.', $exception.BIND);                        this.options = {                            value: {                                condition: true                            },                            observe: <any>noop                        };                    }                    this.contextChanged();                    this.__firstTime = false;                    this.__removeListener = this.options.observe(this._setter);                }                /**                 * Stops listening to the options for changes.                 */                dispose(): void {                    if (isFunction(this.__removeListener)) {                        this.__removeListener();                        this.__removeListener = null;                    }                    this.commentNode = null;                    this.fragmentStore = null;                }                /**                 * Checks the condition and decides                  * whether or not to add or remove                  * the node from the DOM.                 */                _setter(options: IIfOptions): void {                    var value = !!options.condition;                    if (value === this.__condition) {                        return;                    }                    if (value) {                        if (!isNull(this.__leaveAnimation)) {                            this.__leaveAnimation.cancel().then(() => {                                this.__leaveAnimation = null;                                this._addItem();                            });                        } else {                            this._addItem();                        }                    } else {                        if (!isNull(this.__enterAnimation)) {                            this.__enterAnimation.cancel().then(() => {                                this.__enterAnimation = null;                                this._removeItem();                            });                        } else {                            this._removeItem();                        }                    }                    this.__condition = value;                }                /**                 * The callback used to add the fragment to the DOM                  * after the bindableTemplate has been created.                 */                _addItem(): void {                    var commentNode = this.commentNode,                        parentNode = commentNode.parentNode;                    if (!isNode(parentNode)) {                        return;                    }                    parentNode.replaceChild(this.fragmentStore, commentNode);                    this.__enterAnimation = this.$Animator.animate(this.element, __Enter).then(() => {                        this.__enterAnimation = null;                    });                }                /**                 * Removes the node from the DOM.                 */                _removeItem(): void {                    var element = this.element;                    if (this.__firstTime) {                        element.parentNode.insertBefore(this.commentNode, element);                        insertBefore(this.fragmentStore, element);                        return;                    }                    this.__leaveAnimation = this.$Animator.animate(element, __Leave).then(() => {                        this.__leaveAnimation = null;                        element.parentNode.insertBefore(this.commentNode, element);                        insertBefore(this.fragmentStore, element);                    });                }            }            /**             * The available options for plat.ui.controls.If.             */            export interface IIfOptions {                /**                 * A boolean expression to bind to                  * the element's visibility.                 */                condition: boolean;            }            register.control(__If, If);            class Anchor extends TemplateControl {                replaceWith = 'a';                element: HTMLAnchorElement;                initialize(): void {                    var element = this.element;                    if (isEmpty(element.href)) {                        this.addEventListener(element, 'click', (ev: Event) => {                            if (isEmpty(element.href)) {                                ev.preventDefault();                            }                        }, false);                    }                }            }            register.control(__Anchor, Anchor);        }    }    export module processing {        /**         * Responsible for iterating through the DOM and collecting controls.         */        export class Compiler implements ICompiler {            $ElementManagerFactory: IElementManagerFactory = acquire(__ElementManagerFactory);            $TextManagerFactory: ITextManagerFactory = acquire(__TextManagerFactory);            $CommentManagerFactory: ICommentManagerFactory = acquire(__CommentManagerFactory);            $ManagerCache: storage.ICache<INodeManager> = acquire(__ManagerCache);            compile(node: Node, control?: ui.ITemplateControl): void;            compile(nodes: Array<Node>, control?: ui.ITemplateControl): void;            compile(nodes: NodeList, control?: ui.ITemplateControl): void;            compile(node: any, control?: ui.ITemplateControl) {                var childNodes = node.childNodes,                    length: number,                    newLength: number,                    childNode: Node,                    hasControl = !isNull(control),                    manager = <IElementManager>(hasControl ? this.$ManagerCache.read(control.uid) : null),                    create = this.$ElementManagerFactory.create;                if (!isUndefined(childNodes)) {                    childNodes = Array.prototype.slice.call(childNodes);                } else if (isFunction(node.push)) {                    childNodes = node;                } else {                    childNodes = Array.prototype.slice.call(node);                }                if (isNull(manager)) {                    length = childNodes.length;                    for (var i = 0; i < length; ++i) {                        childNode = childNodes[i];                        if (childNode.nodeType === Node.ELEMENT_NODE) {                            if (!isNull(create(<Element>childNode))) {                                this.compile(childNode);                            }                        }                        newLength = childNodes.length;                        i += newLength - length;                        length = newLength;                    }                } else {                    this._compileNodes(childNodes, manager);                }            }            /**             * Iterates through the array of nodes creating Element Managers on Element              * nodes, Text Managers on text nodes, and Comment Managers on comment nodes.             *              * @param nodes The NodeList to be compiled.              * @param manager The parent Element Manager for the given array of nodes.             */            _compileNodes(nodes: Array<Node>, manager: IElementManager): void {                var length = nodes.length,                    node: Node,                    newManager: IElementManager,                    newLength: number,                    create = this.$ElementManagerFactory.create,                    commentCreate = this.$CommentManagerFactory.create,                    textCreate = this.$TextManagerFactory.create;                for (var i = 0; i < length; ++i) {                    node = nodes[i];                    switch (node.nodeType) {                        case Node.ELEMENT_NODE:                            newManager = create(<Element>node, manager);                            if (!isNull(newManager)) {                                this._compileNodes(Array.prototype.slice.call(node.childNodes), newManager);                            }                            break;                        case Node.TEXT_NODE:                            textCreate(node, manager);                            break;                        case Node.COMMENT_NODE:                            commentCreate(node, manager);                            break;                    }                    newLength = nodes.length;                    i += newLength - length;                    length = newLength;                }            }        }        /**         * The Type for referencing the '$Compiler' injectable as a dependency.         */        export function ICompiler(): ICompiler {            return new Compiler();        }        register.injectable(__Compiler, ICompiler);        /**         * Describes an object that iterates through the DOM and collects controls.         */        export interface ICompiler {            /**             * Goes through the childNodes of the given Node, finding elements that contain controls as well as             * text that contains markup.             *              * @param node The node whose childNodes are going to be compiled.             * @param control The parent control for the given Node. The parent must implement ui.ITemplateControl             * since only controls that implement ui.ITemplateControl can contain templates.             */            compile(node: Node, control?: ui.ITemplateControl): void;            /**             * Goes through the Node array, finding elements that contain controls as well as             * text that contains markup.             *              * @param nodes The Node array to be compiled.             * @param control The parent control for the given Node array. The parent must implement ui.ITemplateControl             * since only controls that implement ui.ITemplateControl are responsible for creating DOM.             */            compile(nodes: Array<Node>, control?: ui.ITemplateControl): void;            /**             * Goes through the NodeList, finding elements that contain controls as well as             * text that contains markup.             *              * @param nodes The NodeList to be compiled.              * @param control The parent control for the given NodeList. The parent must implement ui.ITemplateControl             * since only controls that implement ui.ITemplateControl are responsible for creating DOM.             */            compile(nodes: NodeList, control?: ui.ITemplateControl): void;        }        /**         * A NodeManager is responsible for data binding a data context to a Node.         */        export class NodeManager implements INodeManager {            static $ContextManagerStatic: observable.IContextManagerStatic;            static $Parser: expressions.IParser;            static $TemplateControlFactory: ui.ITemplateControlFactory;            /**             * Given an IParsedExpression array, creates an array of unique identifers             * to use with binding. This allows us to avoid creating multiple listeners             * for the identifier and node.             *              * @static             * @param expressions An IParsedExpression array to search for identifiers.             * @returns {Array<string>} An array of identifiers.             */            static findUniqueIdentifiers(expressions: Array<expressions.IParsedExpression>): Array<string> {                var length = expressions.length,                    uniqueIdentifierObject: IObject<boolean> = {},                    uniqueIdentifiers: Array<string> = [],                    identifiers: Array<string>,                    identifier: string,                    j: number,                    jLength: number;                if (length === 1) {                    return expressions[0].identifiers.slice(0);                }                for (var i = 0; i < length; ++i) {                    identifiers = expressions[i].identifiers;                    jLength = identifiers.length;                    for (j = 0; j < jLength; ++j) {                        identifier = identifiers[j];                        if (isNull(uniqueIdentifierObject[identifier])) {                            uniqueIdentifierObject[identifier] = true;                            uniqueIdentifiers.push(identifier);                        }                    }                }                return uniqueIdentifiers;            }            /**             * Determines if a string has the markup notation.             *              * @param text The text string in which to search for markup.             * @returns {Boolean} Indicates whether or not there is markup.             */            static hasMarkup(text: string): boolean {                return NodeManager._markupRegex.test(text);            }            /**             * Given a string, finds markup in the string and creates an IParsedExpression array.             *              * @static             * @param text The text string to parse.             */            static findMarkup(text: string): Array<expressions.IParsedExpression> {                var start: number,                    end: number,                    parsedExpressions: Array<expressions.IParsedExpression> = [],                    wrapExpression = NodeManager._wrapExpression,                    substring: string,                    expression: expressions.IParsedExpression,                    $parser = NodeManager.$Parser;                text = text.replace(NodeManager._newLineRegex, '');                while ((start = text.indexOf(__startSymbol)) !== -1 && (end = text.indexOf(__endSymbol)) !== -1) {                    if (start !== 0) {                        parsedExpressions.push(wrapExpression(text.substring(0, start)));                    }                    // incremement with while loop instead of just += 2 for nested object literal case.                    while (text[++end] === '}') { }                    substring = text.substring(start + 2, end - 2);                    // check for one-time databinding                    if (substring[0] === '=') {                        substring = substring.substr(1).trim();                        expression = $parser.parse(substring);                        expression = {                            expression: expression.expression,                            evaluate: expression.evaluate,                            identifiers: [],                            aliases: expression.aliases,                            oneTime: true                        };                        parsedExpressions.push(expression);                    } else {                        parsedExpressions.push($parser.parse(substring.trim()));                    }                    text = text.substr(end);                }                if (start > -1 && end >= 0) {                    parsedExpressions.push(wrapExpression(text.substring(end)));                } else if (text !== '') {                    parsedExpressions.push(wrapExpression(text));                }                return parsedExpressions;            }            /**             * Takes in data context and an IParsedExpression array and outputs a string of the evaluated             * expressions.             *              * @static             * @param expressions The IParsedExpression array to evaluate.             * @param control The IControl used to parse the expressions.             * @returns {string} The evaluated expressions.             */            static build(expressions: Array<expressions.IParsedExpression>, control?: ui.ITemplateControl) {                var text = '',                    length = expressions.length,                    resources = {},                    expression: expressions.IParsedExpression,                    value: any,                    evaluateExpression = NodeManager.$TemplateControlFactory.evaluateExpression;                for (var i = 0; i < length; ++i) {                    expression = expressions[i];                    value = evaluateExpression(expression, control, resources);                    if (isObject(value)) {                        try {                            text += JSON.stringify(value, null, 4);                        } catch (e) {                            if (!isNull(e.description)) {                                e.description = 'Cannot stringify object: ' + e.description;                            }                            e.message = 'Cannot stringify object: ' + e.message;                            var $exception: IExceptionStatic = acquire(__ExceptionStatic);                            $exception.warn(e, $exception.PARSE);                        }                    } else if (!isNull(value)) {                        text += value;                    }                    if (expression.oneTime) {                        expressions[i] = NodeManager._wrapExpression(value);                    }                }                return text;            }            /**             * Registers a listener to be notified of a change in any associated identifier.             *              * @static             * @param identifiers An Array of identifiers to observe.             * @param control The control associated to the identifiers.             * @param listener The listener to call when any identifier property changes.             */            static observeIdentifiers(identifiers: Array<string>, control: ui.ITemplateControl,                listener: (...args: Array<any>) => void) {                var length = identifiers.length,                    $contextManager = NodeManager.$ContextManagerStatic,                    rootManager = $contextManager.getManager(Control.getRootControl(control)),                    absoluteContextPath = control.absoluteContextPath,                    context = control.context,                    observableCallback = {                        listener: listener,                        uid: control.uid                    },                    resources: IObject<{                        resource: ui.IResource;                        control: ui.ITemplateControl;                    }>  = {},                    resourceObj: {                        resource: ui.IResource;                        control: ui.ITemplateControl;                    },                    manager: observable.IContextManager,                    split: Array<string>,                    alias: string,                    absoluteIdentifier: string,                    identifier: string;                for (var i = 0; i < length; ++i) {                    identifier = identifiers[i];                    absoluteIdentifier = '';                    if (identifier[0] === '@') {                        // we found an alias                        split = identifier.split('.');                        alias = split.shift().substr(1);                        if (split.length > 0) {                            absoluteIdentifier = '.' + split.join('.');                        }                        resourceObj = resources[alias];                        if (isNull(resourceObj)) {                            resourceObj = resources[alias] = control.findResource(alias);                        }                        if (!isNull(resourceObj) && !isNull(resourceObj.resource) && resourceObj.resource.type === 'observable') {                            manager = $contextManager.getManager(resources[alias].control);                            absoluteIdentifier = 'resources.' + alias + '.value' + absoluteIdentifier;                        } else {                            continue;                        }                    } else {                        // look on the control.context                        split = identifier.split('.');                        if (!isNull($contextManager.getContext(context, split))) {                            manager = rootManager;                            absoluteIdentifier = absoluteContextPath + '.' + identifier;                        } else if (!isNull($contextManager.getContext(control, split))) {                            manager = null;                        } else {                            manager = rootManager;                            absoluteIdentifier = absoluteContextPath + '.' + identifier;                        }                    }                    if (!isNull(manager)) {                        manager.observe(absoluteIdentifier, observableCallback);                    }                }            }            /**             * A regular expression for finding markup             */            static _markupRegex: RegExp;            /**             * A regular expression for finding newline characters.             */            static _newLineRegex: RegExp;            /**             * Wraps constant text as an IParsedExpression.             *              * @param text The text to wrap.             */            static _wrapExpression(text: string): expressions.IParsedExpression {                return {                    evaluate: () => text,                    identifiers: [],                    aliases: [],                    expression: text                };            }            type: string;            isClone: boolean = false;            nodeMap: INodeMap;            parent: IElementManager;            initialize(nodeMap: INodeMap, parent: IElementManager): void {                this.nodeMap = nodeMap;                this.parent = parent;                if (!isNull(parent)) {                    this.isClone = parent.isClone;                    parent.children.push(this);                }            }            getParentControl(): ui.ITemplateControl {                var parent = this.parent,                    control: ui.ITemplateControl;                while (isNull(control)) {                    if (isNull(parent)) {                        break;                    }                    control = parent.getUiControl();                    parent = parent.parent;                }                return control;            }            clone(newNode: Node, parentManager: IElementManager): number {                return 1;            }            bind(): void { }        }        /**         * The Type for referencing the '$NodeManagerStatic' injectable as a dependency.         */        export function INodeManagerStatic(            $Regex?: expressions.IRegex,            $ContextManagerStatic?: observable.IContextManagerStatic,            $Parser?: expressions.IParser,            $TemplateControlFactory?: ui.ITemplateControlFactory): INodeManagerStatic {                NodeManager._markupRegex = $Regex.markupRegex;                NodeManager._newLineRegex = $Regex.newLineRegex;                NodeManager.$ContextManagerStatic = $ContextManagerStatic;                NodeManager.$Parser = $Parser;                NodeManager.$TemplateControlFactory = $TemplateControlFactory;                return NodeManager;        }        register.injectable(__NodeManagerStatic, INodeManagerStatic, [            __Regex,            __ContextManagerStatic,            __Parser,            __TemplateControlFactory        ], __STATIC);        /**         * The external interface for the '$NodeManagerStatic' injectable.         */        export interface INodeManagerStatic {            /**             * Given an IParsedExpression array, creates an array of unique identifers             * to use with binding. This allows us to avoid creating multiple listeners             * for the identifier and node.             *              * @static             * @param expressions An IParsedExpression array to search for identifiers.             * @returns {Array<string>} An array of identifiers.             */            findUniqueIdentifiers(expressions: Array<expressions.IParsedExpression>): Array<string>;            /**             * Determines if a string has the markup notation.             *              * @param text The text string in which to search for markup.             * @returns {Boolean} Indicates whether or not there is markup.             */            hasMarkup(text: string): boolean;            /**             * Given a string, finds markup in the string and creates an IParsedExpression array.             *              * @static             * @param text The text string to parse.             * @returns {Array<IParsedExpression>}             */            findMarkup(text: string): Array<expressions.IParsedExpression>;            /**             * Takes in data context and an IParsedExpression array and outputs a string of the evaluated             * expressions.             *              * @static             * @param expressions The IParsedExpression array to evaluate.             * @param control The IControl used to parse the expressions.             * @returns {string} The evaluated expressions.             */            build(expressions: Array<expressions.IParsedExpression>, control?: ui.ITemplateControl): string;            /**             * Registers a listener to be notified of a change in any associated identifier.             *              * @static             * @param identifiers An Array of identifiers to observe.             * @param control The control associated to the identifiers.             * @param listener The listener to call when any identifier property changes.             */            observeIdentifiers(identifiers: Array<string>,                control: ui.ITemplateControl, listener: (...args: Array<any>) => void): void;        }        /**         * Describes an object that takes a Node and provides a way to data-bind to that node.         */        export interface INodeManager {            /**             * The type of INodeManager             */            type: string;            /**             * The INodeMap for this INodeManager. Contains the compiled Node.             */            nodeMap?: INodeMap;            /**             * The parent manager for this INodeManager.             */            parent?: IElementManager;            /**             * Retrieves the parent control associated with the parent manager.             */            getParentControl? (): ui.ITemplateControl;            /**             * Clones this NodeManager with the new node.             *              * @param newNode The node used to clone this NodeManager.             * @param parentManager The parent IElementManager for the clone.             */            clone? (newNode: Node, parentManager: IElementManager): number;            /**             * Initializes the object's properties.             *              * @param nodeMap The INodeMap associated with this TextManager. We have to use an              * INodeMap instead of an INode so we can treat all INodeManagers the same.             * @param parent The parent IElementManager.             */            initialize?(nodeMap: INodeMap, parent: IElementManager): void;            /**             * The function used for data-binding a data context to the DOM.             */            bind(): void;        }        /**         * Describes a compiled Node.         */        export interface INode {            /**             * The control associated with the Node, if one exists.             */            control?: IControl;            /**             * The Node that is compiled.             */            node?: Node;            /**             * The name of the Node.             */            nodeName?: string;            /**             * Any IParsedExpressions contained in the Node.             */            expressions?: Array<expressions.IParsedExpression>;            /**             * Unique identifiers contained in the Node.             */            identifiers?: Array<string>;            /**             * The injector for a control associated with the Node, if one exists.             */            injector?: dependency.IInjector<IControl>;        }        /**         * Defines the interface for a compiled Element.         */        export interface IUiControlNode extends INode {            /**             * The control associated with the Element, if one exists.             */            control: ui.ITemplateControl;            /**             * The resources element defined as the control element's first             * element child.             */            resourceElement?: HTMLElement;        }        /**         * Describes a compiled Element with all          * associated nodes contained within its tag.         */        export interface INodeMap {            /**             * The Element that is compiled.             */            element?: HTMLElement;            /**             * The compiled attribute Nodes for the Element.             */            nodes: Array<INode>;            /**             * An object of key/value attribute pairs.             */            attributes?: IObject<string>;            /**             * The plat-context path for the next UIControl, if specified.             */            childContext?: string;            /**             * Indicates whether or not a IControl was found on the Element.             */            hasControl?: boolean;            /**             * The INode for the UIControl, if one was found for the Element.             */            uiControlNode?: IUiControlNode;        }        /**         * A class used to manage element nodes. Provides a way for compiling and binding the          * element/template. Also provides methods for cloning an ElementManager.         */        export class ElementManager extends NodeManager implements IElementManager {            static $Document: Document;            static $ManagerCache: storage.ICache<IElementManager>;            static $ResourcesFactory: ui.IResourcesFactory;            static $BindableTemplatesFactory: ui.IBindableTemplatesFactory;            /**             * Determines if the associated Element has controls that need to be instantiated or Attr nodes             * containing text markup. If controls exist or markup is found a new ElementManager will be created,             * else an empty INodeManager will be added to the Array of INodeManagers.             *               * @static             * @param element The Element to use to identifier markup and controls.             * @param parent The parent ui.ITemplateControl used for context inheritance.             */            static create(element: Element, parent?: IElementManager): IElementManager {                var name = element.nodeName.toLowerCase(),                    nodeName = name,                    injector = controlInjectors[name] || viewControlInjectors[name],                    noControlAttribute = true,                    hasUiControl = false,                    uiControlNode: IUiControlNode;                if (isNull(injector)) {                    if (element.hasAttribute('plat-control')) {                        name = element.getAttribute('plat-control').toLowerCase();                        injector = controlInjectors[name] || viewControlInjectors[name];                        noControlAttribute = false;                    } else if (element.hasAttribute('data-plat-control')) {                        name = element.getAttribute('data-plat-control').toLowerCase();                        injector = controlInjectors[name] || viewControlInjectors[name];                        noControlAttribute = false;                    }                }                if (!isNull(injector)) {                    var uiControl = <ui.ITemplateControl>injector.inject(),                        resourceElement = ElementManager.locateResources(element);                    uiControlNode = {                        control: uiControl,                        resourceElement: resourceElement,                        nodeName: name,                        expressions: [],                        injector: injector                    };                    hasUiControl = true;                    if (noControlAttribute) {                        element.setAttribute('plat-control', name);                    }                    var replacementType = uiControl.replaceWith,                        replaceWithDiv = replacementType === 'any' && noControlAttribute;                    if (!isEmpty(replacementType) && (replacementType !== 'any' || replaceWithDiv) &&                            replacementType.toLowerCase() !== nodeName) {                        if (replaceWithDiv) {                            replacementType = 'div';                        }                        var replacement = ElementManager.$Document.createElement(replacementType);                        if (replacement.nodeType === Node.ELEMENT_NODE) {                            element = replaceWith(element, <HTMLElement>replacement.cloneNode(true));                        }                    }                }                var attributes = element.attributes,                    elementMap = ElementManager._collectAttributes(attributes),                    manager = new ElementManager();                elementMap.element = <HTMLElement>element;                elementMap.uiControlNode = uiControlNode;                manager.initialize(elementMap, parent);                if (!(elementMap.hasControl || hasUiControl)) {                    manager.bind = () => { return []; };                } else {                    manager.setUiControlTemplate();                    return hasUiControl ? null : manager;                }                return manager;            }            /**             * Looks through the Node's child nodes to try and find any              * defined Resources in a <plat-resources> tags.             *              * @param node The node who may have Resources as a child node.             */            static locateResources(node: Node): HTMLElement {                var childNodes: Array<Node> = Array.prototype.slice.call(node.childNodes),                    childNode: Node;                while (childNodes.length > 0) {                    childNode = childNodes.shift();                    if (childNode.nodeName.toLowerCase() === 'plat-resources') {                        return <HTMLElement>node.removeChild(childNode);                    }                }                return null;            }            /**             * Clones an ElementManager with a new element.             *              * @static             * @param sourceManager The original IElementManager.             * @param parent The parent IElementManager for the new clone.             * @param element The new element to associate with the clone.             * @param newControl An optional control to associate with the clone.             * @param nodeMap The nodeMap used to clone this ElementManager.             */            static clone(sourceManager: IElementManager, parent: IElementManager,                element: Element, newControl?: ui.ITemplateControl, nodeMap?: INodeMap): IElementManager {                if (isNull(nodeMap)) {                    nodeMap = ElementManager._cloneNodeMap(sourceManager.nodeMap, element, parent.getUiControl() ||                        parent.getParentControl(), newControl);                }                var manager = new ElementManager();                manager.nodeMap = nodeMap;                manager.parent = parent;                if (!isNull(parent)) {                    parent.children.push(manager);                }                manager.replace = sourceManager.replace;                manager.replaceNodeLength = sourceManager.replaceNodeLength;                manager.hasOwnContext = sourceManager.hasOwnContext;                manager.isClone = true;                if (!nodeMap.hasControl && isNull(newControl)) {                    manager.bind = () => { return []; };                }                if (!isNull(newControl)) {                    ElementManager.$ManagerCache.put(newControl.uid, manager);                }                return manager;            }            /**             * Clones a UI Control with a new nodeMap.             *              * @static             * @param sourceMap The source INodeMap used to clone the UI Control             * @param parent The parent control of the clone.             */            static cloneUiControl(sourceMap: INodeMap, parent: ui.ITemplateControl): ui.ITemplateControl {                var uiControlNode = sourceMap.uiControlNode;                if (isNull(uiControlNode)) {                    return;                }                var uiControl = uiControlNode.control,                    newUiControl = <ui.ITemplateControl>uiControlNode.injector.inject(),                    resources = ElementManager.$ResourcesFactory.getInstance(),                    attributes: ui.IAttributesInstance = acquire(__AttributesInstance);                newUiControl.parent = parent;                parent.controls.push(newUiControl);                newUiControl.controls = [];                attributes.initialize(newUiControl, sourceMap.attributes);                newUiControl.attributes = attributes;                resources.initialize(newUiControl, uiControl.resources);                newUiControl.resources = resources;                ElementManager.$ResourcesFactory.addControlResources(newUiControl);                if (!isNull(uiControl.innerTemplate)) {                    newUiControl.innerTemplate = <DocumentFragment>uiControl.innerTemplate.cloneNode(true);                }                newUiControl.type = uiControl.type;                newUiControl.bindableTemplates = ElementManager.$BindableTemplatesFactory.create(newUiControl, uiControl.bindableTemplates);                newUiControl.replaceWith = uiControl.replaceWith;                return newUiControl;            }            /**             * Creates new nodes for an INodeMap corresponding to the element associated with the nodeMap or             * the passed-in element.             *              * @static             * @param nodeMap The nodeMap to populate with attribute nodes.             * @param parent The parent control for the new attribute controls.             * @param templateControl The TemplateControl linked to these AttributeControls if              * one exists.             * @param newElement An optional element to use for attributes (used in cloning).             * @param isClone Whether or not these controls are clones.             */            static createAttributeControls(nodeMap: INodeMap, parent: ui.ITemplateControl,                templateControl?: ui.ITemplateControl, newElement?: Element, isClone?: boolean): Array<INode> {                var nodes = nodeMap.nodes,                    element = isClone ? newElement : nodeMap.element,                    elementExists = !isNull(element);                if (elementExists && element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {                    return isClone ? ElementManager._copyAttributeNodes(nodes) : [];                }                var attributes = elementExists ? element.attributes : null,                    attrs = nodeMap.attributes,                    newAttributes: ui.IAttributesInstance,                    node: INode,                    injector: dependency.IInjector<IControl>,                    control: controls.IAttributeControl,                    newNodes: Array<INode> = [],                    length = nodes.length,                    nodeName: string,                    i: number;                for (i = 0; i < length; ++i) {                    node = nodes[i];                    nodeName = node.nodeName;                    injector = node.injector;                    control = null;                    if (!isNull(injector)) {                        control = <controls.IAttributeControl>injector.inject();                        node.control = control;                        control.parent = parent;                        control.element = <HTMLElement>element;                        newAttributes = acquire(__AttributesInstance);                        newAttributes.initialize(control, attrs);                        control.attributes = newAttributes;                        control.type = nodeName;                        if (!isString(control.uid)) {                            control.uid = uniqueId('plat_');                        }                        control.templateControl = templateControl;                    }                    if (isClone) {                        newNodes.push({                            control: control,                            expressions: node.expressions,                            identifiers: node.identifiers,                            node: !!attributes ?                                (attributes.getNamedItem(nodeName) || attributes.getNamedItem('data-' + nodeName)) :                                null,                            nodeName: nodeName,                            injector: injector                        });                        if (!isNull(control)) {                            if (!isNull(parent)) {                                parent.controls.push(control);                            }                            if (isFunction(control.initialize)) {                                control.initialize();                            }                        }                    }                }                if (!isClone) {                    nodes.sort((a, b) => {                        var aControl = <controls.IAttributeControl>a.control,                            bControl = <controls.IAttributeControl>b.control;                        if (isNull(aControl)) {                            return 1;                        } else if (isNull(bControl)) {                            return -1;                        }                        var aPriority = isNumber(aControl.priority) ? aControl.priority : 0,                            bPriority = isNumber(bControl.priority) ? bControl.priority : 0;                        return bPriority - aPriority;                    });                    for (i = 0; i < length; ++i) {                        node = nodes[i];                        control = <controls.IAttributeControl>node.control;                        if (!isNull(control)) {                            if (!isNull(parent)) {                                parent.controls.push(control);                            }                            if (isFunction(control.initialize)) {                                control.initialize();                            }                        }                    }                }                return newNodes;            }            /**             * Returns an instance of an ElementManager.             */            static getInstance(): IElementManager {                return new ElementManager();            }            /**             * Iterates over the attributes NamedNodeMap, creating an INodeMap. The INodeMap              * will contain injectors for all the IControls as well as parsed expressions             * and identifiers found for each Attribute (useful for data binding).             *              * @static             * @param attributes A NamedNodeMap to compile into an INodeMap             * @returns {INodeMap} The compiled NamedNodeMap             */            static _collectAttributes(attributes: NamedNodeMap): INodeMap {                var nodes: Array<INode> = [],                    attribute: Attr,                    name: string,                    value: string,                    childContext: expressions.IParsedExpression,                    childIdentifier: string,                    hasMarkup: boolean,                    hasMarkupFn = NodeManager.hasMarkup,                    findMarkup = NodeManager.findMarkup,                    findUniqueIdentifiers = NodeManager.findUniqueIdentifiers,                    $parser = NodeManager.$Parser,                    build = NodeManager.build,                    expressions: Array<expressions.IParsedExpression>,                    hasControl = false,                    injector: dependency.IInjector<IControl>,                    length = attributes.length,                    controlAttributes: IObject<string> = {},                    uniqueIdentifiers: Array<string>;                for (var i = 0; i < length; ++i) {                    attribute = attributes[i];                    value = attribute.value;                    name = attribute.name.replace(/^data-/i, '').toLowerCase();                    injector = controlInjectors[name] || viewControlInjectors[name];                    expressions = [];                    uniqueIdentifiers = [];                    if (name === 'plat-context') {                        if (value !== '') {                            childContext = $parser.parse(value);                            if (childContext.identifiers.length !== 1) {                                var $exception: IExceptionStatic = acquire(__ExceptionStatic);                                $exception.warn('Incorrect plat-context: ' +                                    value + ', must contain a single identifier.', $exception.COMPILE);                            }                            childIdentifier = childContext.identifiers[0];                        }                    } else if (name !== 'plat-control') {                        hasMarkup = hasMarkupFn(value);                        if (hasMarkup) {                            expressions = findMarkup(value);                            uniqueIdentifiers = findUniqueIdentifiers(expressions);                            if (uniqueIdentifiers.length === 0) {                                attribute.value = value = build(expressions);                            }                        }                        if (!hasControl && (hasMarkup || !isNull(injector))) {                            hasControl = true;                        }                        nodes.push({                            control: null,                            node: attribute,                            nodeName: name,                            expressions: expressions,                            identifiers: uniqueIdentifiers,                            injector: injector                        });                    }                    controlAttributes[camelCase(name)] = value;                }                return {                    element: null,                    attributes: controlAttributes,                    nodes: nodes,                    childContext: childIdentifier,                    hasControl: hasControl                };            }            /**             * Used to copy the attribute nodes during the cloning process.             *              * @static             * @param nodes The compiled INodes to be cloned.             * @returns {INodeMap} The cloned array of INodes.             */            static _copyAttributeNodes(nodes: Array<INode>): Array<INode> {                var newNodes: Array<INode> = [],                    length = nodes.length,                    node: INode;                for (var i = 0; i < length; ++i) {                    node = nodes[i];                    newNodes.push({                        identifiers: node.identifiers,                        expressions: node.expressions,                        nodeName: node.nodeName                    });                }                return newNodes;            }            /**             * Clones an INode with a new node.             *              * @static             * @param sourceNode The original INode.             * @param node The new node used for cloning.             * @param newControl An optional new control to associate with the cloned node.             * @returns {INode} The clones INode.             */            static _cloneNode(sourceNode: INode, node: Node, newControl?: ui.ITemplateControl): INode {                return {                    control: newControl,                    injector: sourceNode.injector,                    identifiers: sourceNode.identifiers,                    expressions: sourceNode.expressions,                    node: node,                    nodeName: sourceNode.nodeName                };            }            /**             * Clones an INodeMap with a new element.             *              * @static             * @param sourceMap The original INodeMap.             * @param element The new Element used for cloning.             * @param newControl An optional new control to associate with the element.             * @returns {INodeMap} The cloned INodeMap.             */            static _cloneNodeMap(sourceMap: INodeMap, element: Element,                parent: ui.ITemplateControl, newControl?: ui.ITemplateControl): INodeMap {                var hasControl = sourceMap.hasControl,                    nodeMap: INodeMap = {                        attributes: sourceMap.attributes,                        childContext: sourceMap.childContext,                        nodes: [],                        element: <HTMLElement>element,                        uiControlNode: !isNull(sourceMap.uiControlNode) ?                        <IUiControlNode>ElementManager._cloneNode(sourceMap.uiControlNode, element, newControl) : null,                        hasControl: hasControl                    };                if (hasControl) {                    nodeMap.nodes = ElementManager.createAttributeControls(sourceMap, parent, newControl, element, true);                }                return nodeMap;            }            $Promise: async.IPromise = acquire(__Promise);            $Compiler: ICompiler = acquire(__Compiler);            $ContextManagerStatic: observable.IContextManagerStatic = acquire(__ContextManagerStatic);            $CommentManagerFactory: ICommentManagerFactory = acquire(__CommentManagerFactory);            $ControlFactory: IControlFactory = acquire(__ControlFactory);            $TemplateControlFactory: ui.ITemplateControlFactory = acquire(__TemplateControlFactory);            children: Array<INodeManager> = [];            type: string = 'element';            replace: boolean = false;            replaceNodeLength: number;            hasOwnContext: boolean = false;            loadedPromise: async.IThenable<void>;            templatePromise: async.IThenable<void>;            clone(newNode: Node, parentManager: IElementManager, nodeMap?: INodeMap): number {                var childNodes: Array<Node>,                    clonedManager: IElementManager,                    replace = this.replace,                    nodeMapExists = !isNull(nodeMap),                    newControl = nodeMapExists ? nodeMap.uiControlNode.control : null,                    newControlExists = !isNull(newControl),                    startNodeManager: INodeManager,                    endNodeManager: INodeManager,                    parentControl = parentManager.getUiControl() || parentManager.getParentControl();                if (!newControlExists) {                    // create new control                    newControl = ElementManager.cloneUiControl(this.nodeMap, parentControl);                    newControlExists = !isNull(newControl);                }                if (replace) {                    // definitely have newControl                    var nodes = newNode.parentNode.childNodes,                        startIndex = Array.prototype.indexOf.call(nodes, newNode);                    childNodes = Array.prototype.slice.call(nodes, startIndex + 1, startIndex + this.replaceNodeLength);                    clonedManager = ElementManager.clone(this, parentManager, null, newControl, nodeMap);                    newControl.elementNodes = childNodes;                    newControl.startNode = newNode;                    newControl.endNode = childNodes.pop();                    startNodeManager = this.children.shift();                    endNodeManager = this.children.shift();                    startNodeManager.clone(newControl.startNode, clonedManager);                    endNodeManager.clone(newControl.endNode, clonedManager);                    if (isFunction(newControl.initialize)) {                        newControl.initialize();                    }                } else {                    childNodes = Array.prototype.slice.call(newNode.childNodes);                    clonedManager = ElementManager.clone(this, parentManager, <Element>newNode, newControl, nodeMap);                    nodeMap = clonedManager.nodeMap;                    if (newControlExists) {                        newControl.element = <HTMLElement>newNode;                        if (isFunction(newControl.initialize)) {                            newControl.initialize();                        }                    }                }                if (clonedManager.hasOwnContext) {                    postpone(() => {                        clonedManager.observeRootContext(newControl, clonedManager.bindAndLoad);                    });                }                var children = this.children,                    length = children.length,                    childNodeOffset = 0;                for (var i = 0; i < length; ++i) {                    // clone children                    childNodeOffset += children[i].clone(childNodes[childNodeOffset], clonedManager);                }                if (replace) {                    this.children.unshift(endNodeManager);                    this.children.unshift(startNodeManager);                    return childNodeOffset + 2;                }                return 1;            }            initialize(nodeMap: INodeMap, parent: IElementManager, dontInitialize?: boolean): void {                super.initialize(nodeMap, parent);                var parentControl = this.getParentControl(),                    controlNode = nodeMap.uiControlNode,                    control: ui.ITemplateControl,                    hasAttributeControl = nodeMap.hasControl,                    hasUiControl = !isNull(controlNode);                if (hasUiControl) {                    this._populateUiControl();                    control = controlNode.control;                    this.hasOwnContext = control.hasOwnContext;                }                if (hasAttributeControl) {                    ElementManager.createAttributeControls(nodeMap, parentControl, control);                }                if (!dontInitialize && hasUiControl && isFunction(control.initialize)) {                    control.initialize();                }            }            bind(): Array<IControl> {                var nodeMap = this.nodeMap,                    parent = this.getParentControl(),                    controlNode = nodeMap.uiControlNode,                    uiControl: ui.ITemplateControl,                    nodes = nodeMap.nodes,                    controls: Array<IControl> = [],                    hasParent = !isNull(parent),                    getManager = this.$ContextManagerStatic.getManager,                    contextManager: observable.IContextManager,                    absoluteContextPath = hasParent ? parent.absoluteContextPath : 'context',                    hasUiControl = !isNull(controlNode),                    replace = this.replace;                if (hasUiControl) {                    uiControl = controlNode.control;                    controls.push(uiControl);                    var childContext = nodeMap.childContext,                        $TemplateControlFactory = this.$TemplateControlFactory;                    if (!isNull(childContext)) {                        if (childContext[0] === '@') {                            var split = childContext.split('.'),                                alias = split.shift().substr(1),                                resourceObj = $TemplateControlFactory.findResource(uiControl, alias);                            if (!isNull(resourceObj)) {                                if (resourceObj.resource.type === 'observable') {                                    var identifier = (split.length > 0) ? '.' + split.join('.') : '';                                    absoluteContextPath = 'resources.' + alias + '.value' + identifier;                                    contextManager = getManager(resourceObj.control);                                    uiControl.root = resourceObj.control;                                } else {                                    var $exception: IExceptionStatic = acquire(__ExceptionStatic);                                    $exception.warn('Only resources of type observable can be set as context.',                                        $exception.CONTEXT);                                }                            }                        } else {                            absoluteContextPath = absoluteContextPath + '.' + childContext;                        }                    }                    uiControl.root = this.$ControlFactory.getRootControl(uiControl) || uiControl;                    contextManager = getManager(uiControl.root);                    if (!uiControl.hasOwnContext) {                        uiControl.context = contextManager.getContext(absoluteContextPath.split('.'));                    } else {                        absoluteContextPath = 'context';                    }                    (<any>uiControl).zCC__plat = contextManager.observe(absoluteContextPath, {                        uid: uiControl.uid,                        listener: (newValue, oldValue) => {                            uiControl.context = newValue;                        }                    });                    $TemplateControlFactory.setAbsoluteContextPath(uiControl, absoluteContextPath);                    $TemplateControlFactory.setContextResources(uiControl);                    ElementManager.$ResourcesFactory.bindResources(uiControl.resources);                    if (!replace) {                        var element = uiControl.element;                        if (!isNull(element) && isFunction(element.removeAttribute)) {                            element.removeAttribute(__Hide);                        }                    }                }                this._observeControlIdentifiers(nodes, parent, controls);                return controls;            }            setUiControlTemplate(templateUrl?: string): void {                var nodeMap = this.nodeMap,                    controlNode = nodeMap.uiControlNode,                    control: ui.ITemplateControl;                if (!isNull(controlNode)) {                    control = controlNode.control;                    this.templatePromise = this.$TemplateControlFactory.determineTemplate(control, templateUrl).then((template) => {                        this.templatePromise = null;                        this._initializeControl(control, <DocumentFragment>template.cloneNode(true));                    }, (error) => {                        this.templatePromise = null;                        if (isNull(error)) {                            this._initializeControl(control, error);                        } else {                            postpone(() => {                                var $exception: IExceptionStatic = acquire(__ExceptionStatic);                                $exception.fatal(error, $exception.COMPILE);                            });                        }                    });                    return;                }                if (!isNull(this.parent)) {                    return;                }                this.bindAndLoad();            }            getUiControl(): ui.ITemplateControl {                var uiControlNode = this.nodeMap.uiControlNode;                if (isNull(uiControlNode)) {                    return;                }                return uiControlNode.control;            }            fulfillTemplate(): async.IThenable<void> {                    if (!isNull(this.templatePromise)) {                        return this.templatePromise.then(() => {                            return this._fulfillChildTemplates();                        });                    }                return this._fulfillChildTemplates();            }            bindAndLoad(): async.IThenable<void> {                var children = this.children,                    length = children.length,                    child: INodeManager,                    promises: Array<async.IThenable<void>> = [],                    controls = this.bind();                for (var i = 0; i < length; ++i) {                    child = children[i];                    if ((<IElementManager>child).hasOwnContext) {                        promises.push((<IElementManager>child).loadedPromise);                        continue;                    }                    if (!isUndefined((<IElementManager>child).children)) {                        promises.push((<IElementManager>child).bindAndLoad());                    } else {                        child.bind();                    }                }                return this.$Promise.all(promises).then(() => {                    this._loadControls(<Array<controls.IAttributeControl>>controls, this.getUiControl());                }).catch((error: any) => {                    postpone(() => {                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);                        $exception.fatal(error, $exception.BIND);                    });                });            }            observeRootContext(root: ui.ITemplateControl, loadMethod: () => async.IThenable<void>): void {                if (!isNull(root.context)) {                    this.loadedPromise = loadMethod.call(this);                    return;                }                this.loadedPromise = new this.$Promise<void>((resolve, reject) => {                    var contextManager: observable.IContextManager = this.$ContextManagerStatic.getManager(root);                    var removeListener = contextManager.observe('context', {                        listener: () => {                            removeListener();                            loadMethod.call(this).then(resolve);                        },                        uid: root.uid                    });                }).catch((error) => {                    postpone(() => {                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);                        $exception.fatal(error, $exception.BIND);                    });                });            }            /**             * Observes the identifiers associated with this ElementManager's INodes.             *              * @param nodes The array of INodes to iterate through.             * @param parent The parent ITemplateControl for context.             * @param controls The array of controls whose attributes will need to be updated              * upon the context changing.             */            _observeControlIdentifiers(nodes: Array<INode>, parent: ui.ITemplateControl,                controls: Array<IControl>): void {                var length = nodes.length,                    bindings: Array<INode> = [],                    attributeChanged = this._attributeChanged,                    hasParent = !isNull(parent),                    node: INode,                    control: IControl;                for (var i = 0; i < length; ++i) {                    node = nodes[i];                    control = node.control;                    if (hasParent && node.identifiers.length > 0) {                        NodeManager.observeIdentifiers(node.identifiers, parent,                            attributeChanged.bind(this, node, parent, controls));                        bindings.push(node);                    }                    if (!isNull(control)) {                        controls.push(control);                    }                }                length = bindings.length;                for (i = 0; i < length; ++i) {                    this._attributeChanged(bindings[i], parent, controls);                }            }            /**             * Loads the AttributeControls associated with this ElementManager and              * attaches the corresponding ITemplateControl if available.             *              * @param controls The array of controls to load.             * @param templateControl The ITemplateControl associated with this              * ElementManager.             */            _loadControls(controls: Array<controls.IAttributeControl>,                templateControl: ui.ITemplateControl): void {                var length = controls.length,                    control: controls.IAttributeControl,                    load = this.$ControlFactory.load,                    hasTemplateControl = !isNull(templateControl),                    i = hasTemplateControl ? 1 : 0,                    templateControlPriority = hasTemplateControl ? templateControl.priority : Number.MIN_VALUE,                    templateControlLoaded = !hasTemplateControl;                for (; i < length; ++i) {                    control = controls[i];                    control.templateControl = templateControl;                    if (!templateControlLoaded && templateControlPriority > control.priority) {                        templateControlLoaded = true;                        load(templateControl);                    }                    load(control);                }                if (!templateControlLoaded) {                    load(templateControl);                }            }            /**             * Fulfills the template promise prior to binding and loading the control.             */            _fulfillAndLoad(): async.IThenable<void> {                return this.fulfillTemplate().then(() => {                    return this.bindAndLoad();                }).catch((error) => {                    postpone(() => {                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);                        $exception.fatal(error, $exception.BIND);                    });                });            }            /**             * Populates the ITemplateControl properties associated with this ElementManager              * if one exists.             */            _populateUiControl(): void {                var nodeMap = this.nodeMap,                    parent = this.getParentControl(),                    controlNode = nodeMap.uiControlNode,                    uiControl = controlNode.control,                    hasParent = !isNull(parent),                    element = nodeMap.element,                    attributes = nodeMap.attributes,                    newAttributes: ui.IAttributesInstance = acquire(__AttributesInstance);                ElementManager.$ManagerCache.put(uiControl.uid, this);                if (hasParent && uiControl.parent !== parent) {                    parent.controls.push(uiControl);                    uiControl.parent = parent;                }                if (isFunction(element.setAttribute)) {                    element.setAttribute(__Hide, '');                }                uiControl.element = element;                uiControl.controls = [];                newAttributes.initialize(uiControl, attributes);                uiControl.attributes = newAttributes;                if (!isNull(uiControl.resources)) {                    uiControl.resources.add(controlNode.resourceElement);                } else {                    var resources = ElementManager.$ResourcesFactory.getInstance();                    resources.initialize(uiControl, controlNode.resourceElement);                    uiControl.resources = resources;                }                ElementManager.$ResourcesFactory.addControlResources(uiControl);                uiControl.type = controlNode.nodeName;                if (!isString(uiControl.uid)) {                    uiControl.uid = uniqueId('plat_');                }                uiControl.bindableTemplates = uiControl.bindableTemplates ||                    ElementManager.$BindableTemplatesFactory.create(uiControl);                if ((element.childNodes.length > 0) &&                    (!isEmpty(uiControl.templateString) || !isEmpty(uiControl.templateUrl))) {                    uiControl.innerTemplate = <DocumentFragment>appendChildren(element.childNodes);                }                var replace = this.replace = (uiControl.replaceWith === null || uiControl.replaceWith === '');                if (replace) {                    this._replaceElement(uiControl, nodeMap);                }            }            /**             * Removes the ITemplateControl's element. Called if its replaceWith property is              * null or empty string.             *              * @param control The ITemplateControl whose element will be removed.             * @param nodeMap The INodeMap associated with this ElementManager.             */            _replaceElement(control: ui.ITemplateControl, nodeMap: INodeMap): void {                var element = nodeMap.element,                    parentNode = element.parentNode,                    $document = ElementManager.$Document,                    controlType = control.type,                    controlUid = control.uid,                    startNode = control.startNode = $document.createComment(controlType + ' ' + controlUid + __START_NODE),                    endNode = control.endNode = $document.createComment(controlType + ' ' + controlUid + __END_NODE),                    create = this.$CommentManagerFactory.create;                create(startNode, this);                create(endNode, this);                parentNode.insertBefore(startNode, element);                parentNode.insertBefore(endNode, element.nextSibling);                control.elementNodes = replace(element);                control.element = nodeMap.element = null;            }            /**             * Initializes a control's template and compiles the control.             *              * @param uiControl The ITemplateControl associated with this ElementManager.             * @param template The uiControl's template.             */            _initializeControl(uiControl: ui.ITemplateControl, template: DocumentFragment): void {                var element = this.nodeMap.element,                    // have to check if null since isNull checks for undefined case                    replaceElement = this.replace,                    hasOwnContext = uiControl.hasOwnContext,                    hasParent = !isNull(uiControl.parent),                    endNode: Node;                if (!isNull(template)) {                    var resourceElement = ElementManager.locateResources(template);                    if (!isNull(resourceElement)) {                        uiControl.resources.add(ElementManager.$ResourcesFactory.parseElement(resourceElement));                    }                    if (replaceElement) {                        endNode = uiControl.endNode;                        uiControl.elementNodes = Array.prototype.slice.call(template.childNodes);                        insertBefore(endNode.parentNode, template, endNode);                    } else {                        insertBefore(element, template, element.lastChild);                    }                }                if (isFunction(uiControl.setTemplate)) {                    uiControl.setTemplate();                }                if (replaceElement) {                    this.$Compiler.compile(uiControl.elementNodes, uiControl);                    var startNode = uiControl.startNode,                        parentNode = startNode.parentNode,                        childNodes: Array<Node> = Array.prototype.slice.call(parentNode.childNodes);                    endNode = uiControl.endNode;                    uiControl.elementNodes = childNodes.slice(childNodes.indexOf(startNode) + 1, childNodes.indexOf(endNode));                    this.replaceNodeLength = uiControl.elementNodes.length + 2;                } else {                    this.$Compiler.compile(element, uiControl);                }                if (hasOwnContext && !this.isClone) {                    this.observeRootContext(uiControl, this._fulfillAndLoad);                } else if (!hasParent) {                    this._fulfillAndLoad();                }            }            /**             * A function to handle updating an attribute on all controls that have it              * as a property upon a change in its value.             *              * @param node The INode where the change occurred.             * @param parent The parent ITemplateControl used for context.             * @param controls The controls that have the changed attribute as a property.             */            _attributeChanged(node: INode, parent: ui.ITemplateControl, controls: Array<IControl>): void {                var length = controls.length,                    key = camelCase(node.nodeName),                    attribute = <Attr>node.node,                    value = NodeManager.build(node.expressions, parent),                    attributes: ui.IAttributesInstance,                    oldValue: any;                for (var i = 0; i < length; ++i) {                    attributes = controls[i].attributes;                    oldValue = (<any>attributes)[key];                    (<any>attributes)[key] = value;                    attributes.attributeChanged(key, value, oldValue);                }                if (!this.replace) {                    attribute.value = value;                }            }            /**             * Runs through all the children of this manager and calls fulfillTemplate.             */            _fulfillChildTemplates(): async.IThenable<void> {                var children = this.children,                    child: INodeManager,                    length = children.length,                    promises: Array<async.IThenable<void>> = [];                for (var i = 0; i < length; ++i) {                    child = children[i];                    if (!isUndefined((<IElementManager>child).children)) {                        promises.push((<IElementManager>child).fulfillTemplate());                    }                }                return this.$Promise.all(promises).catch((error) => {                    postpone(() => {                        var $exception: IExceptionStatic = acquire(__ExceptionStatic);                        $exception.fatal(error, $exception.COMPILE);                    });                });            }        }        /**         * The Type for referencing the '$ElementManagerFactory' injectable as a dependency.         */        export function IElementManagerFactory(            $Document?: Document,            $ManagerCache?: storage.ICache<IElementManager>,            $ResourcesFactory?: ui.IResourcesFactory,            $BindableTemplatesFactory?: ui.IBindableTemplatesFactory): IElementManagerFactory {                ElementManager.$Document = $Document;                ElementManager.$ManagerCache = $ManagerCache;                ElementManager.$ResourcesFactory = $ResourcesFactory;                ElementManager.$BindableTemplatesFactory = $BindableTemplatesFactory;                return ElementManager;        }        register.injectable(__ElementManagerFactory, IElementManagerFactory, [            __Document,            __ManagerCache,            __ResourcesFactory,            __BindableTemplatesFactory        ], __FACTORY);        /**         * Creates and manages a class for dealing with Element nodes.         */        export interface IElementManagerFactory {            /**             * Determines if the associated Element has controls that need to be instantiated or Attr nodes             * containing text markup. If controls exist or markup is found a new ElementManager will be created,             * else an empty INodeManager will be added to the Array of INodeManagers.             *              * @static             * @param element The Element to use to identifier markup and controls.             * @param parent The parent ui.ITemplateControl used for context inheritance.             */            create(element: Element, parent?: IElementManager): IElementManager;            /**             * Creates new nodes for an INodeMap corresponding to the element associated with the nodeMap or             * the passed-in element.             *              * @static             * @param nodeMap The nodeMap to populate with attribute nodes.             * @param parent The parent control for the new attribute controls.             * @param templateControl The TemplateControl linked to these AttributeControls if              * one exists.             * @param newElement An optional element to use for attributes (used in cloning).             * @param isClone Whether or not these controls are clones.             */            createAttributeControls(nodeMap: INodeMap, parent: ui.ITemplateControl,                templateControl?: ui.ITemplateControl, newElement?: Element, isClone?: boolean): Array<INode>;            /**             * Clones a UI Control with a new nodeMap.             *              * @static             * @param sourceMap The source INodeMap used to clone the UI Control             * @param parent The parent control of the clone.             */            cloneUiControl(sourceMap: INodeMap, parent: ui.ITemplateControl): ui.ITemplateControl;            /**             * Clones an ElementManager with a new element.             *              * @static             * @param sourceManager The original IElementManager.             * @param parent The parent IElementManager for the new clone.             * @param element The new element to associate with the clone.             * @param newControl An optional control to associate with the clone.             * @param nodeMap The nodeMap used to clone this ElementManager.             */            clone(sourceManager: IElementManager, parent: IElementManager,                element: Element, newControl?: ui.ITemplateControl, nodeMap?: INodeMap): IElementManager;            /**             * Looks through the Node's child nodes to try and find any             * defined Resources in a <plat-resources> tags.             *              * @static             * @param node The node who may have Resources as a child node.             */            locateResources(node: Node): HTMLElement;            /**             * Returns a new instance of an IElementManager             *              * @static             */            getInstance(): IElementManager;        }        /**         * An ElementManager is responsible for initializing and data-binding controls associated to an Element.         *          */        export interface IElementManager extends INodeManager {            /**             * The child managers for this manager.             */            children: Array<INodeManager>;            /**             * Specifies whether or not this manager has a uiControl which has              * replaceWith set to null or empty string.             */            replace: boolean;            /**             * The length of a replaced control, indiates the number of nodes to slice              * out of the parent's childNodes.             */            replaceNodeLength: number;            /**             * Indicates whether the control for this manager hasOwnContext.             */            hasOwnContext: boolean;            /**             * Lets us know when an ElementManager is a cloned manager, or the compiled              * manager from BindableTemplates. We do not want to bindAndLoad compiled              * managers that are clones.             */            isClone: boolean;            /**             * In the event that a control hasOwnContext, we need a promise to fullfill              * when the control is loaded to avoid loading its parent control first.             */            loadedPromise: async.IThenable<void>;            /**             * A templatePromise set when a uiControl specifies a templateUrl.             */            templatePromise: async.IThenable<void>;            /**             * Clones the IElementManager with a new node.             *              * @param newNode The new element used to clone the ElementManager.             * @param parentManager The parent for the clone.             * @param nodeMap An optional INodeMap to clone a ui control if needed.             */            clone(newNode: Node, parentManager: IElementManager, nodeMap?: INodeMap): number;            /**             * Initializes all the controls associated to the ElementManager's nodeMap.              * The INodeManager array must be passed in because if this ElementManager is              * used for transclusion, it can't rely on one INodeManager array.             *              * @param parent The parent IElementManager.             * @param dontInitialize Specifies whether or not the initialize method should              * be called for a control.             * @param dontInitialize Specifies whether or not the initialize method should              * be called for a control.             */            initialize(nodeMap: INodeMap, parent: IElementManager, dontInitialize?: boolean): void;            /**             * Observes the root context for controls that specify their own context, and initiates              * a load upon a successful set of the context.             *              * @param root The ITemplateControl specifying its own context.             * @param loadMethod The function to initiate the loading of the root control and its              * children.             */            observeRootContext(root: ui.ITemplateControl, loadMethod: () => async.IThenable<void>): void;            /**             * Links the data context to the DOM (data-binding).             */            bind(): void;            /**             * Sets the template for an ElementManager by calling its associated UI Control's             * setTemplate method.             *              * @param templateUrl An optional templateUrl used to override the control's template.             */            setUiControlTemplate(templateUrl?: string): void;            /**             * Retrieves the UI control instance for this ElementManager.             */            getUiControl(): ui.ITemplateControl;            /**             * Fullfills any template template promises and finishes the compile phase             * for the template associated to this ElementManager.             */            fulfillTemplate(): async.IThenable<void>;            /**             * Binds context to the DOM and loads controls.             */            bindAndLoad(): async.IThenable<void>;        }        /**         * The class responsible for initializing and data-binding values to text nodes.         */        export class TextManager extends NodeManager implements ITextManager {            /**             * Determines if a text node has markup, and creates a TextManager if it does.             * A TextManager or empty TextManager will be added to the managers array.             *              * @static             * @param node The Node used to find markup.             * @param parent The parent ITemplateControl for the node.             */            static create(node: Node, parent: IElementManager): ITextManager {                var value = node.nodeValue,                    manager = new TextManager();                if (NodeManager.hasMarkup(value)) {                    var expressions = NodeManager.findMarkup(value),                        map = {                            nodes: [{                                node: node,                                expressions: expressions,                                identifiers: NodeManager.findUniqueIdentifiers(expressions),                            }]                        };                    manager.initialize(map, parent);                    return manager;                }                manager.initialize(null, parent);                manager.bind = noop;                return manager;            }            /**             * Clones an INodeMap with a new text node.             *              * @static             * @param sourceMap The original INodeMap.             * @param newNode The new text node used for cloning.             */            static _cloneNodeMap(sourceMap: INodeMap, newNode: Node): INodeMap {                var node = sourceMap.nodes[0],                    nodeMap: INodeMap = {                        nodes: [{                            identifiers: node.identifiers,                            expressions: node.expressions,                            nodeName: node.nodeName,                            node: newNode                        }]                    };                return nodeMap;            }            /**             * Clones a TextManager with a new text node.             *              * @static             * @param sourceManager The original INodeManager.             * @param node The new text node to associate with the clone.             * @param parent The parent IElementManager for the new clone.             */            static _clone(sourceManager: INodeManager, node: Node, parent: IElementManager): ITextManager {                var map = sourceManager.nodeMap,                    manager = new TextManager();                if (!isNull(map)) {                    manager.initialize(TextManager._cloneNodeMap(map, node), parent);                } else {                    manager.initialize(null, parent);                    manager.bind = noop;                }                return manager;            }            /**             * Specifies the type for this INodeManager.             */            type: string = 'text';            clone(newNode: Node, parentManager: IElementManager): number {                TextManager._clone(this, newNode, parentManager);                return 1;            }            bind(): void {                var parent = this.getParentControl(),                    node = this.nodeMap.nodes[0],                    textNode = node.node,                    expressions = node.expressions;                NodeManager.observeIdentifiers(node.identifiers, parent,                    this._setText.bind(this, textNode, parent, expressions));                this._setText(textNode, parent, expressions);            }            /**             * Builds the node expression and sets the value.             *              * @param Node The associated node whose value will be set.             * @param control The control whose context will be used to bind              * the data.             * @param expressions An array of parsed expressions used to build              * the node value.             */            _setText(node: Node, control: ui.ITemplateControl, expressions: Array<expressions.IParsedExpression>): void {                control = control || <ui.ITemplateControl>{};                node.nodeValue = NodeManager.build(expressions, control);            }        }        /**         * The Type for referencing the '$TextManagerFactory' injectable as a dependency.         */        export function ITextManagerFactory(): ITextManagerFactory {            return TextManager;        }        register.injectable(__TextManagerFactory, ITextManagerFactory, null, __FACTORY);        /**         * Creates and manages a class for dealing with Text nodes.         */        export interface ITextManagerFactory {            /**             * Determines if a text node has markup, and creates a TextManager if it does.             * A TextManager or empty TextManager will be added to the managers array.             *              * @static             * @param node The Node used to find markup.             * @param parent The parent ui.ITemplateControl for the node.             */            create(node: Node, parent?: IElementManager): ITextManager;        }        /**         * An object responsible for initializing and data-binding values to text nodes.         */        export interface ITextManager extends INodeManager {            /**             * Clones this ITextManager with a new node.             *              * @param newNode The new node attached to the cloned ITextManager.             * @param parentManager The parent IElementManager for the clone.             */            clone(newNode: Node, parentManager: IElementManager): number;            /**             * The function used for data-binding a data context to the DOM.             */            bind(): void;        }        /**         * A class used to manage Comment nodes. Provides a way to          * clone a Comment node.         */        export class CommentManager extends NodeManager implements ICommentManager {            /**             * Creates a new CommentManager for the given Comment node.             *              * @static             * @param node The Comment to associate with the new manager.             * @param parent The parent IElementManager.             */            static create(node: Node, parent: IElementManager): ICommentManager {                var manager = new CommentManager();                manager.initialize({                    nodes: [{                        node: node                    }]                }, parent);                return manager;            }            /**             * Specifies the type of INodeManager.             */            type: string = 'comment';            clone(newNode: Node, parentManager: IElementManager): number {                CommentManager.create(newNode, parentManager);                return 1;            }        }        /**         * The Type for referencing the '$CommentManagerFactory' injectable as a dependency.         */        export function ICommentManagerFactory(): ICommentManagerFactory {            return CommentManager;        }        register.injectable(__CommentManagerFactory, ICommentManagerFactory, null, __FACTORY);        /**         * Creates and manages a class for dealing with Comment nodes.         */        export interface ICommentManagerFactory {            /**             * Creates a new CommentManager for the given Comment node.             *              * @static             * @param node The Comment to associate with the new manager.             * @param parent The parent IElementManager.             */            create(node: Node, parent: IElementManager): ICommentManager;        }        /**         * An object used to manage Comment nodes.         */        export interface ICommentManager extends INodeManager {            /**             * A method for cloning this CommentManager.             *              * @param newNode The new Comment node to associate with the cloned             * manager.             * @param parentManager The parent IElementManager for the new clone.             */            clone(newNode: Node, parentManager: IElementManager): number;        }    }    export module navigation {        /**         * A class that defines the base Navigation properties and methods.         */        export class BaseNavigator implements IBaseNavigator {            $EventManagerStatic: events.IEventManagerStatic = acquire(__EventManagerStatic);            $NavigationEventStatic: events.INavigationEventStatic = acquire(__NavigationEventStatic);            $BaseViewControlFactory: ui.IBaseViewControlFactory = acquire(__BaseViewControlFactory);            $ContextManagerStatic: observable.IContextManagerStatic = acquire(__ContextManagerStatic);            uid: string;            baseport: ui.controls.IBaseport;            currentState: IBaseNavigationState;            navigating: boolean;            /**             * Define unique id and subscribe to the 'goBack' event             */            constructor() {                this.$ContextManagerStatic.defineGetter(this, 'uid', uniqueId('plat_'));                this.$EventManagerStatic.on(this.uid, 'goBack', this.goBack, this);            }            initialize(baseport: ui.controls.IBaseport): void {                this.baseport = baseport;            }            navigate(navigationParameter: any, options: IBaseNavigationOptions): void {                this.navigating = true;            }            navigated(control: ui.IBaseViewControl, parameter: any, options: IBaseNavigationOptions): void {                this.currentState = {                    control: control                };                this.navigating = false;                control.navigator = this;                control.navigatedTo(parameter);                this._sendEvent('navigated', control, control.type, parameter, options, false);            }            goBack(options?: IBaseBackNavigationOptions): void { }            dispose(): void { }            /**             * Sends a NavigationEvent with the given parameters.  The 'sender' property of the event will be the              * navigator.             *              * @param name The name of the event to send.             * @param target The target of the event, could be a view control or a route depending upon the navigator and              * event name.             * @param options The IBaseNavigationOptions used during navigation             * @param cancelable Whether or not the event can be cancelled, preventing further navigation.             */            _sendEvent(name: string, target: any, type: string, parameter: any,                options: IBaseNavigationOptions, cancelable: boolean): events.INavigationEvent<any> {                return this.$NavigationEventStatic.dispatch(name, this, {                    target: target,                    type: type,                    parameter: parameter,                    options: options,                    cancelable: cancelable                });            }        }        /**         * Defines the methods that a Navigator must implement.         */        export interface IBaseNavigator {            /**             * A unique identifier used to identify this navigator.             */            uid: string;            /**             * Every navigator will have a viewport with which to communicate and              * facilitate navigation.             */            baseport: ui.controls.IBaseport;            /**             * Set to true during navigate, set to false during navigated.             */            navigating: boolean;            /**             * Specifies the current state of navigation. This state should contain              * enough information for it to be pushed onto the history stack when              * necessary.             */            currentState: IBaseNavigationState;            /**             * Initializes a Navigator. The viewport will call this method and pass itself in so              * the navigator can store it and use it to facilitate navigation. Also subscribes to              * 'routeChanged' and 'beforeRouteChange' events in the case of a RoutingNavigator.             *              * @param baseport The baseport instance this navigator will be attached to.             */            initialize(baseport: ui.controls.IBaseport): void;            /**             * Allows a ui.IBaseViewControl to navigate to another ui.IBaseViewControl. Also allows for             * navigation parameters to be sent to the new ui.IBaseViewControl.             *              * @param navigationParameter An optional navigation parameter to send to the next ui.IBaseViewControl.             * @param options Optional IBaseNavigationOptions used for navigation.             */            navigate(navigationParameter: any, options?: IBaseNavigationOptions): void;            /**             * Called by the Viewport to make the Navigator aware of a successful navigation. The Navigator will             * in-turn call the app.navigated event.             *              * @param control The ui.IBaseViewControl to which the navigation occurred.             * @param parameter The navigation parameter sent to the control.             * @param options The INavigationOptions used during navigation.             */            navigated(control: ui.IBaseViewControl, parameter: any, options: IBaseNavigationOptions): void;            /**             * Every navigator must implement this method, defining what happens when a view              * control wants to go back.             *              * @param options Optional backwards navigation options of type IBaseBackNavigationOptions.             */            goBack(options?: IBaseBackNavigationOptions): void;            /**             * Clean up memory             */            dispose(): void;        }        /**         * Options that you can submit to the navigator in order         * to customize navigation.         */        export interface IBaseNavigationOptions {            /**             * Allows a ui.IBaseViewControl to leave itself out of the              * navigation history.             */            replace?: boolean;        }        /**         * Options that you can submit to the navigator during a backward         * navigation in order to customize the navigation.         */        export interface IBaseBackNavigationOptions {            /**             * Lets the Navigator know to navigate back a specific length              * in history.             */            length?: number;        }        /**         * Defines the base interface needing to be implemented in the history.         */        export interface IBaseNavigationState {            /**             * The view control associated with a history entry.             */            control: ui.IBaseViewControl;        }        /**         * The Navigator class allows ui.IViewControls to navigate within a Viewport.         * Every Viewport has its own Navigator instance, allowing multiple navigators to          * coexist in one app.         */        export class Navigator extends BaseNavigator implements INavigatorInstance {            history: Array<IBaseNavigationState> = [];            navigate(Constructor?: new (...args: any[]) => ui.IViewControl, options?: INavigationOptions): void;            navigate(injector?: dependency.IInjector<ui.IViewControl>, options?: INavigationOptions): void;            navigate(Constructor?: any, options?: INavigationOptions) {                options = options || <IBaseNavigationOptions>{};                var state = this.currentState || <IBaseNavigationState>{},                    viewControl = state.control,                    injector: dependency.IInjector<ui.IViewControl>,                    key: string,                    parameter = options.parameter,                    event: events.INavigationEvent<any>,                    baseport = this.baseport,                    BaseViewControlFactory = this.$BaseViewControlFactory;                event = this._sendEvent('beforeNavigate', Constructor, null, parameter, options, true);                if (event.cancelled) {                    return;                }                this.navigating = true;                BaseViewControlFactory.detach(viewControl);                if (isObject(parameter)) {                    parameter = _clone(parameter, true);                }                baseport.controls = [];                if (isFunction(Constructor.inject)) {                    injector = Constructor;                    key = (<dependency.IInjector<any>>Constructor).name;                } else {                    var keys = Object.keys(viewControlInjectors),                        control: dependency.IInjector<ui.IViewControl>;                    while (keys.length > 0) {                        key = keys.pop();                        control = <any>viewControlInjectors[key];                        if (control.Constructor === Constructor) {                            injector = control;                            break;                        }                    }                }                if (isNull(injector)) {                    var $exception: IExceptionStatic = acquire(__ExceptionStatic);                    $exception.fatal('Attempting to navigate to unregistered view control.', $exception.NAVIGATION);                }                event.target = injector;                event.type = key;                if (!isNull(viewControl)) {                    baseport.navigateFrom(viewControl).then(() => {                        BaseViewControlFactory.detach(viewControl);                        if (!options.replace) {                            this.history.push({ control: viewControl });                        }                        baseport.navigateTo(event);                    }).catch((error) => {                        postpone(() => {                            var Exception: IExceptionStatic = acquire(__ExceptionStatic);                            Exception.fatal(error, Exception.NAVIGATION);                        });                    });                    return;                }                // need to postpone so that the viewport can compile before the first navigation                postpone(() => {                    baseport.navigateTo(event);                });            }            goBack(options?: IBackNavigationOptions): void {                options = options || {};                var viewControl = this.currentState.control,                    length = isNumber(options.length) ? options.length : 1,                    Constructor = options.ViewControl,                    parameter = options.parameter,                    history = this.history,                    baseport = this.baseport;                if (history.length === 0) {                    this.$EventManagerStatic.dispatch('shutdown', this, this.$EventManagerStatic.DIRECT);                }                var event = this._sendEvent('beforeNavigate', viewControl, viewControl.type, parameter, options, true);                if (event.cancelled) {                    return;                }                var $exception: IExceptionStatic;                if (!isNull(Constructor)) {                    var index = this._findInHistory(Constructor);                    if (index > -1) {                        length = history.length - index;                    } else {                        $exception = acquire(__ExceptionStatic);                        $exception.warn('Cannot find ViewControl in navigation history.', $exception.NAVIGATION);                        return;                    }                }                if (!isNumber(length) || length > history.length) {                    $exception = acquire(__ExceptionStatic);                    $exception.warn('Not enough views in the navigation history in order to navigate back.',                        $exception.NAVIGATION);                    return;                }                baseport.navigateFrom(viewControl).then(() => {                    this.$BaseViewControlFactory.dispose(viewControl);                    var last: IBaseNavigationState = this._goBackLength(length);                    if (isNull(last)) {                        return;                    }                    viewControl = last.control;                    this.currentState = last;                    event.target = viewControl;                    event.type = viewControl.type;                    baseport.navigateTo(event);                }).catch((error) => {                    postpone(() => {                        var Exception: IExceptionStatic = acquire(__ExceptionStatic);                        Exception.fatal(error, Exception.NAVIGATION);                    });                });            }            canGoBack(): boolean {                return this.history.length > 0;            }            clearHistory(): void {                var history = this.history,                    dispose = this.$BaseViewControlFactory.dispose;                while (history.length > 0) {                    dispose(history.pop().control);                }            }            /**             * Finds the given constructor in the history stack. Returns the index in the history where             * the constructor is found, or -1 if no constructor is found.             *              * @param Constructor The view control constructor to search for in the history stack.             */            _findInHistory(Constructor: new (...args: any[]) => ui.IViewControl): number {                var history = this.history,                    length = history.length - 1,                    index = -1,                    control: any;                for (var i = length; i >= 0; --i) {                    control = history[i].control;                    if (control.constructor === Constructor) {                        index = i;                        break;                    }                }                return index;            }            /**             * This method takes in a length and navigates back in the history, returning the view control              * associated with length + 1 entries back in the history.  It disposes all the view controls              * encapsulated in the length.             */            _goBackLength(length?: number): IBaseNavigationState {                length = isNumber(length) ? length : 1;                var last: IBaseNavigationState,                    dispose = this.$BaseViewControlFactory.dispose,                    history = this.history;                while (length-- > 0) {                    if (!isNull(last) && !isNull(last.control)) {                        dispose(last.control);                    }                    last = history.pop();                }                return last;            }        }        /**         * The Type for referencing the '$Navigator' injectable as a dependency.         */        export function INavigatorInstance(): INavigatorInstance {            return new Navigator();        }        register.injectable(__NavigatorInstance, INavigatorInstance, null, __INSTANCE);        /**         * An object implementing INavigator allows ui.IViewControls to implement methods          * used to navigate within a Viewport.         */        export interface INavigatorInstance extends IBaseNavigator {            /**             * Contains the navigation history stack for the associated Viewport.             */            history: Array<IBaseNavigationState>;            /**             * Allows a ui.IViewControl to navigate to another ui.IViewControl. Also allows for             * navigation parameters to be sent to the new ui.IViewControl.             *              * @param Constructor The Constructor for the new ui.IViewControl. The Navigator will find the injector              * for the Constructor and create a new instance of the control.             * @param options Optional IBaseNavigationOptions used for Navigation.             */            navigate(Constructor?: new (...args: any[]) => ui.IViewControl, options?: INavigationOptions): void;            navigate(injector?: dependency.IInjector<ui.IViewControl>, options?: INavigationOptions): void;            /**             * Returns to the last visited ui.IViewControl.             *              * @param options Optional IBackNavigationOptions allowing the ui.IViewControl             * to customize navigation. Enables navigating back to a specified point in history as well             * as specifying a new templateUrl to use at the next ui.IViewControl.             */            goBack(options?: IBackNavigationOptions): void;            /**             * Lets the caller know if there are ui.IViewControls in the history, meaning the caller             * is safe to perform a backward navigation.             */            canGoBack(): boolean;            /**             * Clears the navigation history, disposing all the controls.             */            clearHistory(): void;        }        /**         * Options that you can submit to the Navigator in order         * to customize navigation.         */        export interface INavigationOptions extends IBaseNavigationOptions {            /**             * An optional parameter to send to the next ui.IViewControl.             */            parameter?: any;        }        /**         * Options that you can submit to the Navigator during a backward         * navigation in order to customize the navigation.         */        export interface IBackNavigationOptions extends IBaseBackNavigationOptions {            /**             * An optional parameter to send to the next ui.IViewControl.             */            parameter?: any;            /**             * A ui.IViewControl Constructor that the Navigator will             * use to navigate. The Navigator will search for an instance              * of the ui.IViewControl in its history and navigate to it.             */            ViewControl?: new (...args: any[]) => ui.IViewControl;        }        /**         * A Navigator class that utilizes routing capabilities. It is associated with a          * Routeport, thus only allowing one RoutingNavigator per app.         */        export class RoutingNavigator extends BaseNavigator implements IRoutingNavigator {            $Router: web.IRouter = acquire(__Router);            $Window: Window = acquire(__Window);            /**             * The routing information for the Routeport's current state.             */            currentState: IRouteNavigationState;            private __removeListeners: Array<IRemoveListener> = [];            private __historyLength = 0;            initialize(baseport: ui.controls.IBaseport): void {                this.__removeListeners.push(this.$EventManagerStatic.on(this.uid, 'routeChanged', this._onRouteChanged, this));                this.__removeListeners.push(this.$EventManagerStatic.on(this.uid, 'beforeRouteChange', this._beforeRouteChange, this));                super.initialize(baseport);            }            navigate(path: string, options?: web.IRouteNavigationOptions): void {                this.navigating = true;                if (!this.$Router.route(path, options)) {                    this.navigating = false;                }            }            navigated(control: ui.IBaseViewControl, parameter: web.IRoute<any>, options: web.IRouteNavigationOptions): void {                super.navigated(control, parameter, options);                this.currentState.route = parameter;            }            goBack(options?: IBaseBackNavigationOptions): void {                options = options || {};                this.__historyLength -= 2;                if (this.__historyLength < 0) {                    this.$EventManagerStatic.dispatch('shutdown', this, this.$EventManagerStatic.DIRECT);                }                this.$Router.goBack((isNumber(options.length) ? options.length : 1));            }            dispose(): void {                var listeners = this.__removeListeners;                while (listeners.length > 0) {                    listeners.pop()();                }            }            /**             * The method called prior to a route change event.             *              * @param ev The INavigationEvent containing information regarding the ViewControl, the routing information,              * and the Router.             */            _beforeRouteChange(ev: events.INavigationEvent<web.IRoute<any>>): void {                var event = this._sendEvent('beforeNavigate', ev.target, ev.type, ev.parameter, ev.options, true);                if (event.cancelled) {                    ev.cancel();                }            }            /**             * The method called when a route change is successfully performed and ViewControl navigation can occur.             *              * @param ev The INavigationEvent containing information regarding the ViewControl, the routing infomration,              * and the Router.             */            _onRouteChanged(ev: events.INavigationEvent<web.IRoute<any>>): void {                var state = this.currentState || <IRouteNavigationState>{},                    viewControl = state.control,                    injector = ev.target,                    baseport = this.baseport;                if (isNull(injector)) {                    return;                }                this.__historyLength++;                baseport.navigateFrom(viewControl).then(() => {                    this.$BaseViewControlFactory.dispose(viewControl);                    baseport.navigateTo(ev);                }).catch((error) => {                    postpone(() => {                        var Exception: IExceptionStatic = acquire(__ExceptionStatic);                        Exception.fatal(error, Exception.NAVIGATION);                    });                });            }        }        /**         * The Type for referencing the '$RoutingNavigator' injectable as a dependency.         */        export function IRoutingNavigator(): IRoutingNavigator {            return new RoutingNavigator();        }        register.injectable(__RoutingNavigator, IRoutingNavigator);        /**         * Defines the methods that a Navigator must implement if it chooses to utilize          * routing capabilities.         */        export interface IRoutingNavigator extends IBaseNavigator {            /**             * Allows a ui.IBaseViewControl to navigate to another ui.IBaseViewControl. Also allows for             * navigation parameters to be sent to the new ui.IBaseViewControl.             *              * @param path The url path to navigate to.             * @param options Optional INavigationOptions for ignoring the current ui.IBaseViewControl in the history as             * well as specifying a new templateUrl for the next ui.IBaseViewControl to use.             */            navigate(path: string, options?: web.IRouteNavigationOptions): void;            /**             * Called by the Viewport to make the Navigator aware of a successful navigation. The Navigator will             * in-turn call the app.navigated event.             *              * @param control The ui.IBaseViewControl to which the navigation occurred.             * @param parameter The navigation parameter sent to the control.             * @param options The INavigationOptions used during navigation.             */            navigated(control: ui.IBaseViewControl, parameter: web.IRoute<any>, options: web.IRouteNavigationOptions): void;            /**             * Returns to the last visited ui.IBaseViewControl.             *              * @param options Optional IBackNavigationOptions allowing the ui.IBaseViewControl             * to customize navigation. Enables navigating back to a specified point in history as well             * as specifying a new templateUrl to use at the next ui.IBaseViewControl.             */            goBack(options?: IBaseBackNavigationOptions): void;        }        /**         * Defines the route type interface implemented for current state and last state.         */        export interface IRouteNavigationState extends IBaseNavigationState {            /**             * The associated route information.             */            route: web.IRoute<any>;        }    }    /**     * @name App     * @memberof plat     * @kind class     *      * @implements {plat.IApp}     *      * @description     * Class for every app. This class contains hooks for Application Lifecycle Events      * as well as error handling.     */    export class App implements IApp {        /**         * @name $Compat         * @memberof plat.App         * @kind property         * @access public         * @static         *          * @type {plat.ICompat}         *          * @description         * Reference to the {@link plat.ICompat|ICompat} injectable.         */        static $Compat: ICompat;        /**         * @name $EventManagerStatic         * @memberof plat.App         * @kind property         * @access public         * @static         *          * @type {plat.events.IEventManagerStatic}         *          * @description         * Reference to the {@link plat.events.IEventManagerStatic|IEventManagerStatic} injectable.         */        static $EventManagerStatic: events.IEventManagerStatic;        /**         * @name $Document         * @memberof plat.App         * @kind property         * @access public         * @static         *          * @type {Document}         *          * @description         * Reference to the Document injectable.         */        static $Document: Document;        /**         * @name $Compiler         * @memberof plat.App         * @kind property         * @access public         * @static         *          * @type {plat.processing.ICompiler}         *          * @description         * Reference to the {@link plat.processing.ICompiler|ICompiler} injectable.         */        static $Compiler: processing.ICompiler;        /**         * @name $LifecycleEventStatic         * @memberof plat.App         * @kind property         * @access public         * @static         *          * @type {plat.events.ILifecycleEventStatic}         *          * @description         * Reference to the {@link plat.events.ILifecycleEventStatic|ILifecycleEventStatic} injectable.         */        static $LifecycleEventStatic: events.ILifecycleEventStatic;        /**         * @name start         * @memberof plat.App         * @kind function         * @access public         * @static         *          * @description         * A static method for initiating the app startup.         *          * @returns {void}         */        static start(): void {            if (!App.$Compat.isCompatible) {                var $exception: IExceptionStatic = acquire(__ExceptionStatic);                $exception.fatal('PlatypusTS only supports modern browsers where ' +                    'Object.defineProperty is defined', $exception.COMPAT);                return;            }            App.__addPlatCss();            var $EventManagerStatic = App.$EventManagerStatic;            $EventManagerStatic.dispose('__app__');            $EventManagerStatic.on('__app__', 'ready', App.__ready);            $EventManagerStatic.on('__app__', 'shutdown', App.__shutdown);            $EventManagerStatic.initialize();        }        /**         * @name registerApp         * @memberof plat.App         * @kind function         * @access public         * @static         *          * @description         * A static method called upon app registration. Primarily used          * to initiate a ready state in the case that amd is being used.         *          * @param {any} app The app instance.         *          * @returns {void}         */        static registerApp(app: any): void {            if (!isNull(App.app) && isString(App.app.uid)) {                App.$EventManagerStatic.dispose(App.app.uid);            }            App.app = app;            if (App.$Compat.amd) {                var $LifecycleEventStatic = App.$LifecycleEventStatic,                    dispatch = $LifecycleEventStatic.dispatch;                postpone(() => {                    dispatch('ready', $LifecycleEventStatic);                });            }        }        /**         * @name load         * @memberof plat.App         * @kind function         * @access public         * @static         *          * @description         * Kicks off compilation of the DOM from the specified node. If no node is specified,          * the default start node is document.body.         *          * @param {Node} node The node at which DOM compilation begins.         *          * @returns {void}         */        static load(node?: Node): void {            var $LifecycleEventStatic = App.$LifecycleEventStatic,                $compiler = App.$Compiler,                body = App.$Document.body,                head = App.$Document.head;            $LifecycleEventStatic.dispatch('beforeLoad', App);            if (isNull(node)) {                $compiler.compile(head);                body.setAttribute(__Hide, '');                $compiler.compile(body);                body.removeAttribute(__Hide);                return;            }            if (isFunction((<Element>node).setAttribute)) {                (<Element>node).setAttribute(__Hide, '');                $compiler.compile(node);                (<Element>node).removeAttribute(__Hide);            } else {                $compiler.compile(node);            }        }        /**         * @name app         * @memberof plat.App         * @kind property         * @access public         * @static         *          * @type {plat.IApp}         *          * @description         * The instance of the registered {@link plat.IApp|IApp}.         */        static app: IApp = null;        /**         * @name __ready         * @memberof plat.App         * @kind function         * @access private         * @static         *          * @description         * A static method called when the application is ready. It calls the app instance's          * ready function as well as checks for the presence of a module loader. If one exists,          * loading the DOM falls back to the app developer. If it doesn't, the DOM is loaded from          * document.body.         *          * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} for the app ready.         *          * @returns {void}         */        private static __ready(ev: events.ILifecycleEvent): void {            dependency.Injector.initialize();            if (!isNull(App.app)) {                App.__registerAppEvents(ev);            }            if (!App.$Compat.amd) {                App.load();            }        }        /**         * @name __shutdown         * @memberof plat.App         * @kind function         * @access private         * @static         *          * @description         * A static method called when the application wants to programmatically shutdown.         *          * @returns {void}         */        private static __shutdown(): void {            var app = (<any>navigator).app;            if (!isNull(app) && isFunction(app.exitApp)) {                app.exitApp();            }        }        /**         * @name __registerAppEvents         * @memberof plat.App         * @kind function         * @access private         * @static         *          * @description         * A static method called to register all the {@link plat.events.ILifecycleEvent|ILifecycleEvents} for an app instance.         *          * @returns {void}         */        private static __registerAppEvents(ev: events.ILifecycleEvent): void {            var app = App.app;            if (isFunction((<dependency.IInjector<any>>(<any>app)).inject)) {                App.app = app = (<dependency.IInjector<any>>(<any>app)).inject();            }            app.on('suspend', app.suspend);            app.on('resume', app.resume);            app.on('online', app.online);            app.on('offline', app.offline);            app.on('error', app.error);            if (isFunction(app.ready)) {                app.ready(ev);            }        }        /**         * @name __addPlatCss         * @memberof plat.App         * @kind function         * @access private         * @static         *          * @description         * We need to add [plat-hide] as a css property if platypus.css doesn't exist so we can use it to temporarily          * hide elements.         *          * @returns {void}         */        private static __addPlatCss(): void {            var $document = App.$Document;            if (App.$Compat.platCss) {                return;            } else if (!isNull($document.styleSheets) && $document.styleSheets.length > 0) {                (<CSSStyleSheet>$document.styleSheets[0]).insertRule('[plat-hide] { display: none !important; }', 0);                return;            }            var style = <HTMLStyleElement>document.createElement('style');            style.textContent = '[plat-hide] { display: none !important; }';            document.head.appendChild(style);        }        /**         * @name uid         * @memberof plat.App         * @kind property         * @access public         * @readonly         *          * @type {string}         *          * @description         * A unique id, created during instantiation.         */        uid: string;        /**         * @name constructor         * @memberof plat.App         * @kind function         * @access public         *          * @description         * Class for every app. This class contains hooks for Application Lifecycle Management (ALM)         * as well as error handling and navigation events.         *          * @returns {plat.App}         */        constructor() {            var ContextManager: observable.IContextManagerStatic = acquire(__ContextManagerStatic);            ContextManager.defineGetter(this, 'uid', uniqueId('plat_'));        }        /**         * @name suspend         * @memberof plat.App         * @kind function         * @access public         * @virtual         *          * @description         * Event fired when the app is suspended.         *          * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.         *          * @returns {void}         */        suspend(ev: events.ILifecycleEvent): void { }        /**         * @name resume         * @memberof plat.App         * @kind function         * @access public         * @virtual         *          * @description         * Event fired when the app resumes from the suspended state.         *          * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.         *          * @returns {void}         */        resume(ev: events.ILifecycleEvent): void { }        /**         * @name error         * @memberof plat.App         * @kind function         * @access public         * @virtual         *          * @description         * Event fired when an internal error occures.         *          * @param {plat.events.IErrorEvent<Error>} ev The {@link plat.events.IErrorEvent|IErrorEvent} object.         *          * @returns {void}         */        error(ev: events.IErrorEvent<Error>): void { }        /**         * @name ready         * @memberof plat.App         * @kind function         * @access public         * @virtual         *          * @description         * Event fired when the app is ready.         *          * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.         *          * @returns {void}         */        ready(ev: events.ILifecycleEvent): void { }        /**         * @name online         * @memberof plat.App         * @kind function         * @access public         * @virtual         *          * @description         * Event fired when the app regains connectivity and is now in an online state.         *          * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.         *          * @returns {void}         */        online(ev: events.ILifecycleEvent): void { }        /**         * @name offline         * @memberof plat.App         * @kind function         * @access public         * @virtual         *          * @description         * Event fired when the app loses connectivity and is now in an offline state.         *          * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.         *          * @returns {void}         */        offline(ev: events.ILifecycleEvent): void { }        /**         * @name dispatchEvent         * @memberof plat.App         * @kind function         * @access public         *          * @description         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to all          * listeners based on the {@link plat.events.EventManager.DIRECT|DIRECT} method. Propagation          * will always start with the sender, so the sender can both produce and consume the same event.         *          * @param {string} name The name of the event to send, cooincides with the name used in the         * {@link plat.App.on|app.on()} method.         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.         *          * @returns {void}         */        dispatchEvent(name: string, ...args: any[]): void {            App.$EventManagerStatic.dispatch(name, this, App.$EventManagerStatic.DIRECT, args);        }        /**         * @name on         * @memberof plat.App         * @kind function         * @access public         * @variation 0         *          * @description         * Registers a listener for a beforeNavigate event. The listener will be called when a beforeNavigate          * event is propagating over the app. Any number of listeners can exist for a single event name.          * This event is cancelable using the {@link plat.events.INavigationEvent.cancel|ev.cancel()} method,          * and thereby preventing the navigation.         *          * @param {string} name='beforeNavigate' The name of the event, cooinciding with the beforeNavigate event.         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the beforeNavigate event is fired.         *          * @returns {plat.IRemoveListener} A method for removing the listener.          */        on(name: 'beforeNavigate', listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;        /**         * @name on         * @memberof plat.App         * @kind function         * @access public         * @variation 1         *          * @description         * Registers a listener for a navigating event. The listener will be called when a navigating          * event is propagating over the app. Any number of listeners can exist for a single event name.          * This event is cancelable using the {@link plat.events.INavigationEvent.cancel|ev.cancel()} method,          * and thereby preventing the navigation.         *          * @param {string} name='navigating' The name of the event, cooinciding with the navigating event.         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the navigating          * event is fired.         *          * @returns {plat.IRemoveListener} A method for removing the listener.          */        on(name: 'navigating', listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;        /**         * @name on         * @memberof plat.App         * @kind function         * @access public         * @variation 2         *          * @description         * Registers a listener for a navigated event. The listener will be called when a navigated          * event is propagating over the app. Any number of listeners can exist for a single event name.          * This event is not cancelable.         *          * @param {string} name='navigated' The name of the event, cooinciding with the navigated event.         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the navigated          * event is fired.         *          * @returns {plat.IRemoveListener} A method for removing the listener.          */        on(name: 'navigated', listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;        /**         * @name on         * @memberof plat.App         * @kind function         * @access public         * @variation 3         *          * @description         * Registers a listener for a routeChanged event. The listener will be called when a routeChange event          * is propagating over the app. Any number of listeners can exist for a single event name.         *          * @param {string} eventName='routeChange' This specifies that the listener is for a routeChange event.         * @param {(ev: plat.events.INavigationEvent<plat.web.IRoute<any>>) => void} listener The method called          * when the routeChange is fired. The route argument will contain a parsed route.         * @returns {plat.IRemoveListener} A method for removing the listener.         */        on(name: 'routeChanged', listener: (ev: events.INavigationEvent<web.IRoute<any>>) => void): IRemoveListener;        /**         * @name on         * @memberof plat.App         * @kind function         * @access public         * @variation 4         *          * @description         * Registers a listener for a {@link plat.events.NavigationEvent|NavigationEvent}. The listener will be called          * when a NavigationEvent is propagating over the app. Any number of listeners can exist for a single event name.         *          * @param {string} name The name of the event, cooinciding with the {@link plat.events.NavigationEvent|NavigationEvent} name.         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the          * {@link plat.events.NavigationEvent|NavigationEvent} is fired.         *          * @returns {plat.IRemoveListener} A method for removing the listener.         */        on(name: string, listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;        /**         * @name on         * @memberof plat.App         * @kind function         * @access public         * @variation 5         *          * @description         * Registers a listener for a {@link plat.events.DispatchEvent|DispatchEvent}. The listener will be called when          * a DispatchEvent is propagating over the app. Any number of listeners can exist for a single event name.         *          * @param {string} name The name of the event, cooinciding with the DispatchEvent name.         * @param {(ev: plat.events.IDispatchEventInstance, ...args: Array<any>) => void} listener The method called when          * the DispatchEvent is fired.         *          * @returns {plat.IRemoveListener} A method for removing the listener.         */        on(name: string, listener: (ev: events.IDispatchEventInstance, ...args: any[]) => void): IRemoveListener {            return App.$EventManagerStatic.on(this.uid, name, listener, this);        }        /**         * @name load         * @memberof plat.App         * @kind function         * @access public         *          * @description         * Kicks off compilation of the DOM from the specified node. If no node is specified,          * the default start node is document.body. This method should be called from the app when          * using module loaders. If a module loader is in use, the app will delay loading until          * this method is called.         *          * @param {Node} node The node where at which DOM compilation begins.         *          * @returns {void}         */        load(node?: Node): void {            App.load(node);        }    }    /**     * The Type for referencing the '$AppStatic' injectable as a dependency.     */    export function IAppStatic(        $Compat?: ICompat,        $EventManagerStatic?: events.IEventManagerStatic,        $Document?: Document,        $Compiler?: processing.ICompiler,        $LifecycleEventStatic?: events.ILifecycleEventStatic): IAppStatic {            App.$Compat = $Compat;            App.$EventManagerStatic = $EventManagerStatic;            App.$Document = $Document;            App.$Compiler = $Compiler;            App.$LifecycleEventStatic = $LifecycleEventStatic;            return App;    }    register.injectable(__AppStatic, IAppStatic, [        __Compat,        __EventManagerStatic,        __Document,        __Compiler,        __LifecycleEventStatic    ], __STATIC);    /**     * The Type for referencing the '$App' injectable as a dependency.     */    export function IApp($AppStatic?: IAppStatic): IApp {        return $AppStatic.app;    }    register.injectable(__App, IApp, [__AppStatic], __INSTANCE);    /**     * @name IAppStatic     * @memberof plat     * @kind interface     *      * @description     * The external interface for the '$AppStatic' injectable.     */    export interface IAppStatic {        /**         * @name start         * @memberof plat.IAppStatic         * @kind function         * @access public         * @static         *          * @description         * A static method for initiating the app startup.         *          * @returns {void}         */        start(): void;        /**         * @name registerApp         * @memberof plat.IAppStatic         * @kind function         * @access public         * @static         *          * @description         * A static methods called upon app registration. Primarily used          * to initiate a ready state in the case that amd is being used.         *          * @returns {void}         */        registerApp(app: dependency.IInjector<IApp>): void;        /**         * @name load         * @memberof plat.IAppStatic         * @kind function         * @access public         * @static         *          * @description         * Kicks off compilation of the DOM from the specified node. If no node is specified,         * the default start node is document.body.         *          * @param node The node at which DOM compilation begins.         *          * @returns {void}         */        load(node?: Node): void;        /**         * @name app         * @memberof plat.IAppStatic         * @kind property         * @access public         * @static         *          * @type {plat.IApp}         *          * @description         * The instance of the registered {@link plat.IApp|IApp}.         */        app: IApp;    }    /**     * @name IApp     * @memberof plat     * @kind interface     *      * @description     * An object implementing IApp implements the methods called by the framework to support      * Application Lifecycle Management (ALM) as well as error handling and navigation events.     */    export interface IApp {        /**         * @name uid         * @memberof plat.IApp         * @kind property         * @access public         * @readonly         *          * @type {string}         *          * @description         * A unique id, created during instantiation.         */        uid: string;        /**         * @name suspend         * @memberof plat.IApp         * @kind function         * @access public         * @virtual         *          * @description         * Event fired when the app is suspended.         *          * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.         *          * @returns {void}         */        suspend? (ev: events.ILifecycleEvent): void;        /**         * @name resume         * @memberof plat.IApp         * @kind function         * @access public         * @virtual         *          * @description         * Event fired when the app resumes from the suspended state.         *          * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.         *          * @returns {void}         */        resume? (ev: events.ILifecycleEvent): void;        /**         * @name error         * @memberof plat.IApp         * @kind function         * @access public         * @virtual         *          * @description         * Event fired when an internal error occures.         *          * @param {plat.events.IErrorEvent} ev The {@link plat.events.IErrorEvent|IErrorEvent} object.         *          * @returns {void}         */        error? (ev: events.IErrorEvent<Error>): void;        /**         * @name ready         * @memberof plat.IApp         * @kind function         * @access public         * @virtual         *          * @description         * Event fired when the app is ready.         *          * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.         *          * @returns {void}         */        ready? (ev: events.ILifecycleEvent): void;        /**         * @name online         * @memberof plat.IApp         * @kind function         * @access public         * @virtual         *          * @description         * Event fired when the app regains connectivity and is now in an online state.         *          * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.         *          * @returns {void}         */        online? (ev: events.ILifecycleEvent): void;        /**         * @name offline         * @memberof plat.IApp         * @kind function         * @access public         * @virtual         *          * @description         * Event fired when the app loses connectivity and is now in an offline state.         *          * @param {plat.events.ILifecycleEvent} ev The {@link plat.events.ILifecycleEvent|ILifecycleEvent} object.         *          * @returns {void}         */        offline? (ev: events.ILifecycleEvent): void;        /**         * @name dispatchEvent         * @memberof plat.IApp         * @kind function         * @access public         *          * @description         * Creates a new {@link plat.events.DispatchEvent|DispatchEvent} and propagates it to all          * listeners based on the {@link plat.events.EventManager.DIRECT|DIRECT} method. Propagation          * will always start with the sender, so the sender can both produce and consume the same event.         *          * @param {string} name The name of the event to send, cooincides with the name used in the         * {@link plat.App.on|app.on()} method.         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.         *          * @returns {void}         */        dispatchEvent(name: string, ...args: any[]): void;        /**         * @name on         * @memberof plat.IApp         * @kind function         * @access public         * @variation 0         *          * @description         * Registers a listener for a beforeNavigate event. The listener will be called when a beforeNavigate          * event is propagating over the app. Any number of listeners can exist for a single event name.          * This event is cancelable using the {@link plat.events.INavigationEvent.cancel|ev.cancel()} method,          * and thereby preventing the navigation.         *          * @param {string} name='beforeNavigate' The name of the event, cooinciding with the beforeNavigate event.         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the beforeNavigate event is fired.         *          * @returns {plat.IRemoveListener} A method for removing the listener.          */        on(name: 'beforeNavigate', listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;        /**         * @name on         * @memberof plat.IApp         * @kind function         * @access public         * @variation 1         *          * @description         * Registers a listener for a navigating event. The listener will be called when a navigating          * event is propagating over the app. Any number of listeners can exist for a single event name.          * This event is cancelable using the {@link plat.events.INavigationEvent.cancel|ev.cancel()} method,          * and thereby preventing the navigation.         *          * @param {string} name='navigating' The name of the event, cooinciding with the navigating event.         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the navigating          * event is fired.         *          * @returns {plat.IRemoveListener} A method for removing the listener.          */        on(name: 'navigating', listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;        /**         * @name on         * @memberof plat.IApp         * @kind function         * @access public         * @variation 2         *          * @description         * Registers a listener for a navigated event. The listener will be called when a navigated          * event is propagating over the app. Any number of listeners can exist for a single event name.          * This event is not cancelable.         *          * @param {string} name='navigated' The name of the event, cooinciding with the navigated event.         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the navigated          * event is fired.         *          * @returns {plat.IRemoveListener} A method for removing the listener.          */        on(name: 'navigated', listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;        /**         * @name on         * @memberof plat.IApp         * @kind function         * @access public         * @variation 3         *          * @description         * Registers a listener for a routeChanged event. The listener will be called when a routeChange event          * is propagating over the app. Any number of listeners can exist for a single event name.         *          * @param {string} eventName='routeChange' This specifies that the listener is for a routeChange event.         * @param {(ev: plat.events.INavigationEvent<plat.web.IRoute<any>>) => void} listener The method called          * when the routeChange is fired. The route argument will contain a parsed route.         * @returns {plat.IRemoveListener} A method for removing the listener.         */        on(name: 'routeChanged', listener: (ev: events.INavigationEvent<web.IRoute<any>>) => void): IRemoveListener;        /**         * @name on         * @memberof plat.IApp         * @kind function         * @access public         * @variation 4         *          * @description         * Registers a listener for a {@link plat.events.NavigationEvent|NavigationEvent}. The listener will be called          * when a NavigationEvent is propagating over the app. Any number of listeners can exist for a single event name.         *          * @param {string} name The name of the event, cooinciding with the {@link plat.events.NavigationEvent|NavigationEvent} name.         * @param {(ev: plat.events.INavigationEvent<any>) => void} listener The method called when the          * {@link plat.events.NavigationEvent|NavigationEvent} is fired.         *          * @returns {plat.IRemoveListener} A method for removing the listener.         */        on(name: string, listener: (ev: events.INavigationEvent<any>) => void): IRemoveListener;        /**         * @name on         * @memberof plat.IApp         * @kind function         * @access public         * @variation 5         *          * @description         * Registers a listener for a {@link plat.events.DispatchEvent|DispatchEvent}. The listener will be called when          * a DispatchEvent is propagating over the app. Any number of listeners can exist for a single event name.         *          * @param {string} name The name of the event, cooinciding with the DispatchEvent name.         * @param {(ev: plat.events.IDispatchEventInstance, ...args: Array<any>) => void} listener The method called when          * the DispatchEvent is fired.         *          * @returns {plat.IRemoveListener} A method for removing the listener.         */        on(name: string, listener: (ev: events.IDispatchEventInstance, ...args: any[]) => void): IRemoveListener;        /**         * @name load         * @memberof plat.IApp         * @kind function         * @access public         *          * @description         * Kicks off compilation of the DOM from the specified node. If no node is specified,          * the default start node is document.body. This method should be called from the app when          * using module loaders. If a module loader is in use, the app will delay loading until          * this method is called.         *          * @param {Node} node The node where at which DOM compilation begins.         *          * @returns {void}         */        load(node?: Node): void;    }    /**     * @name IObject     * @memberof plat     * @kind interface     *      * @description     * Interface for an object where every key has the same typed value.     *      * @typeparam {any} T The type of each value in the object.     */    export interface IObject<T> {        /**         * @name [key: string]         * @memberof plat.IObject         * @kind property         * @access public         * @static         *          * @type {T}         *          * @description         * Every key must be of type T         */        [key: string]: T    }    /**     * @name IRemoveListener     * @memberof plat     * @kind interface     *      * @description     * Defines a function that will halt further callbacks to a listener.     * Equivalent to `() => void`.     */    export interface IRemoveListener {        /**         * @memberof plat.IRemoveListener         * @kind function         * @access public         * @static         *          * @description         * The method signature for {@link plat.IRemoveListener|IRemoveListener}.         *          * @returns {void}         */        (): void;    }    /**     * @name IPropertyChangedListener     * @memberof plat     * @kind interface     *      * @description     * Defines a function that will be called whenever a property has changed.     */    export interface IPropertyChangedListener {        /**         * @memberof plat.IPropertyChangedListener         * @kind function         * @access public         * @static         *          * @description         * The method signature for {@link plat.IPropertyChangedListener|IPropertyChangedListener}.         *          * @param {any} newValue The new value of the observed property.         * @param {any} oldValue The previous value of the observed property.         *          * @returns {void}         */        (newValue: any, oldValue: any): void;    }}/* tslint:enable */